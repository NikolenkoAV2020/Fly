//-------------------------------------------------------------------------------
// ModISAManager.cpp
// А. Николенко 29.08.2018
//
// Диспетчер индексов солнечной активности.
// Предназначен для загрузки из вне массивов индексов СА, формирования их значений
// на заданный момент времени по этим массивам и/или прогнозирования индексов 
// на заданный момент времени и предоставления данных значений модели движения
// с целю расчёта параметров динамичекой атмосыеры
//------------------------------------------------------------------------------- 
#include <stdafx.h>
#pragma   hdrstop
#include <FlyMMath.h>	// Математические функции
#include <FlyTime.h>	// Всё про время

#include <FlyCoreSource\\ModType.h>
#include <FlyCoreSource\\ModGlobal.h>
#include <FlyCoreSource\\ZCISAManager.h>

//------------------------------------------------------------------------------- 
ZCISAManager::ZCISAManager()
{
	MJDBegin = 0 ; 
	MJDEnd   = 0 ; 
	MJDEndForecast = 0 ; 

	isInit = false ;
	lastta = 0 ;
	lastF107 = 125.0 ;
	lastF81  = 125.0 ;
	lastKP   = 2 ;
}

//------------------------------------------------------------------------------- 
ZCISAManager::~ZCISAManager()
{
	isInit = false ;
}

//------------------------------------------------------------------------------- 
int ZCISAManager::Init()
{
	isInit = true ;
	return 0 ; 
}

//------------------------------------------------------------------------------- 
int ZCISAManager::Load()
{
	return 0 ; 
}

//------------------------------------------------------------------------------- 
int ZCISAManager::UpdateToTime(double ta, double tau)
{
	SelectFrom(ta) ;
	return 0 ;
}

//------------------------------------------------------------------------------- 
int ZCISAManager::SelectFrom(double ta)
{
	// При необходимости инициализация
	if (!isInit) Init() ;
	// Проверка времени для которого был проведён последний запрос
	// Если время тоже самое то выборку значения индексов не выполняем
	if (fabs(lastta-ta)<1e-10) return 0 ;

	// Выборка индексов СА

	// Сохраняем время для которого выполнялся последний запрос индексов
	lastta = ta ;
	return 0 ;
}

//------------------------------------------------------------------------------- 
int ZCISAManager::AverageF107t0F81(double ta, int count, double tau)
{
	double F107[81] ; memset(F107, 0, sizeof(F107)) ;
	double Wi ;
	double WS = 0 ;
	double FS = 0 ;
	int    i ;
	// Учёт запаздывания значения индексов
	ta+= tau ;
	// Загрузка массива F107[81] - 81 значение суточного индекса F107
	// на интервале 80 суток предшествующих моменту времени ta
	// F107[0] - индекс на момент времени ta-80 ссс
	// F107[1] - индекс на момент времени ta-79 ссс
	// ............................................
	// F107[80]- индекс на момент времени ta
	for (i=-80; i<1; i++) {
		F107[i+80] = lastF107 ;
	}
	// Расчёт средне-взвешенного значения
	for (i=-80; i<1; i++) {
		Wi = 1.0+0.5*(double)i/80.0 ;
		WS+= Wi ;
		FS+= Wi*F107[i+80] ;
	}
	lastF81 = FS/WS ;
	return 0 ;
}

//------------------------------------------------------------------------------- 
ISAITEM ZCISAManager::ISA()
{
	ISAITEM I ;
	I.type= IsaFixed ;
	I.MJD = lastta ; 
	I.F107= F107() ;
	I.F81 = F81() ;
	I.KP  = KP() ;
	return I ;
}

//------------------------------------------------------------------------------- 
double ZCISAManager::F107()
{
	return lastF107 ;
}

//------------------------------------------------------------------------------- 
double ZCISAManager::F81()
{
	return lastF81 ;
}

//------------------------------------------------------------------------------- 
double ZCISAManager::AP()
{
	return KpAp(lastKP) ;
}

//------------------------------------------------------------------------------- 
double ZCISAManager::KP()
{
	return lastKP ;
}

//------------------------------------------------------------------------------- 
//  Функции перевода индекса Ap в индекс Kp и обратно
//------------------------------------------------------------------------------- 
static double T_Ap[28] = {
	0.,		2.,		3.,		4.,		5.,		6.,		7.,
    9.,		12.,	15.,	18.,	22.,	27.,	32.,
	39.,	48.,	56.,	67.,	80.,	94.,	111.,
	132.,	154.,	179.,	207.,	236.,	300.,	400.
};

//------------------------------------------------------------------------------- 
//  Функция перевода индекса Ap в индекс Kp
//------------------------------------------------------------------------------- 
double ZCISAManager::ApKp(double Ap)
{
	short i ;
	// Защита от некорректных значений
	if (Ap<=  0.0) return 0.0 ;
	if (Ap>=400.0) return 9.0 ;
	// Поиск индекса подинтервала
	for (i=0; i<27; i++) if (Ap<=T_Ap[i+1]) break ;
	return (i+(Ap-T_Ap[i])/(T_Ap[i+1]-T_Ap[i]))/3.0 ;
}

//---------------------------------------------------------------------------
//  Функция перевода индекса Kp в индекс Ap
//---------------------------------------------------------------------------
double ZCISAManager::KpAp(double Kp)
{
	// Kp  может принимать значения от 0.0 до 9.0 с шагом 0.3333333333333333333333
	// Ap  может принимать значения от 0.0 до 400 
	short i;
	double D_Kp;
	// Защита от некорректных значений
	if(Kp<=0.) return 0.;
	if(Kp>=9.) return 400.;
	// Поиск индекса подинтервала
	D_Kp = Kp*3. ;
	i = (short) D_Kp ;
	D_Kp-= (double)i ;
	return T_Ap[i]+(T_Ap[i+1]-T_Ap[i])*D_Kp ;
}

//---------------------------------------------------------------------------

