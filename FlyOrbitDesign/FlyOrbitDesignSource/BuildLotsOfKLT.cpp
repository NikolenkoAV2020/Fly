//-------------------------------------------------------------------------------
// BuildLotsOfKLT.cpp : 
// ј. Ќиколенко 15.01.2019
//-------------------------------------------------------------------------------
#include "stdafx.h"

//-------------------------------------------------------------------------------
//  омпоненты Fly
#include <FlyCore.h>		// —обственоно сама модель движени€
#include <FlyMMath.h>		// ћатематические функции

//-------------------------------------------------------------------------------
// ѕостроение множества возможных суточных кратностей (VKL)
//
// maxD = 1.0/14.0	ћаксимальное значение рационального числа
// minD = 1.0/16.0	ћинимальное значение рационального числа
// K0 = 1			Ќачальное (минимальное) значение числител€
// KM = 14			ћаксимальное значение числител€
// L0 = 14			Ќачальное (минимальное) значение знаменател€
// LM = 224			ћаксимальное значение знаменател€
//-------------------------------------------------------------------------------
void BuildLotsOfKLT(double minD, double maxD, int K0, int KM, int L0, int LM, VKLTOrb& VKL)
{
	// “екущие значени€ числител€ и знаменател€ и рац-го числа
	int    K, L ;
	double D ;
	KLTOrb KLT ;
	//
	int LN=L0;
	for (K=K0; K<KM; K++) {
		// ¬ариаци€ значени€ щнаменател€ от начального значени€ LN
		// до максимального, с контролем на минимальное значение 
		// полученного рационального числа K/L>=nimD.
		for (L=LN; L<=LM; L++) {
			// «начение рационального числа
			D = (double)K/(double)L ;
			// ѕроверка на выход из допустимого диапазона
			// (проверка на минимальное значение)
			if (D<minD) break ;

			// —окращЄнные значени€ числител€ и знаменател€
			int KI, LI ;
			// —окращение дроби 
			IsItCompletelyDivided(K, L, KI, LI) ;

			// ѕроверка на существование в списке VKL точно
			// такой же дроби. ≈сли это так, то полученное значение
			// как повторное просто пропускаетс€
			int  N = VKL.size() ;		// –азмер списка найденных чисел
			// Ќеобходимость пропутить найденное число как повторение
			bool needBreak = false ;	
			// ѕеребор всех найденных ранее рациональных чисел
			for (int i=0; i<N; i++) {
				if (VKL[i].K==KI && VKL[i].L==LI) {
					// “акое рациональное число уже есть
					needBreak = true ;
					break ;
				}
				if (VKL[i].K>KI) break ;
			}
			// ѕропускаем архивирование, так как найдено повторение
			if (needBreak) continue ;

			// јрхивирование найденного значени€
			KLT.K = KI ;
			KLT.L = LI ;
			KLT.T = D ;
			VKL.push_back(KLT) ;
		}
		// Ќовое начальное значение LN (знаменател€)
		LN = (int)((double)L0/(double)K0*(K+1))+1 ;
		// «начение K (числител€) измени€етс€ в операторе цикла
	}
	// —ортировка всех полученных разиональных значений по возрастанию
	sort(VKL.begin(), VKL.end()) ;

	int N = VKL.size() ;
	for (int i=0; i<N; i++) {
		VKL[i].T*= 86400.0 ;
	}
}

//-------------------------------------------------------------------------------

