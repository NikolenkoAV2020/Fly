//--------------------------------------------------------------------------------
//
//
//--------------------------------------------------------------------------------
#include <stdafx.h>
#pragma   hdrstop

#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#include <FlyCoreSource\\ZMForceAtmSMAGost440181.h>

//--------------------------------------------------------------------------------
struct profPTMPoint {
 public:
	double H ;		// геопотенциальная высота в [м]
	double P ;		// давление в [Па] 
	double T ;		// молярная температура [К] Т0 = 273.15 К
	double b ;		// градиент молярной температуры  в [К/м]
	double M ;		// молярная масса [грамм/моль]
};

struct profTPoint {
 public:
	double H ;		// геопотенциальная высота в [м]
	double T ;		// молярная температура [К] Т0 = 273.15 К
	double b ;		// градиент молярной температуры  в [К/м]
};

struct molPoint {
 public:
	double H1 ;		// высота в [м]
	double H2 ;		// высота в [м]
	double d[4] ;	// коэфф-ты 
};

struct numPoint {
 public:
	double H1 ;		// высота в [м]
	double H2 ;		// высота в [м]
	double d[5] ;	// коэфф-ты 
	int    m ;
};

//--------------------------------------------------------------------------------
//тут от геопотенциальной высоты
// Профиль молярной температуры и молярной массы по геопотенциальной высоте 
// для высот до 120 км
const profPTMPoint prof0[ 12 ] = {
	// Градиенты пересчитаны для начала каждого интервала, 
	// а не для конца как они даны в ГОСТе. 
	// Это позволяет избежать путаницы в коде и ошибок рассчёта
	// Высота геопотенциальная
	// Температура молярная. До высоты 94 000 молярная и 
	// кинетическая температуры совпадают
	// H       P                T             beta    M возд 
	 -2000.0, 127774.0,        301.15,      -0.0065, 28.964420,
	     0.0, 101325.0,        288.15,      -0.0065, 28.964420,
	 11000.0,  22632.0,        216.65,       0.0,    28.964420,
	 20000.0,   5474.87,       216.65,       0.0010, 28.964420,
	 32000.0,    868.014,      228.65,       0.0028, 28.964420,
	 47000.0,    110.906,      270.65,       0.0,    28.964420,
	 51000.0,     66.9384,     270.65,      -0.0028, 28.964420,
	 71000.0,      3.95639,    214.65,      -0.001999993358382, 28.964420,
	 84852.046,    0.373380,   186.946,     -0.000033776799291, 28.964420,   
	 93601.158,    0.0752834,  186.650483,   0.003038292386349, 28.960,
	102325.895,    1.67431,    213.158785,   0.010836872832073, 27.668,
	117777.0,      0.00266618, 380.600445,   0.0,    25.450000
	//85000.,      0.0        186.65,  0.0,    28.964420,
	//94000.,      0.0        186.525, 0.0030, 28.964420,
	// Для молярной температуры
	//102450.,     0.0        212.00,  0.0110, 27.846000,
	//117777.,     0.0        380.60,  0.0,    25.450000
	// Для кинетической температуры
	// Tким = Тмол * M/M0
	//102450., 203.81,  0.0085213675, 27.846000,
	//117777., 334.417, 0.0, 25.450000		
} ;

//--------------------------------------------------------------------------------
//тут от геометрической высоты
const profTPoint prof1[ 10 ] = {
	// Профиль кинетической температуры по геометрической высоте
	// для высот более 120 км
	 120000.,   334.42,  0.011259,
	 140000.,   559.60,  0.006800,
	 160000.,   695.60,  0.003970,
	 200000.,   834.40,  0.001750,
	 250000.,   941.90,  0.000570,
	 325000.,   984.65,  0.0001500,
	 400000.,   995.90,  0.0000200,
	 600000.,   999.90,  0.0000005,
	 800000.,  1000.00,  0.0000000,
	1200000.,  1000.00,  0.0000000
} ;

//--------------------------------------------------------------------------------
void ZMAtmSMA440181::formerH(double Hh, bool fromGeometric, double& H, double& h) 
{
	double R = 6356767.0 ;
	h = fromGeometric ? Hh : (R*Hh/(R-Hh)) ; 
	H = fromGeometric ? (R*Hh/(R+Hh)) : Hh ;
}

//--------------------------------------------------------------------------------
/*
void ZMAtmSMA440181::buildProf()
{
	int    i ;
	double p_1 = 101325.000000 ;	// Давление на высоте 0 [Па]
	double Rm = 287.05287 ;			// Удельная газовая постоянная для воздуха [Дж/кг/К]
	double gc = 9.80665 ;			// Коэф-т перевода (ускорение свободного падения) [м/сек2]
	double Na = 6.02214129e23 ;		// Число авагадро кажется [1/моль]

	p[1] = p_1 ;
	p[0] = p[1]*pow(prof0[0].T/prof0[1].T,-gc/prof0[0].b/Rm) ;
	//профиль по направлению "вверх"
	for (i=1; i<11; i++){
		if (prof0[i].b!=0) {
			//градиент не 0
			p[i+1] = p[i]*pow(prof0[i].T/prof0[i+1].T, gc/Rm/prof0[i].b) ;
		} else {
			//градиент 0
			p[i+1] = p[i]*exp(-gc*(prof0[i+1].H-prof0[i].H)/prof0[i+1].T/Rm) ;
	}	}
	p1[0] = p[11] = 0.0026613 ;
	for (i=0; i<9; i++){
		double M1  = M(prof1[i].H) ;
		double M2  = M(prof1[i+1].H) ;
		double bm  = prof1[i].b ;
		double T1m = prof1[i].T*prof0[0].M/M1 ;
		double T2m = prof1[i+1].T*prof0[0].M/M1 ;
	    double R  = 8.3144598 ; 
		double Rmh = 1e3*R/M1 ;
		double H1, H2, h1, h2 ;
		formerH(prof1[i].H, true, H1, h1) ;
		formerH(prof1[i+1].H, true, H2, h2) ;
		bm = (T2m-T1m)/(H2-H1) ;
		double Pa = 0 ;
		if (bm!=0) {
			Pa = p1[i]*pow(T1m/T2m, gc/bm/Rmh) ;
		}
		if (prof1[i].b!=0) {
			//градиент не 0
			p1[i+1] = p1[i]*pow(prof1[i].T/prof1[i+1].T, gc/Rm/prof1[i].b) ;
			Pa = N(h2)*R*T(h2, false)/Na ;
			p1[i+1] = Pa ;
		} else {
			//градиент 0
			p1[i+1] = p1[i]*exp(-gc*(prof1[i+1].H-prof1[i].H)/prof1[i+1].T/Rm) ;
			//p1[i+1] = p1[i]*exp(-gc*(prof1[i+1].H-prof1[i].H)/T2m/Rmh) ;
	}	}
}
*/
//--------------------------------------------------------------------------------
double ZMAtmSMA440181::M(double h)
{
	if (h<=94000.0) return 28.964420 ;
	double M = 0 ;
	if (h>94000.0 && h<=97000.0) {
		M = 28.82+0.158*sqrt(1.0-7.5e-8*pow(h-94000.0, 2))-2.479e-4*sqrt(97000.0-h) ;
	}
	if (h>97000.0 && h<=97500.0) {
		M = 28.91-0.00012*(h-97000.0) ;
	}
	if (h>97500.0 && h<=120000.0) {
		M = 28.850-0.0001511*(h-97500.0) ;
	}
	if (h>120000.0 && h<=1200000.0) {
		static molPoint moly[6] = {
		120000.,  250000.,  46.9083, -29.71210e-5, 12.08693e-10, -1.85675e-15,
		250000.,  400000.,  40.4668, -15.52722e-5,  3.55735e-10, -3.02340e-16,
		400000.,  650000.,   6.3770,   6.25497e-5, -1.10144e-10,  3.36907e-17,
		650000.,  900000.,  75.6896, -17.61243e-5,  1.33603e-10, -2.87884e-17,
		900000., 1050000., 112.4838, -30.68086e-5,  2.90329e-10, -9.20616e-17,
		1050000.,1200000.,   9.8970,  -1.19732e-5,  7.78247e-10, -1.77541e-18
		} ;
		int k = 0 ;
		for (int i=0; i<6; i++) {
			if (h>moly[i].H1 && h<=moly[i].H2) { k = i ; break ; }
		}
		M = moly[k].d[0]+moly[k].d[1]*h+moly[k].d[2]*h*h+moly[k].d[3]*h*h*h ;
	}
	return M ;
}

//--------------------------------------------------------------------------------
double ZMAtmSMA440181::ro(double h)
{
	double ra = 0.0 ;
	// Число авагадро кажется [1/моль]
	double Na = 6.02214129e23 ;
	// Молярная масса в грамм/моль
	double Mv = M(h) ;
	if (h<120000) {
		// Универсальная газовая постоянная
		double R  = 8.3144598 ; 
		// Давление в Паскалях
		double Pa = P(h) ;
		// Температура термодинамическая в градусах Кельвина
		double Ta = T(h, false) ;
		// Плотность в граммах на метр кубический (потому что молярная масса
		// выражается в граммах на моль)
		// Данное соотношение является следствием уравнения состояния идеального гада
		// (уравнения Клайперона-Менделеева)
		//double ra1 = N(h)*Mv/Na ;
		ra = Pa*Mv/R/Ta ;
	} else {
		// ПО концентрации частиц вычисляется плотность правильно
		ra = N(h)*Mv/Na ;
	}
	// Возвращаем плотность атмосферы в кг на метр кубический 
	return ra/1e3 ;
}

//--------------------------------------------------------------------------------
double ZMAtmSMA440181::T(double h, bool needMolTemp)
{
	// h - высота геометрическая
	// H - высота геопотенциальная	    
	double H ; formerH(h, true, H, h) ; 
	double T ;		// Температура термодинамическая
	double Tm ;		// Температура молярная
 	if (H<117777.0){
		// Если геометрическая высота не больше чем 120 км
		// prof0, геопотенциальная высота и температура в кельвинах
		int k = 0 ;
		for (int i=0; i<11; i++) {
			if (H>=prof0[i].H && H<=prof0[i+1].H) { k = i ; break ; }
		}
		// Температура молярная вычисленная по геопотенциальной высоте
		Tm = prof0[k].T+prof0[k].b*(H-prof0[k].H) ;
		// Температура термодинамическая
		T  = Tm*M(h)/prof0[0].M ;
	} else {
		// prof1, геометрическая высота и температура в кельвинах
		int k = 0 ;
		for (int i=0; i<9; i++) {
			if (h>=prof1[i].H && h<=prof1[i+1].H) {	k = i ;	break ;	}
		}
		// Температура термодинамическая вычисленная по геометрической высоте
		T = prof1[k].T+prof1[k].b*(h-prof1[k].H) ;
		// Температура молярная
		Tm= T*prof0[0].M/M(h) ;
	}
	// Возвращаем молярную или термодинамическую температуру
	// в зависимости от того что требуется
	return (needMolTemp?Tm:T) ;
}

//--------------------------------------------------------------------------------
double ZMAtmSMA440181::P(double h)
{
	// h - высота геометрическая
	// H - высота геопотенциальная	    
	double H ; formerH(h, true, H, h) ; 
	double Rm = 287.05287 ;					// Газов. постоянная удельная
	double R  = 8.3144598 ;					// Газов. постоянная универсальная
	double gc = 9.80665 ;					// Коэф-т перевода
	double Na = 6.02214129e23 ;				// Число авагадро кажется [1/моль]
	double Pa = 0 ;
	int    k = 0 ;
	if (h<=120000.0) {
		for (int i=0; i<11; i++) {
			if (H>=prof0[i].H && H<=prof0[i+1].H) {	k = i ;	break ;	}
		}
		if (prof0[k].b!=0.0) 
			 Pa = prof0[k].P*pow(prof0[k].T/T(h, true), gc/prof0[k].b/Rm) ;	
		else Pa = prof0[k].P*exp(-gc*(H-prof0[k].H)/prof0[k].T/Rm) ;
	} else {
		// ПО концентрации частиц вычисляется плотность правильно
		Pa = N(h)*R*T(h, false)/Na ;
/*
		for (int i=0; i<9; i++) {
			if (h>=prof1[i].H && h<=prof1[i+1].H) {	k = i ;	break ;	}
		}
		if (prof1[k].b!=0.0) {
			//double Tzm = prof1[k].T*prof0[0].M/M(h) ;
			//double Tm = T(h, true) ;
			//double dT = Tm/Tzm ;
			// Pa = p1[k]*pow(dT, -gc/prof1[k].b/Rm) ;	
			// Pa = p1[k]*pow(dT, -gc/prof1[k].b/R) ;
			 double Mh  = M(h) ;
			 double bm  = prof1[k].b ;
			 double T1m = prof1[k].T*prof0[0].M/Mh ;
			 double T2m = prof1[k+1].T*prof0[0].M/Mh ;
			 double Rmh = 1e3*R/Mh ;
			 bm = (T2m-T1m)/(prof1[k+1].H-prof1[k].H) ;
			 Pa = p1[k]*pow(T1m/T(h, true), gc/bm/Rmh) ;	
		}
		else Pa = p1[k]*exp(-gc*(h-prof1[k].H)/prof1[k].T/Rm) ;
*/		
	}
	return Pa ;
}

//--------------------------------------------------------------------------------
double ZMAtmSMA440181::N(double h)
{
	double NH = 0 ;
	if (h<=120000) {
		NH = 7.243611e22*P(h)/T(h, false) ;
		return NH ;
	}
	const numPoint num[ 9 ] = {
    120000.,  150000.,  0.210005867e4,-0.5618444757e-1, 0.5663986231e-6, -0.2547466858e-11, 0.4309844119e-17, 17,
	150000.,  200000.,  0.10163937e4, -0.2119530830e-1, 0.1671627815e-6, -0.5894237068e-12, 0.7826684089e-18, 16,
	200000.,  250000.,  0.7631575e3,  -0.1150600844e-1, 0.6612598428e-7,  0.1708736137e-12, 0.1669823114e-18, 15,
	250000.,  350000.,  0.1882203e3,  -0.2265999519e-2, 0.1041726141e-7, -0.2155574922e-13, 0.1687430962e-19, 15,
	350000.,  450000.,  0.2804823e3,  -0.2432231125e-2, 0.8055024663e-8, -0.1202418519e-13, 0.6805101379e-20, 14,
	450000.,  600000.,  0.5599362e3,  -0.3714141392e-2, 0.9358870345e-8, -0.1058591881e-13, 0.4525531532e-20, 13,
	600000.,  800000.,  0.8358756e3,  -0.4265393073e-2, 0.8252842085e-8, -0.7150127437e-14, 0.2335744331e-20, 12,
	800000.,  1000000., 0.8364965e2, -0.3162492458e-3, 0.4602064246e-9, -0.3021858469e-15, 0.7512304301e-22, 12,
	1000000., 1200000., 0.383220e2,   -0.50980e-4,      0.18100e-10,      0.,               0.,               11 } ;
	int i, k = 0 ;
	for (i=0; i<9; i++) {
		if (h>=num[i].H1 && h<=num[i].H2) { k = i ;	break ;	}
	}
	if (i<9) {
		NH =(num[k].d[0]+num[k].d[1]*h+num[k].d[2]*h*h+num[k].d[3]*h*h*h 
			+num[k].d[4]*pow(h, 4.0))*pow(10.0, num[k].m) ;
	}
	return NH ;
}

//--------------------------------------------------------------------------------
double ZMAtmSMA440181::a(double h)
{
	return (20.046796*sqrt(T(h, false))) ;
}

//--------------------------------------------------------------------------------
int ZMAtmSMA440181::Calc(double* xg, double& ro)
{
	double a[3] ;
	int rc = CalcPROT(xg, a) ; 
	ro = a[1] ;
	return rc ;
}

//--------------------------------------------------------------------------------
int ZMAtmSMA440181::CalcPROT(double* X, double *a)
{
	double Re   = 6378136.0 ;
	double alfa = 1.0/298.257839303 ;
	double R    = sqrt(X[0]*X[0]+X[1]*X[1]+X[2]*X[2]) ;
	// Высота в м
	double h = 1e7*R-Re*(1.0-alfa*X[2]*X[2]/R/R) ;
	a[0] = P(h) ;
	a[1] = ro(h) ;
	a[2] = T(h, false) ;
	return 0 ;
}

//--------------------------------------------------------------------------------
