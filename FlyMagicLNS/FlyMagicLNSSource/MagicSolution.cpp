//-----------------------------------------------------------------------------
// MagicSolutio.cpp : 
// А. Николенко 12.10.2018
//-----------------------------------------------------------------------------
#include "stdafx.h"
//-----------------------------------------------------------------------------
// Компоненты Fly
#include <FlyMMath.h>		// Математические функции
#include <FlyCore.h>		// Математические функции
#include <FlyMagicLNS.h>	//
#include <FlyCoreSource\ZMessageManager.h>
#include "MagicSolution.h"

//-----------------------------------------------------------------------------
// Расчёт параметров коррекции
//
// Реализация итерационного процесса решения задачи расчёта параметров L-Манёвра
// методом узловых точек. Вычислительная процедура пригодна для любого варианта 
// решения задачи от 11-го до 33-го.
// Задание на выполнение расчёта параметризуется посредством структуры
// ZSMagicLnsSolution* MS.
// Задача решаеься в модели движения  ZMSC& KA, для начальных условий ZNU& NU.
// Результаты решения предствлены расчётными элементами движения в различных 
// точках траектории ZSLoopFact* P1r, P2r, PNr, PRr.
// Искомое управление после завершения итерационного процесса содержится 
// в структуре ZSFlightRule* Ur.
//-----------------------------------------------------------------------------
int MagicSolution(
	ZSMagicLnsSolution* MS,			// Модель решения задачи
	ZCPrintManager    * PrintMng,	// Диспетчер документирования
	FILE  *pf,			// Тесктовый документ для результатов решения задачи
	ZLSF  &LSF,			// Логическая шкала сил для решения задачи маневра 
	ZMSC  &KA,			// Модель движения КА
	ZNU   &NU,			// Начальные условия движения
	ZCExternalEquationsDefinition *EED,
	ZSLoopFact   *P1r,	// Пар-ы движ. на витке 1-го импульса
	ZSLoopFact   *P2r,	// Пар-ы движ. на витке 2-го импульса
	ZSLoopFact   *PNr,	// Пар-ы движ. на заданном витке в пассивном полёте
	ZSLoopFact   *PRr,	// Расчётные параметры движения на заданном витке 
	ZSFlightRule *Ur)	// Расчитанные параметры программы управления
{
	int  rc = 0 ;
	char Msg[512] ;
    MS->GlobCount = 0 ;

	MsgManager.Clear() ;

	//-------------------------------------------------------------------------
	// Инициализация модели движения
	rc = KA.Init(NU, &LSF, EED); RRC;

	// Плная начальная масса КА 
	// Данные о полной массе массе КА берутся из НУ, если же в НУ данной 
	// информации нет, то сухая масса КА и масса топлива берутся из данных
	// по КА.
	MS->MZ.M() = KA.WeightFullNU();	
	// Решение задачи с нулевой массой не возможно 
	assert(MS->MZ.M() > 0);

	//-------------------------------------------------------------------------
	// Формирование ключей (основного и дополнительного) 
	// требуемых на правом конце траектории параметров. В зависимости 
	// от выбранного варианта решаемой задачи составляется два битовых ключа:
	//		первичный DemandsKey - определяет параметры по которым невязки 
	//							   на правом  конце траетории необходимо 
	//							   свести к нулю (точное решение);
	//		и вторичный SecondDemandsKey - определяет параметры для которых
	//							   необходимо обеспечить максимально возможное
	//							   приближение.
	MS->MZ.GetParKorFromVar(MS->MZ.DemandsKey);
	MS->MZ.GetAdvParKorFromVar(MS->MZ.SecondDemandsKey);

	//-------------------------------------------------------------------------
	// Краткое описание в документе решаемой ззадачи манёвра
	char TaskName[256], S[512];
	MS->MZ.GetVarText(TaskName);

	// Заголовок текстового документа
	fprintf(pf, "\n____________________________________________________________\n\0");
	fprintf(pf, "\n  РАСЧЁТ ПАРАМЕТРОВ КОРРЕКЦИИ ОРБИТЫ КА №%d\n\0", MS->MZ.KA());
	PrintMng->PrintHeaderDoc("\n   РАСЧЁТ ПАРАМЕТРОВ КОРРЕКЦИИ ОРБИТЫ КА");

	sprintf(S, "  Вариант   %s\n\n\0", TaskName);
	fprintf(pf, "%s", S);
	PrintMng->PrintText(S);
	
	sprintf(S, "  1. ИСХОДНЫЕ ДАННЫЕ\n\0");
	fprintf(pf, "%s", S);
	PrintMng->PrintText(S);
	//ZCHtmlBuilder* HB = PrintMng->HtmlFile();

	//-------------------------------------------------------------------------
	// Документирование НУ
	PrintMng->PrintNU(NU, NULL, 3, pf);
	// Документирование ЛШС
	PrintMng->PrintLSF(LSF, 1, pf);

	//-------------------------------------------------------------------------
	// Характеристики движения КА в пассивном полёте,
	// в том числе, на начало витка первого импульса на заданный виток
	int vI[3] ;
    vI[0] = MS->MZ.VITIMP(0) ;	// Виток первого импульса
	vI[1] = MS->MZ.VITIMP(1);	// Виток второго импульса
	vI[2] = MS->MZ.VITIMP(2);	// Виток второго импульса
	int vz = MS->MZ.VIT();	// Заданный виток
	int vnu = NU.vit ;		// Виток НУ
	int ErrImp = 0 ;		// Номер импульса при реализации которого произошла ошибка
							// если 0, то все импульсы оработаны верно
	double m0 = KA.WeightFullNU() ;
	double dm = 0 ; 
	double dms= 0 ; 

    // Условный номер задачи
	int indexTask = MS->MZ.TASK();
    if (indexTask==0) { 
		return 0 ;
		// Моделирование тестовой коррекции
		//return ( MknSolutionTest( ) ) ;
	}

	ZNU         RIKNU[3] ;	// НУ с расчётным импульсом коррекции после 1-го, 2-го и 3-го импульса
	ZSC_VI		VI[5] ;		// Параметры движения на заданном витке в пассивном полёте и с учётом расчитанной программы управления,
	ZSC_SI		SI[5] ;		// а также после 1-го, 2-го и 3-го импульса.  
	ZSLoopFact  PN,			// Параметры орбиты. Начальные (исходные) на заданный виток
				PR,			// Параметры орбиты. Расчётные на заданный виток
				P1, P2, PZ ;
	ZCLnsNpmClaim      
				PT,
				PTN,		// Требуемые параметры начальные
				PTT;		// Требуемые параметры текущие (с учётом промаха)
	ZSFlightRule U;			// Параметры искомой программы управления 		

	memset(&U, 0, sizeof(ZSFlightRule)) ; 
	for (int i=0 ; i<3; i++) {
		U.vit[i] = vI[i] ;
		U.sk[i]  = 8 ;
	}

	// Подшагивание на виток первого импульса
	rc = KA.GoToVit(vI[0] - 1); RRC;
	// Сохранение состояния модели движения 
	int HSTORYV1 = KA.Story(); if (!HSTORYV1) return 1;

    // Моделирование витка первого импульса
	rc = KA.GoAlongVit(vI[0]); RRC;
	P1 << KA.FV ; 
	
    // Моделирование витка второго импульса - если это необхордимо
	if ((MS->MZ.TASK() >= 20 && MS->MZ.TASK()<30) || (MS->MZ.TASK() >= 200 && MS->MZ.TASK()<300)) {
		rc = KA.GoAlongVit(vI[1], _SK_ASKTE) ; RRC ;
		P2 << KA.FV ; 
    } else P2 = P1 ; 
	
    // Выход на начало заданного витка - начальные параметры движния на заданный виток
	// Моделирование данного витка
	rc = ModelForcingGivenTurn(MS->MZ, KA, vz, SI[0], VI[0], PN); RRC;
	PZ = PN ;

	//-------------------------------------------------------------------------
    // Формирование структуры начальных заданных параметров
	// PTN - параметры требуемые начальные
	DemandInit(MS->MZ, PN, PTN);
    // Перед началом итераций текущие требуемые параметры равны требуемым начальным
    PTT = PTN ;
    // Перед началом итераций расчётные параметры на заданный виток равны исходным
    PR = PN ;

	// Отображение на консоли задания на решение задачи расчёта 
	// параметров управления движением КА
	MagicPrint(MS, PrintMng, nullptr, P1, P2, PN, PR, U, -1);

    //-------------------------------------------------------------------------
    // Цикл численного решения задачи
	MS->GlobCount = 1;
    while(1) {
		int i ; 
		// Восстанавливаем состояние МД на момент начала витка первого импульса
		rc = KA.ReStory(HSTORYV1) ; RRC ;

		//---------------------------------------------------------------------
		// Расчет параметров программы управления
		// Аналитический расчёт параметров программы управления.
		// Методика расчёта - метод узловых точек.
		// Результаты расчёта записываются в структуру ZSFlightRule U. 
		// Исходные данные для решения задачи
		//		P1 - параметры движения на витке первого импульса
		//		PZ - параметры движения на заданный виток в пассивном полёте
		//		PTT- требуемые (текущие, т.е. с учётом поправок краевой задачи) 
		//		     параметры движения на заданный виток
		rc = LNSMagicBox(MS, P1, P2, PZ, PTT, U) ; if (rc) goto end ;

		// На первой итерации проектируется ОМИВ или ДУ орбита 
		// и формируется её геометрия, после этого геометрию данной орбиты необходимо
		// сохранить в структуре параметров требуемых начальных
		if ((PTN.VarOrb==SPO_ORB_OMIV || PTN.VarOrb==SPO_ORB_DU) && MS->GlobCount==1) {
			MS->MZ.PARe() = PTT.e;
			MS->MZ.PARw() = PTT.w;
			PTN.e = PTT.e ;	PTN.w = PTT.w ;
			PTN.e1= PTT.e1;	PTN.e2= PTT.e2;
		}
		if (PTN.VarOrb == SPO_ORB_HBH && MS->GlobCount == 1) {
			PTN.uH = PTT.uH ;	
		}

		// Заканчиваем формирование структуры, 
		// содержащей параметры программы управления движением 
		// Ориентация импульса по его знаку (разгон или торможение)
		for (i=0 ; i<U.n ; i++) {
			U.alf[i] = 0 ;
			U.bet[i] = U.dV[i]>0 ? 0.0:180 ;
		}

		// Моделирование движения КА с учётом программы управления его движением
		rc = ControlImplementation(KA, NU, MS->DU, U, SI, VI, RIKNU); if (rc) goto end;

		//---------------------------------------------------------------------
		// Моделирование движения КА на заданном витке	
		ModelForcingGivenTurn(MS->MZ, KA, vz, SI[1], VI[1], PR) ;

		// Отображение текущих результатов на консоли
		MagicPrint(MS, PrintMng, NULL, P1, P2, PN, PR, U, MS->GlobCount);

		//---------------------------------------------------------------------
		// Проверка выполнения краевых условий 
		if (MagicIsNeedBreak(MS, PTN, PR)) {
			break ;
		}

		//---------------------------------------------------------------------      
		// Формирование структуры заданных параметров с учётом текущего промаха 
		// - формирование ложной цели для обеспечения сходимости задачи
		DemandIncrement(MS->MZ, MS->MP, PTN, PR, PTT);

		// Увеличение счётчика итераций
		MS->GlobCount++;
		// Проверка превышения максимально допустимого числа итераций
		//if ( GlobCount > 3 ) { rc =-11 ; break ; }
		if (MS->GlobCount >= MS->MP.maxIter) { rc = -11; break; }
	}

	//-------------------------------------------------------------------------
	// Завершение решения задачи
end : ;

	// Освобождение памяти использованной для архивирования 
	// состояния модели движения
	KA.FreeStory(NULL) ; 

	//-------------------------------------------------------------------------
	// Сообщение об ошибке если завершено не корректно
	if ( rc ) {
		switch ( rc ) {
			case 50:
			case-1 : sprintf( Msg, "Решение задачи прервано оператором" ) ; break ;
			case-2 : if ( ErrImp > 0 ) sprintf( Msg, "Выгорание топлива на  %d  включении", ErrImp ) ;
					 else sprintf( Msg, "Выгорание топлива" ) ;
					 break ;
			case-3 : if ( ErrImp > 0 ) sprintf( Msg, "Величина  %d  импульса меньше минимально возможного значения", ErrImp ) ;
					 else sprintf( Msg, "Величина импульса меньше минимально возможного значения" ) ;
					 break ;
	        case-4 : if ( ErrImp > 0 ) sprintf( Msg, "Величина  %d  импульса больше максимально допустимой величины", ErrImp ) ;
					 else sprintf( Msg, "Величина импульса больше максимально допустимой величины" ) ;
					 break ;
	        case-9 : sprintf( Msg, "Некорректные характеристики ДУ" ) ; break ;
		    case-10: sprintf( Msg, "Требуемая орбита не существует" ) ; break ;
			case-11: sprintf( Msg, "Решение завершено по числу итераций" ) ; break ;
	        case-12: sprintf( Msg, "Решение заданного варианта недопустимо" ) ; break ;
		    case-13: sprintf( Msg, "Ошибка считывания характеристик ДУ" ) ; break ;
			case-14: sprintf( Msg, "Коррекция орбиты не требуется" ) ; break ;
	        case-20:
		    case-21:
			case-22: sprintf( Msg, "Ошибка проектирования орбиты" ) ; break ;
	        case-30: sprintf( Msg, "Используемая ЛШС не учитывает работу ДУ" ) ; break ;
		    case-999:sprintf( Msg, "Решение задачи завершено аварийно\n" ) ; break ;
			default: sprintf( Msg, "Решение задачи завершено аварийно\n" ) ; break ;
		}
		MsgManager << Msg ;
	} else {
		//for (int i=0 ; i<ii ; i++) {
		//	if ( TPU.isOnlyMain[ i ] ) {
		//		sprintf( Msg, "Величина  %d  импульса меньше минимально возможного значения", ErrImp ) ;
		//		MMessageBox( Msg, 2 ) ;
		//	} 
		//} 
	}

	//-------------------------------------------------------------------------
	// Документирование 
	pf << MsgManager ;
	if (!rc) {
		// Документирование результатов расчёта
		MagicSolutionPrint(MS, PrintMng, pf, KA, 
						   P1, P2, PN, PR, SI, VI, U, RIKNU) ;
		// Завершение документирования
		PrintMng->PostPrint(&pf, MS->GlobCount);
	}
	if (!rc) {
		if (P1r) *P1r= P1 ;
		if (P2r) *P2r= P2 ;
		if (PNr) *PNr= PN ;
		if (PRr) *PRr= PR ;
		if (Ur ) *Ur = U ;
	}

	return rc ;
}

//-------------------------------------------------------------------------------