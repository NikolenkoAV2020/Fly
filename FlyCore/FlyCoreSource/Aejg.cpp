//---------------------------------------------------------------------------
// Управляющий модуль Астрономического Ежегодника
//---------------------------------------------------------------------------
#include <stdafx.h>
#pragma   hdrstop
#include <FlyMMath.h>	// Математические функции
#include <FlyTime.h>	// Всё про время

#include <FlyCoreSource\\ModType.h>
#include <FlyCoreSource\\ModGlobal.h>
#include <FlyCoreSource\\ModAstro.h>
#include <FlyCoreSource\\Z.h>

//---------------------------------------------------------------------------
#define NEED_ANAL_AE
//#define AE_2003      // ТЕОРИЯ 2003 ГОДА, ИНАЧЕ - 1996 ГОДА 
// -----------------------------------------------------------------------
#ifdef AE_2003
   // Звёздное время - 2003 года, иначе - 1996 года
    #define STARTIME_2003
   // Нутация        - 2003 года, иначе - 1996 года
    #define NUTATION_2003
   // Прецессия      - 2003 года, иначе - 2000 года
    #define PRECESSION_2003
   // Наклон к эклиптике - 2009 года, иначе - 1996 года
    #define E0_2003
   // Околосуточные вариации ПВЗ - 2009 года, иначе - 1996 года
    #define VAR_PVZ_OCEAN_2003
#else
   // Околосуточные вариации ПВЗ - 2009 года, иначе - 1996 года
   // #define VAR_PVZ_OCEAN_2003
#endif AE_2003
//---------------------------------------------------------------------------
// Компоненты Fly
#include <FlyMMath.h>	// Математические функции
#include <FlyTime.h>	// Всё про время

//---------------------------------------------------------------------------
#include "ModType.h"
#include "ModAstro.h"
//---------------------------------------------------------------------------
#define SIZE_OPER_MAS_TABL_AE 30
double  Tae ;

//---------------------------------------------------------------------------
// Глобальный указатель на объект работы с астроданными
static CModAstro *pAstroData = nullptr ;
//---------------------------------------------------------------------------
#ifdef _CML_ASTRODATA_SS
CML_AstroData *pAstroDataSS;
#endif _CML_ASTRODATA_SS
//---------------------------------------------------------------------------
// Флаг инициализации работы с астроданными
static bool  fAstroData = 0 ;
//---------------------------------------------------------------------------
// Расчёт вектор из 9-ти аргументов планет в радианах
void Arg_Planet(double t, double *u);
//---------------------------------------------------------------------------
// Функция создания глобального объекта расчета астрономических данных
//---------------------------------------------------------------------------
HRESULT Init_AEJG( double dTA_Begin )
{
	if( !pAstroData ) pAstroData = new CModAstro(BTS_EARTH);
#ifdef _CML_ASTRODATA_SS
	//if(! pAstroDataSS ) pAstroDataSS = new CModAstro(BTS_SS);
#endif _CML_ASTRODATA_SS 
	fAstroData = true ;
	return 0 ;
}
//---------------------------------------------------------------------------
// Функция удаления глобального объекта расчета астрономических данных
//---------------------------------------------------------------------------
void End_AEJG()
{
	if ( pAstroData  ) { delete pAstroData ; pAstroData = nullptr ; }
#ifdef _CML_ASTRODATA_SS
	if( pAstroDataSS ) { delete pAstroDataSS ; pAstroDataSS = nullptr ; }
#endif _CML_ASTRODATA_SS
}

//---------------------------------------------------------------------------
// Расчет астрономических данных
//---------------------------------------------------------------------------
short AEJG(double t,short N, short mode)
{
	short ko=0;
	static short Flag_TAE, Flag_NotPVZ;
    //-------------------------------------------------------------------------
    // Инициализация астрономических данных
    //-------------------------------------------------------------------------
    if( !fAstroData ) Init_AEJG( t ) ; 
    Tae = t ;
    if(fabs(Tae-Wae->t[N]) < Wae->dop[ N ]) return 0 ;
    //-------------------------------------------------------------------------
    // Расчет астрономических данных
    //-------------------------------------------------------------------------
    if(mode==BTS_EARTH)
    {
      if(pAstroData)
      {
        double *pDblPar ;
        AstroObject  Obj;

        switch(N)
        {
          default:
          //---------------------------------------------------------------------
          case 0: // Солнце
          pDblPar = Wae->qso;
          Obj = Sun;
          break;
          //---------------------------------------------------------------------
          case 1: // Луна
          pDblPar = Wae->qlu;
          Obj = Moon;
          break;
          //---------------------------------------------------------------------
          case 8: // Меркурий
          pDblPar = Wae->qme;
          Obj = Mercury;
          break;
          //---------------------------------------------------------------------
          case 5: // Венера
          pDblPar = Wae->qwe;
          Obj = Venus;
          break;
          //---------------------------------------------------------------------
          case 6: // Марс
          pDblPar = Wae->qma;
          Obj = Mars;
          break;
          //---------------------------------------------------------------------
          case 2: // Юпитер
          pDblPar = Wae->qup;
          Obj = Jove;
          break;
          //---------------------------------------------------------------------
          case 3: // Сатурн
          pDblPar = Wae->qsa;
          Obj = Saturn;
          break;
          //---------------------------------------------------------------------
          case 4: // Уран
          pDblPar = Wae->qur;
          Obj = Uranus;
          break;
          //---------------------------------------------------------------------
          case 7: // Нептун
          pDblPar = Wae->qne;
          Obj = Neptune;
          break;
          //---------------------------------------------------------------------
          case 9: // Плутон
          pDblPar = Wae->qpl;
          Obj = Pluto;
          break;
          //---------------------------------------------------------------------
          case 12: // Нутация
#ifdef NUTATION_2003
          return pAstroData->Calc_AstroData_nutation(Tae, Wae->qnu);
#else
          pDblPar = Wae->qnu;
          Obj = Nutation;
          break;
#endif
          //---------------------------------------------------------------------
          case 10: // Прецессия
          return ( ( short )pAstroData->Calc_AstroData_precess(Tae, Wae->qpr)) ;
          //---------------------------------------------------------------------
          case 11: // ПВЗ
          //if(!Flag_NotPVZ) ko=TABL_AE(t,N);
          if(ko==15)
          {
            Flag_NotPVZ=true;
            ko=0;
          }

          return ko;

          //---------------------------------------------------------------------
        }

        //Расчет астрономических данных по новому
        ko = ( short )pAstroData->Calc_AstroData(Tae, Obj, 0, pDblPar);
        if(ko)
          Flag_NotPVZ = ko;

        return ko;
      }
      else
      {
        if(N==10) { 
			// Прецессия от эпохи 2000 года (на момент 12 часов 01.01.2000 параметры прецесси равны нулю)
			ZPrecessJ2000( Tae, Wae->qpr, TIME1975ASD ) ;
			for (int i = 3; --i >= 0; Wae->qpr[i] /= M_SEKRAD);
			Wae->t[10]=Tae ;
			Wae->metod[ 10 ]=1 ;			
			//PRECES(Tae); 
			return 0; 
		}

        //if(!Flag_TAE) Flag_TAE=TABL_AE(t,N);
        if(!Flag_TAE) return 0;
        ko=Flag_TAE;

#ifdef NEED_ANAL_AE
        if( N<10 && (fabs(Tae-Wae->t[10])>Wae->dop[10])) {
			// Прецессия от эпохи 2000 года (на момент 12 часов 01.01.2000 параметры прецесси равны нулю)
			ZPrecessJ2000( Tae, Wae->qpr, TIME1975ASD ) ;
			for (int i = 3; --i >= 0; Wae->qpr[i] /= M_SEKRAD);
			Wae->t[10]=Tae ;
			Wae->metod[ 10 ]=1 ;			
			//PRECES(Tae);
		}
        if((N>=2 && N<10) && (fabs(Tae-Wae->t[0])>Wae->dop[0]))
        {
          if((ko=ANAL_AE(Tae,0))!=0) return ko;
        }

        ko=ANAL_AE(Tae,N);
#endif
       }
    }

#ifdef _CML_ASTRODATA_SS
    if(mode==BTS_SS)
    {
      if(pAstroDataSS)
      {
        double *pDblPar, Temp_Dbl[3];
        AstroObject  Obj;

        switch(N)
        {
          default:
          //---------------------------------------------------------------------
          case 0: // Солнце
          pDblPar = Wae->qso;
          Obj = Sun;
          break;
          //---------------------------------------------------------------------
          case 1: // Луна
          pDblPar = Wae->qlu;
          Obj = Moon;
          break;
          //---------------------------------------------------------------------
          case 8: // Меркурий
          pDblPar = Wae->qme;
          Obj = Mercury;
          break;
          //---------------------------------------------------------------------
          case 5: // Венера
          pDblPar = Wae->qwe;
          Obj = Venus;
          break;
          //---------------------------------------------------------------------
          case 6: // Марс
          pDblPar = Wae->qma;
          Obj = Mars;
          break;
          //---------------------------------------------------------------------
          case 2: // Юпитер
          pDblPar = Wae->qup;
          Obj = Jove;
          break;
          //---------------------------------------------------------------------
          case 3: // Сатурн
          pDblPar = Wae->qsa;
          Obj = Saturn;
          break;
          //---------------------------------------------------------------------
          case 4: // Уран
          pDblPar = Wae->qur;
          Obj = Uranus;
          break;
          //---------------------------------------------------------------------
          case 7: // Нептун
          pDblPar = Wae->qne;
          Obj = Neptune;
          break;
          //---------------------------------------------------------------------
          case 9: // Плутон
          pDblPar = Wae->qpl;
          Obj = Pluto;
          break;
          //---------------------------------------------------------------------
          case 12:// Нутация
#ifdef NUTATION_2003
          return pAstroData->Calc_AstroData_nutation(Tae, Wae->qnu);
#else
          pDblPar = Wae->qnu;
          Obj = Nutation;
          break;
#endif
          //---------------------------------------------------------------------
          case 10:// Прецессия
          return pAstroDataSS->Calc_AstroData_precess(Tae, Wae->qpr);
          //---------------------------------------------------------------------
          case 11:// ПВЗ
          if(!Flag_NotPVZ)
            ko=TABL_AE(t,N);
          if(ko==15)
          {
            Flag_NotPVZ=true; ko=0;
          }

          return ko;

          //---------------------------------------------------------------------
          case 13: // Земля (для БЦ СС)
          pDblPar = Wae->qze;
          Obj = Earth;
          break;
        }

        //Расчет астрономических данных по новому
        pAstroDataSS->AstroRazmSet(0,0,0,0);  //Эпока J2000 принудительно для режима BTS_SS

        ko=pAstroDataSS->Calc_AstroData(Tae, Obj, 0, pDblPar);

        if(ko)
          Flag_NotPVZ = ko;

//        double dResult[6];
//        memset(dResult, 0, sizeof(dResult));
//        ko=pAstroDataSS->Calc_Precesion(Tae, Obj, dResult);

        return ko;
      }
      else
      {
        if(N==10) { PRECES(Tae); return 0; }

        if(!Flag_TAE)
          Flag_TAE=TABL_AE(t,N);
        if(!Flag_TAE) return 0;
        ko=Flag_TAE;

#ifdef NEED_ANAL_AE
        if(N<10 && (fabs(Tae-Wae->t[10])>Wae->dop[10])) PRECES(Tae);
        if((N>=2 && N<10) && (fabs(Tae-Wae->t[0])>Wae->dop[0]))
        {
          if((ko=ANAL_AE(Tae,0))!=0) return ko;
        }
        ko=ANAL_AE(Tae,N);
#endif
      }
    }
#endif _CML_ASTRODATA_SS

    return ko;
}

//----------------------------------------------------------------------------
// Функция расчета интервала времени между B1975 и J2000
//----------------------------------------------------------------------------
double Calc_Delta_J2000_B1975()
{
	double jd2000[ 2 ] = { 2451545., 0.0 } ;
	double jd1975[ 2 ] = { 2442413., 0.5 }, bd1975[ 2 ] ;
	double Delta_T ;
	// Вычисление начала Бесселева 1975 года в юлианских днях
	JD_Bessel( jd1975, bd1975 ) ;
	// Вычисление разницы между B1975 и J2000 в юлианских днях
	Delta_T = ( bd1975[ 0 ] - jd2000[ 0 ] ) + ( bd1975[ 1 ] - jd2000[ 1 ] ) ;
	// Вычисление разницы между B1975 и J2000 в юлианских столетиях
	Delta_T /= 36525. ;
	return Delta_T ;
}
//----------------------------------------------------------------------------
// Функция расчета прецессии за время от 0 час 01.01.1975 до заданного времени
//----------------------------------------------------------------------------
/*
void Calc_Prec_Par_B1975(double Tae, double *Preces)
{
	double Cs;
	Cs = tau2000( t_TDT( *W_DELTA_2000 + Tae ) ) - J_ask0 ;
	//  preces(J_ask0,Cs,Preces);
	preces_IERS( J_ask0, Cs, Preces ) ;
}
*/
//----------------------------------------------------------------------------
// Функция расчета прецессии за время от 0 час 01.01.1975 до заданного времени
//----------------------------------------------------------------------------
/*
void Calc_Prec_Par(double dIAT_E1, double dIAT_E2, double *Preces)
{
	double Tep, Tau, Tmp_Preces[ 3 ] ;
	short i;
	//Расчет прецессии за время от Е1 до Е2
	//Время эпохи E1 относительно J2000 в Юлиан.Столетиях
	double TDT = t_TDT(*W_DELTA_2000+dIAT_E1) ;
	// Время в юлианских столетиях от 0h 01.01.2000 до 12h 01.01.2000 - 32 сек (зачем?)
	Tep = tau2000(TDT);
	// Время эпохи E2 относительно эпохи E1 в Юлиан.Столетиях
	Tau = (dIAT_E2-dIAT_E1)/36525.;
	preces_IERS(J_ask0,-J_ask0, Tmp_Preces);
	preces_IERS(Tep,Tau,Preces);
	// Перевод прецессии в радианы
	for(i=0; i<3; i++) Preces[i] /= k_sekrad;
}
*/
//----------------------------------------------------------------------------
// Функция расчета прецессии
//----------------------------------------------------------------------------
/*
void PRECES(double Tae)
{
	double Cs;
	short i;
	Cs = tau2000( t_TDT( *W_DELTA_2000 + Tae ) ) - J_ask0 ;
	preces_IERS( J_ask0, Cs, Wae->qpr ) ;
	for( i = 3 ; --i >= 0 ; Wae->qpr[ i ] /= k_sekrad ) ;
	Wae->t[ 10 ] = Tae ;
	Wae->metod[ 10 ] = 1 ;
}
*/
/*
#ifndef PRECESSION_2003
//----------------------------------------------------------------------------
// Расчет параметров прецессии от Тau до Тau+tau (в угловых секундах)
//----------------------------------------------------------------------------
static double Mas_Kft_Prec[15] = {
	+2306.2181, //  0 - Линейные члены Кси_А, Зет_А
	+1.39656,   //  1 -
	-0.139e-3,  //  2 -
	+0.30188,   //  3 - Квадрат. члены Кси_А
	-0.344e-3,  //  4 -
	+0.017998,  //  5 - Кубичес. член  Кси_А
	+1.09468,   //  6 - Квадрат. члены Зет_А
	+0.66e-4,   //  7 -
	+0.018203,  //  8 - Кубичес. член  Зет_А
	+2004.3109, //  9 - Линейные члены Тет_А
	-0.8533,    // 10 -
	-0.217e-3,  // 11 -
	-0.42665,   // 12 - Квадрат. члены Тет_А
	-0.217e-3,  // 13 -
	-0.041833   // 14 - Кубичес. член  Тет_А
};
//----------------------------------------------------------------------------
// Расчет параметров прецессии от Тau до Тau+tau (в угловых секундах)
//----------------------------------------------------------------------------
void preces(double Tau, double tau, double *Precess)
{
	double dTemp;
	// Расчет параметров прецессии
	dTemp = Mas_Kft_Prec[ 0]+(Mas_Kft_Prec[ 1]+Mas_Kft_Prec[ 2]*Tau)*Tau;
	Precess[0] = (tau*(tau*(Mas_Kft_Prec[ 5]*tau+Mas_Kft_Prec[ 4]*Tau+Mas_Kft_Prec[ 3])+dTemp));
	Precess[1] = (tau*(tau*(Mas_Kft_Prec[ 8]*tau+Mas_Kft_Prec[ 7]*Tau+Mas_Kft_Prec[ 6])+dTemp));
	dTemp = Mas_Kft_Prec[ 9]+(Mas_Kft_Prec[10]+Mas_Kft_Prec[11]*Tau)*Tau;
	Precess[2] = (tau*(tau*(Mas_Kft_Prec[14]*tau+Mas_Kft_Prec[13]*Tau+Mas_Kft_Prec[12])+dTemp));
}
#endif
*/
//----------------------------------------------------------------------------
// Расчет параметров прецессии за время tau от эпохи J2000
// dIAT_D1975 - Атомное время в ССС от 0 часов базовой эпохи
//----------------------------------------------------------------------------
/*
HRESULT Precess_J2000(double dIAT_D1975, double *Precess)
{
	double Tau = 0., tau;

	// Приведение поправки к эпохе J2000 (от 12 часов 1 января)
	tau = tau2000(t_TDT(*W_DELTA_2000+dIAT_D1975)); 
	// Расчет параметров прецессии
	preces_IERS(Tau, tau, Precess);
	// Приведение параметров прецессии в радианы
	for(int i=0; i<3; i++) Precess[i]/= k_sekrad;
	return S_OK;
}
*/
//----------------------------------------------------------------------------
/*
static double Mas_Kft_Prec_IERS2003[18] = {
	+2.650545,     //  0 - Кси_А: подставка
	+2306.083227,  //  1 -        линейная составляющая
	+0.2988499,    //  2 -        **2
	+0.01801828,   //  3 -        **3
	-5.791e-6,     //  4 -        **4
	-3.173e-7,     //  5 -        **5
	-2.650545,     //  6 - Зет_А: подставка
	+2306.077181,  //  7 -        линейная составляющая
	+1.0927348,    //  8 -        **2
	+0.01826837,   //  9 -        **3
	-2.8596e-5,    // 10 -        **4
	-2.904e-7,     // 11 -        **5
	+0.0,          // 12 - Тет_А: подставка
	+2004.191903,  // 13 -        линейная составляющая
	-0.4294934,    // 14 -        **2
	-0.04182264,   // 15 -        **3
	-7.089e-6,     // 16 -        **4
	-1.274e-7,     // 17 -        **5
} ;
//----------------------------------------------------------------------------
// Расчет параметров прецессии от Тau до Тau+tau (в угловых секундах)
//----------------------------------------------------------------------------
#ifndef PRECESSION_2003
void preces(double Tau, double tau, double *Precess);
#endif
HRESULT Precess_J2000_IERS(double Tau, double *Precess);
void preces_IERS(double Tau, double tau, double *Precess)
{
#ifdef PRECESSION_2003
 static bool   Flag_PrecessFix75 = false;
 static double PrecessFix75[3];
        double PrecessFix[3];
        UINT   i;

// Расчет параметров прецессии до текущей эпохи
 Precess_J2000_IERS( Tau+tau, Precess );
// Расчет параметров прецессии до фиксированной эпохи
 if( Tau == J_ask0 )
   { if( !Flag_PrecessFix75  )
       { Precess_J2000_IERS( Tau, PrecessFix75 ); Flag_PrecessFix75 = true; }
     for( i=0; i<3; i++ ) PrecessFix[i] = PrecessFix75[i];
   }
 else
   { Precess_J2000_IERS( Tau, PrecessFix ); }
// Расчет общей прецессии
 for( i=0; i<3; i++ ) Precess[i] -= PrecessFix[i];
#else
  preces( Tau, tau, Precess );
#endif
}
//----------------------------------------------------------------------------
// Расчет параметров прецессии за время tau от эпохи J2000
// Tau - Атомное время в ССС от 0 часов базовой эпохи
//----------------------------------------------------------------------------
HRESULT Precess_J2000_IERS(double tau, double *Precess)
{
	for( UINT i=0; i<3; i++ )
		Precess[i] = Mas_Kft_Prec_IERS2003[i*6]+
			(Mas_Kft_Prec_IERS2003[i*6+1]+
            (Mas_Kft_Prec_IERS2003[i*6+2]+
            (Mas_Kft_Prec_IERS2003[i*6+3]+
            (Mas_Kft_Prec_IERS2003[i*6+4]+
            Mas_Kft_Prec_IERS2003[i*6+5]*tau)*tau)*tau)*tau)*tau;
	return 0 ;
}
*/
//----------------------------------------------------------------------------
// по умолчанию FlagTDT = true (время TDT от ДНО), иначе время TAI
//----------------------------------------------------------------------------
double SR_E0( double Tae, bool FlagTDT )
{
	double Cs ;
	Cs = DELTA_2000 + Tae ;
	if( !FlagTDT ) Cs = t_TDT( Cs ) ;
	Cs=tau2000( Cs );
	return(sr_E0_IERS(Cs) / M_SEKRAD);
}

//----------------------------------------------------------------------------
// Расчет среднего наклона земного экватора к эклиптике (результат в угл.сек.)
//----------------------------------------------------------------------------
double sr_E0_IERS(double tau2000)
{
#ifdef E0_2003
	// AE2009
	return ((((-4.34e-8*tau2000-5.76e-7)*tau2000+0.0020034)*tau2000-0.0001831)*tau2000-46.836769)*tau2000+84381.406;
#else
	//return ((0.001813*tau2000-0.00059)*tau2000-46.81500)*tau2000+84381.448;
	// Convention_2003
	return ((0.001813*tau2000-0.00059)*tau2000-46.84024)*tau2000+84381.448;
#endif
}
//----------------------------------------------------------------------------
// t - время TDT в столетиях от J2000.0
// u - результат-вектор из 5-ти аргументов l,l',F,D,Omega в радианах
// FlagCalc - флаг расчёта (0 - 5 параметров(по умолчанию),1 - 5,GMST+PI, 2 - 5,Planet) - Жуков 09.02.09
//----------------------------------------------------------------------------
void fargTIME( double t, double *u, char FlagCalc )
{
	double x, y ;
	short  i, j ;

	// Сделать проверку по времени для оптимизации расчёта
	const static double a[5][6] = {
	// Convention_2003 - ?
	{ 1325.,-24.470e-5, 5.1635e-2, 31.8792, 715923.2178, 485868.249036 },    // Средняя аномалия Луны
	{   99.,-11.490e-5,-0.0136e-2, -0.5532,1292581.0481,1287104.793048 },    // Средняя аномалия Солнца
	{ 1342.,  0.417e-5,-0.1037e-2,-12.7512, 295262.8478, 335779.526232 },    // L-Omega
	{ 1236., -3.169e-5, 0.6593e-2, -6.3706,1105601.2090,1072260.703692 },    // Средняя элонгация (разность средних долгот) Луны и Солнца
	{   -6., -5.939e-5, 0.7702e-2,  7.4722, 813109.4569, 450160.398036 } } ; // Средняя долгота восходящего узла орбиты Луны на эклиптике                              };
	// Расчёт основных фундаментальных аргументов
	for( i = 0 ; i < 5 ; i++ ) {
		x=a[i][0]*t;
		x-=floor(x);
		for( j=1,y=0.; j<6; y=y*t+a[i][j++] );
		x+=y/1296000.;
		u[i]=(x-floor(x))*k_dwapi;
	}
	// Расчёт дополнительных аргументов
	if( FlagCalc == 1 ) { 
		// расчёт GMST+PI
		u[5] = ZAverageSiderealTime(t*36525-del_TDT/k_cbc)*k_dwapi+k_pi;
		u[5] = fmod(u[5],k_dwapi); // убираю целые циклы
	}
	if( FlagCalc == 2 ) {
		// расчёт планетных членов
		Arg_Planet( t, u+5 ); 
	}
	return ;
}
//----------------------------------------------------------------------------
// t - время TDT в столетиях от J2000.0
// u - результат-вектор из 9-ти аргументов планет в радианах
//----------------------------------------------------------------------------
void Arg_Planet(double t, double *u)
{
	//lMe
	u[0] = 4.402608842 + 2608.7903141574 * t;
	//lVe
	u[1] = 3.176146697 + 1021.3285546211 * t;
	//lE
	u[2] = 1.753470314 + 628.3075849991 * t;
	//lMa			
	u[3] = 6.203480913 + 334.0612426700 * t; 			
	//lJu
	u[4] = 0.599546497 + 52.9690962641 * t;
	//lSa
	u[5] = 0.874016757 + 21.3299104960 * t;
	//lUr
	u[6] = 5.481293872 + 7.4781598567 * t;
	//lNe
	u[7] = 5.311886287 + 3.8133035638 * t;
	//pa
	u[8] = (0.024381750 + 0.00000538691 * t) * t;
}
//---------------------------------------------------------------------------
// РАСЧЁТ МАТРИЦЫ ПЕРЕХОДА ОТ B1975 К J2000
// Параметры - double Matr_Precess[9]
//---------------------------------------------------------------------------
void Calc_Matr_Preces_B1975_J2000( double *Matr_B1975_J2000 )
{
	static bool FlagInit_mJ2000_B1975 = false;
	double      Preces[ 3 ];
	UINT        i;

	if( !FlagInit_mJ2000_B1975 ) { // Расчёт матрицы   
		memset( mJ2000_B1975, 0, 9*sizeof(double) ) ;
		// Расчет параметров прецессии
		#ifdef PRECESSION_2003
			//Precess_J2000_IERS( J_ask0, Preces );
		#else
			//preces( 0, J_ask0, Preces );
			ZPrecessJ2000( 0.5, Preces, TIME2000ASD) ;
		#endif
		// Перевод в радианы
			for (i = 0; i<3; i++) Preces[i] /= M_SEKRAD;
		// Расчет матрицы прецессии
		mJ2000_B1975[0] = -sin(Preces[0])*sin(Preces[1]) + cos(Preces[0])*cos(Preces[1])*cos(Preces[2]);
		mJ2000_B1975[1] = -cos(Preces[0])*sin(Preces[1]) - sin(Preces[0])*cos(Preces[1])*cos(Preces[2]);
		mJ2000_B1975[2] = -cos(Preces[1])*sin(Preces[2]);
		mJ2000_B1975[3] =  sin(Preces[0])*cos(Preces[1]) + cos(Preces[0])*sin(Preces[1])*cos(Preces[2]);
		mJ2000_B1975[4] =  cos(Preces[0])*cos(Preces[1]) - sin(Preces[0])*sin(Preces[1])*cos(Preces[2]);
		mJ2000_B1975[5] = -sin(Preces[1])*sin(Preces[2]);
		mJ2000_B1975[6] =  cos(Preces[0])*sin(Preces[2]);
		mJ2000_B1975[7] = -sin(Preces[0])*sin(Preces[2]);
		mJ2000_B1975[8] =  cos(Preces[2]);
		FlagInit_mJ2000_B1975 = true;
	}
	// Присвоение матрицы в выходной массив
	memcpy( Matr_B1975_J2000, mJ2000_B1975, 9 * sizeof( double ) ) ;
}

//----------------------------------------------------------------------------
