//-----------------------------------------------------------------------------
// ZCAlgebraicMdfHolder.cpp
// А. Николенко 01.04.2019
//
// Владелец коллекции локальных алгебраических моделей 
// апроксимирующих дискретно функцию, заданную набором значений аргумента 
// и самой функции.
//-----------------------------------------------------------------------------
#include <stdafx.h>

#include <math.h>
#include <iostream>
#include <fstream>

#include <FlyCoreSource\\ZCAlgebraicMDF.h>
#include <FlyCoreSource\\ZCAlgebraicMdfHolder.h>

//-----------------------------------------------------------------------------
// Вычисление момента начала тайм фрейма содержащего момент времени t,
// заданный модифицированной юлианской датой, и длительности 
// TimeFrame юлианских дней.
double ZCAlgebraicMdfHolder::FindTimeFrameBeg(double t, bool fromMjd)
{
	// MJD в формате двойного числа 
	TheDblTime  dMjd;
	// Календарная дата и время в UTC для заданного момента времени t
	DATETIMEUTC UTC;
	if (fromMjd) {
		// Время задано как MJD в формате одного числа
		dMjd = t;
		ZFMJDtoDMYH(dMjd, &UTC);
	} else {
		// Время t задано как атомное время - время выраженное в ССС,
		// равномерно текущее и отсчитываемое от эпохи начала отсчёта
		// времени (0h 0m 0s 01.01.1975)
		UTC << t;
	}
	// В зависимости от даты в качестве начала фрейма полагаяем либо
	// 01 января текущего года, либо 01 июля текущего гожа.

	if (TimeFrameType == 0) {
		// по месяцам
	}
	else {
		if (TimeFrameType == 1) {
			// по кварталам
			if (UTC.M > 9) UTC.M = 10;
			else {
				if (UTC.M > 6) UTC.M = 7;
				else {
					if (UTC.M > 3) UTC.M = 4;
					else {
						UTC.M = 1;
			}	}	}	
		} else {
			if (TimeFrameType == 2) {
				// полугодие
				UTC.M = UTC.M < 7 ? 1 : 7;
			} else {
				if (TimeFrameType == 3) {
					// год
					UTC.M = 1;
				} else {
					assert(0);
	}	}	}	}
	UTC.D = 1;
	UTC.h = UTC.m = UTC.s = 0; UTC.d = 0.0;
	// Преобразуем обратно в MJ
	ZFDMYHMStoMJD(UTC, &dMjd);
	return dMjd.LikeDouble() ;
}

//-----------------------------------------------------------------------------
// Поиск в коллекции моделей (в оперативном массиве локальных моделей),
// поиск модели область определения которой содержит момент времени t
int ZCAlgebraicMdfHolder::FindModInCollection(double t, ZCAlgebraicMDF* FM)
{
	int    N = VM.size();
	if (CI >= 0 && CI < N) {
		// Проверка текущей локальной модели
		ItVM = VM.begin();
		ItVM+= CI;
		// Если время лежит в пределах области определения моделт,
		// то модель найдена
		if (ItVM->IsDomainFrom(t)) {
			// Если задан адрес для возврата найденной модели то найденная
			// модель копируется !!! ==> происходит выделение памяти под
			// коэффициенты
			if (FM) FM->Cpy(*ItVM);
			// Возвращяется индекс найденной модели
			return CI;
		} else {
			// В противном случае ... 
			if (t > ItVM->GetET()) {
				// Если время больше чем правая граница области определения
				// текущей локальной модели, тогда перебираем все модели 
				// коллекции вперёд.
				ItVM++; CI++;
				while (ItVM != VM.end()){
					if (ItVM->IsDomainFrom(t)) {
						// Найдена модель область определения которой содержит
						// время t.
						if (FM) FM->Cpy(*ItVM);
						return CI;
					}
					ItVM++; CI++;
				}
				// Все локальные модели из коллекции были просмотреныи нужной 
				// не оказалось ===> в коллекции нужной модели нет, значит 
				// такая модель должна быть загружена из хранилища или 
				// сгенерирована по значениям дискретной функции.
				CI =-1;
				return-1;
			} else {
				while (1){
					// Если время меньше чем левая граница области определения
					// текущей локальной модели, тогда перебираем все модели 
					// коллекции назад.
					if (ItVM->IsDomainFrom(t)) {
						// Найдена модель область определения которой содержит
						// время t.
						if (FM) FM->Cpy(*ItVM);
						return CI;
					}
					ItVM--; CI--;
					if (CI < 0) {
						// Все локальные модели из коллекции были просмотреныи 
						// нужной не оказалось ===> в коллекции нужной модели  
						// нет, значит такая модель должна быть загружена из 
						// хранилища или сгенерирована по значениям 
						// дискретной функции.
						return-1;
	}	}	}	}	}

	if (!N) {
		// Коллекция пустая, следовательно необходимо загрузить из хранилища
		// или сгенерировать локальную модель
		return -1;
	}

	// Текущей модели нет, следовательно поиск актуальной для момента времени
	// t модели выполняется переборпом среди всех элементов коллекции моделей.
	for (auto M : VM) {
		if (M.IsDomainFrom(t)) {
			// Найдена модель область определения которой содержит время t.
			ItVM = VM.begin(); 
			ItVM+= CI;
			if (FM) FM->Cpy(*ItVM);
			return CI;
		}
		CI++;
	}

	// Все локальные модели из коллекции были просмотреныи нужной 
	// не оказалось ===> в коллекции нужной модели нет, значит 
	// такая модель должна быть загружена из хранилища или 
	// сгенерирована по значениям дискретной функции.
	CI =-1;
	return-1;
}

//-----------------------------------------------------------------------------
// Поиск в хранеилище (долгосрочном архиве локальных моделей - файл или БД),
// поиск модели область определения которой содержит момент времени t
int ZCAlgebraicMdfHolder::FindModInStorage(double t, ZCAlgebraicMDF* FM)
{
	ifstream f;
	f.open(GetFileStorageName(), ios::in | ios::binary);
	if (!f.is_open()) return-1;
	if (f.eof()) {
		f.close();
		return-1;
	}

	//-------------------------------------------------------------------------
	// Чтение колличества моделей.
	int N = 0;
	f.read((char*)(&N), sizeof(int));
	if (N <= 0) {
		f.close();
		return-1;
	}

	// размер одной записи заголовка 
	unsigned long sizeHeaderItem = sizeof(ZSStorageEOPHeaderItem);
	// Размер заголовка файла в котором по числу моделей содержится
	// Время начала Тайм фрейма модели и смещение данных модели от
	// начала файла - два числа double и unsigned long
	unsigned long sizeHeader = sizeof(int) + N*sizeHeaderItem;
	// Смещение до начала считываемых данных
	unsigned long shiftData = sizeof(int);
	// Смещение до начала первой записи заголовка
	f.seekg(shiftData);
	if (f.eof()) {
		f.close();
		return -1;
	}

	int Count = 0;
	int j =-1;
	ZSStorageEOPHeaderItem HI;
	while (1) {
		// чтение очередной записи заголовка
		f.read((char*)(&HI), sizeHeaderItem);
		// Проверка на конец файла
		if (f.eof()) break;
		// Увеличение счётчика просмотренных записей заголовка
		Count++;
		// Проверка области определения текущей локальной модели
		if (HI.MJD > t && t < HI.MJD + TimeFrame) {
			// Область определения данной локальной модели содержит
			// момент времени t. Необходимо уточнение для участка перекрытия
			// области определения со следующей локальной моделью.
			shiftData = HI.shiftData;
			j = Count;
		}
		if (j >= 0) {
			// Проверка перекрытия локальных моделей
			if (HI.MJD > t) {
				// Локальная модель найдена. Индекс модели 
				// в хранилище равен j
				break;
		}	}
		if (Count >= N) break;
	}

	if (j < 0) {
		// Модели для времени t в хранилище не найдено
		f.close();
		return-1;
	}

	// Смещение до начала данных найденной локальной модели
	f.seekg(shiftData);
	if (f.eof()) {
		f.close();
		return -1;
	}

	// Считывание модели из хранилища
	if (FM->LoadFromStream(f, TimeFrame)) {
		j =-1;
	}
	
	f.close();
	return j;
}

//-----------------------------------------------------------------------------
// Поиск уже существующецй созданной ранее локальной модели.
int ZCAlgebraicMdfHolder::FindMod(double t, ZCAlgebraicMDF* FMS, ZCAlgebraicMDF* FMC)
{
	int i = 0; 
	i = FindModInCollection(t, FMC);
	if (i < 0) i = FindModInStorage(t, FMS);
	return i;
}

//----------------------------------------------------------------------------
/*
int ZCAlgebraicMdfHolder::NewMod(double t)
{
	// Желательно реализовать проверку на наличие модели
	// актуальной для времени t в опреативном массиве моделей VM. 
	// Если такая модель уже существует, то возможно её и создавать вновь не
	// следует?...




	// Загрузка дискретной функции
	double* T = nullptr;
	double* Y = nullptr;
	int     rc, N = 0;
	// Вычисление начала Тайм фрейма
	double  fromTime = FindTimeFrameBeg(t);
	// Вычисление правой границы Тайм фрейма
	double  toTime = fromTime + TimeFrame;
	// Загрузка массивов значений и аргумкнта дискретной функции
	// с выделением памяти под массивы T, Y.
	rc = LoadDFfromTime(fromTime, toTime, &T, &Y, N);
	// Проверка корректности проведённой загрузки
	if (rc || !T || !Y || N < 5) return-1;
	// Создание алгебраической модели с вызовом процедуры метода 
	// апроксимации по Чебышёву, с формированием текущего итератора ItVM
	// и индекса CI локальной модели в коллекции моделей.
	ItVM = VM.emplace(VM.end(), ZCAlgebraicMDF(T, Y, N, 12));
	CI = VM.size();
	// Удаление временных массивов аргумента и значений апроксимируемой
	// дискретной функции.
	delete[] T;
	delete[] Y;
	return 0;
}
*/
//----------------------------------------------------------------------------
int ZCAlgebraicMdfHolder::BuildNewMod(double* T, double* Y, int N)
{
	// Проверка корректности проведённой загрузки
	if (!T || !Y || N<3) return-1;
	// Создание алгебраической модели.
	// В конец коллекции моделей вставляется новая модель которая 
	// одновременно создаётся посредством "генерирующего конструктора".
	// Далее в соответствии с сематикой перемещения, созданный объект
	// перемещается в коллекцию - вызывается конструктор перемещения.	
	try {
		ItVM = VM.emplace(VM.end(), ZCAlgebraicMDF(T, Y, N, 12));
		// ... новая моделль добавлена в конец коллекции
	} catch (...) {
		return 1;
	}

	// Добавление новой созданной модели в хранилище 
	vector<ZCAlgebraicMDF> LVM;
	LVM.push_back(VM[VM.size() - 1]);
	int rc = UpdateStorage(&LVM, false);

	// Сортировка оперативного масива моделей (то есть коллекции моделей)
	sort(VM.begin(), VM.end());

	return rc;
}

//----------------------------------------------------------------------------
int ZCAlgebraicMdfHolder::Calc(double t, double& F)
{
	if (CI >= 0) {
		ItVM = VM.begin();
		ItVM += CI;
		if (ItVM != VM.end() && ItVM->IsDomainFrom(t)) {
			// Текущая модель является актуальной для заданного 
			// момента времени.
			// Собственно вычисление полинома
			F = ItVM->Calc(t);
			return 0;
	}	}

	int rc;
	// Поиск необходимой локальной модели в коллекции и в хранилище
	ZCAlgebraicMDF MS;
	rc = FindMod( t, &MS);
	// Если модель нигде не найдена
	if (rc < 0) {
		// Модель не найдена ни в хранилище ни в коллекции.
		// В данной ситуации модель должна быть создана по данным
		// ПВЗ загруженным из хранилища ПВЗ, полученная модель должна быть
		// сохранена в хранилище и добавлена в коллекцию. Как хранилище,
		// так и коллекия должны бытть отсортированнны по времени
		// 
		// !!! В данной ситуации возвращается код ошибки 100, означающий
		// что управляющий фрагмент кода должен выполнить загрузку значений
		// моделируемой дискретной функции и перед повторной попыткой
		// вычисления сгенерировать новую модель, добавить ее в хранилище и
		// коллекцию моделей.
		return 100;
	}
	// Если модель найдена
	if (rc >= 0) {
		// Проверка найденной модели... найдена ли она в хранилище?
		if (!MS.MA()) {
			// Мордель найдена в коллекции... тогда ... 
			// индекс новой текущей модели в коллекции 
			CI = rc;
		}
		else {
			// Мордель найдена в хранилище и из хранилища загружена в
			// объект MS. 
			// Увелисчивается размерность коллекции.
			int N = VM.size();
			VM.resize(N + 1);
			// Найденная модель перемещается в коллекцию
			VM[N].Move(MS);
			// Коллекция сортируется
			sort(VM.begin(), VM.end());
			// Индекс новой актуальной модели в коллекции
			CI = FindModInCollection(t);
			if (CI < 0) {
				// Модель обязательно должна была появиться в коллекции и
				// обязательно должна была быть найдена
				assert(0);
	}	}	}

	// Итератор начала коллекции
	ItVM = VM.begin();
	// Итератор указывающий на новую актуальную локальную модель
	ItVM += CI;

	// Собственно вычисление полинома
	F = ItVM->Calc(t);
	return 0;
}

//----------------------------------------------------------------------------
int ZCAlgebraicMdfHolder::Calc(double t, float& F)
{
	double dF; 
	int rc = Calc(t, dF);
	F = (float)dF;
	return rc;
}

//----------------------------------------------------------------------------
// Методы загрузки значений дискретной функции
//----------------------------------------------------------------------------
/*
int ZCAlgebraicMdfHolder::LoadDFfromTime(double fromTime, double toTime,
										 double** T, double** Y, int& N)
{
	N = 0;
	*T = nullptr;
	*T = nullptr;
	//
	N = (int)(toTime - fromTime) + 1;
	try {
		*T = new double[N];
		*Y = new double[N];
		for (int i = 0; i<N; i++) {
			double x = (double)i;
			(*T)[i] = x + fromTime;
			(*Y)[i] = sin(6.0*x / 365.0);
		}
	} catch (...) {
		return -1;
	}
	return 0;
}*/

//-----------------------------------------------------------------------------
int ZCAlgebraicMdfHolder::SaveToStorage(vector<ZCAlgebraicMDF>* LVM)
{
	if (!LVM) LVM = &VM;

	int N = LVM->size(); if (!N) return-2;
	ofstream f;
	f.open(GetFileStorageName(), ios::out | ios::binary);
	if (!f.is_open()) return-1;
	//
	int i;
	// Сортировка построенных моделей по времени
	sort(LVM->begin(), LVM->end());
	// Размер заголовка файла в котором по числу моделей содержится
	// Время начала Тайм фрейма модели и смещение данных модели от
	// начала файла - два числа double и unsigned long
	unsigned long sizeHeader = sizeof(int) + N*(sizeof(double) +
		sizeof(unsigned long));
	// Смещение данных модели от начала файла.
	// Смещение первой модели от начала файла равно длинне 
	// заголовка файла.
	unsigned long shiftData = sizeHeader;

	// Запись в файл колличества моделей.
	f.write((const char*)(&N), sizeof(int));
	// Запись в файл данных заголовка, для каждой модели 
	// последовательно начало тайм фрейма и её смещение в файле.
	for (i = 0; i<N; i++) {
		// Время тачала Тайм фрейма.
		double BT = (*LVM)[i].GetBT();
		f.write((const char*)(&BT), sizeof(double));
		// Смещение модели в файле.
		f.write((const char*)(&shiftData), sizeof(unsigned long));
		// Изменяем смещение в файле на размер модели.
		shiftData += ((*LVM)[i].GetDegree() + 2)*sizeof(double) + sizeof(int);
	}
	// Запись последовательно данных каждой модели
	// Время начала Тайм фрейма, степень полинома, 
	// массив коэффициентов
	for (auto M: (*LVM)) M.StoryToStream(f);

	f.close();
	return 0;
}

//-----------------------------------------------------------------------------
// Обновить хранилище моделей новыми сгенерированными моделями.
// Модели, имеющие признак isGenerated равный true будут помещены в
// хранилище моделей.
int ZCAlgebraicMdfHolder::UpdateStorage(vector<ZCAlgebraicMDF>* LVM, bool LikeMove)
{
	if (!LVM) LVM = &VM;
	int rc = 0;

	// Загрузка локальных моделей из хранилища
	vector<ZCAlgebraicMDF> SVM;
	rc = LoadFromStorage(&SVM); if (rc) return 1;

	// Подсчёт новых моделей
	int CountNew = 0;
	for (ZCAlgebraicMDF M : (*LVM)) { if (M.IsGener()) CountNew++; }

	// Резервирование памяти в коллекции моделей под новые модели
	SVM.reserve(SVM.size() + CountNew);

	// Вставка в коллекцию моделей ранее сохранённых моделей.
	// Фактически объединение того что было в памяти и того что 
	// находилось в хранилище
	// В хранилище добавляются только вновь созданные модели !!!!
	for (ZCAlgebraicMDF M : (*LVM)) { 
		if (M.IsGener()) SVM.insert(SVM.end(), LikeMove ? move(M) : M);
	}

	// Сортировка моделей по времени
	sort(SVM.begin(), SVM.end());

	// Сохранение полученногог массива моделей в хранилище
	rc = SaveToStorage(&SVM); if (rc) return 2;

	// Удаление промежуточной коллекции моделей LVM
	for (auto M : SVM) M.Clr();
	SVM.clear();
	// Если требуется перемещение (LikeMove) то освобождаем ресурсы LVM
	if (LikeMove) {
		for (auto M : (*LVM)) M.Clr();
		LVM->clear();
	}

	return 0;
}

//-----------------------------------------------------------------------------
// Загрузить из хранилища все имеющиеся там полиномиальные модели
int ZCAlgebraicMdfHolder::LoadFromStorage(vector<ZCAlgebraicMDF>* LVM)
{
	if (!LVM) LVM = &VM;

	ifstream f;
	f.open(GetFileStorageName(), ios::in | ios::binary);
	if (!f.is_open()) return-1;

	// Удаляется массив загруженных ранее моделей
	LVM->clear();

	//-------------------------------------------------------------------------
	// Чтение колличества моделей.
	int N = 0;
	f.read((char*)(&N), sizeof(int));
	if (N <= 0) return-1;
	// Резервируем в массиве моделей место для N моделей
	LVM->reserve(N);

	// Размер заголовка файла в котором по числу моделей содержится
	// Время начала Тайм фрейма модели и смещение данных модели от
	// начала файла - два числа double и unsigned long
	unsigned long sizeHeader = sizeof(int) + N*(sizeof(double) +
							   sizeof(unsigned long));
	// Смещение данных модели от начала файла.
	// Смещение первой модели от начала файла равно длинне 
	// заголовка файла.
	unsigned long shiftData = sizeHeader;

	//-------------------------------------------------------------------------
	// Смещение в файле до начала описания моделей
	f.seekg(shiftData);

	//-------------------------------------------------------------------------
	// Чтение последовательно данных каждой модели
	// Время начала Тайм фрейма, степень полинома, 
	// массив коэффициентов
	int i=0;
	LVM->resize(N);
	for (auto M : (*LVM)) {
		if (M.LoadFromStream(f, TimeFrame)) break;
		i++;
	}
	// Закрытие файла
	f.close();
	// Уменьшение размерности коллекции моделей если не все N моделей 
	// загружены из хранилища
	if (i<N) {
		LVM->resize(i);
		return-3;
	}
	return 0;
}

//-----------------------------------------------------------------------------
// Загрузить из хранилища полиномиальную модель актуальную 
// для времени fromTime 
int ZCAlgebraicMdfHolder::LoadFromStorage(double fromTime)
{
	ifstream f;
	f.open(GetFileStorageName(), ios::in | ios::binary);
	if (!f.is_open()) return-1;

	// Чтение колличества моделей.
	int N = 0;
	f.read((char*)(&N), sizeof(int));
	if (N <= 0) return-1;

	// Размер заголовка файла в котором по числу моделей содержится
	// Время начала Тайм фрейма модели и смещение данных модели от
	// начала файла - два числа double и unsigned long
	unsigned long sizeHeader = sizeof(int) + N*(sizeof(double) +
							   sizeof(unsigned long));

	//-------------------------------------------------------------------------
	// Чтение заголовка и поиск модели, область определения которой
	// содержит момент времени fromTime...
	// fromTime должен принадлежать промежутку времени от 
	// begTime до (begTime+TimeFrame)
	int i;
	double BT;
	unsigned long needPos = -1;
	for (i = 0; i<N; i++) {
		if (f.eof()) break;
		f.read((char*)(&BT), sizeof(double));
		if ((fromTime - BT)*(fromTime - BT - TimeFrame) <= 0) {
			// Нужная модель найдена
			if (f.eof()) break;
			f.read((char*)(&needPos), sizeof(unsigned long));
			break;
		}
		f.seekg(f.tellg() + (streamoff)sizeof(unsigned long));
	}
	// Проверка, найдена ли модель
	if (needPos<sizeHeader) return-1;
	// Смещение до нужной модели
	f.seekg(needPos);

	//-------------------------------------------------------------------------
	// Собственно считывание модели
	if (f.eof()) return-2;
	i = VM.size();
	VM.resize(i + 1);
	if (VM[i].LoadFromStream(f, TimeFrame)) VM.resize(i);

	//-------------------------------------------------------------------------
	// Сортировка моделей по времени
	sort(VM.begin(), VM.end());
	return 0;
}

//-----------------------------------------------------------------------------
// Загрузить из хранилища одну или несколько полиномиальных  
// моделей актуальных для интервала времени 
// от fromTime до toTime.
int ZCAlgebraicMdfHolder::LoadFromStorage(double fromTime, double toTime)
{
	// Открытие файла-хранилища для чтения в двоичном режиме
	ifstream f;
	f.open(GetFileStorageName(), ios::in | ios::binary);
	if (!f.is_open()) return-1;

	// Чтение колличества моделей в хранилище.
	int N = 0;
	f.read((char*)(&N), sizeof(int));
	if (N <= 0) return-1;

	// Размер заголовка файла в котором по числу моделей содержится
	// Время начала Тайм фрейма модели и смещение данных модели от
	// начала файла - два числа double и unsigned long
	unsigned long sizeHeader = sizeof(int) + N*(sizeof(double) +
							   sizeof(unsigned long));

	//-------------------------------------------------------------------------
	// Чтение заголовка и поиск модели, область определения которой
	// содержит момент времени fromTime...
	// fromTime должен принадлежать промежутку времени от 
	// begTime до (begTime+TimeFrame)
	int i;
	double BT;						// Начало Тайм фрейма читаемое из хранилища
	unsigned long needPos;			// Считываемое смещение модели	
	vector<unsigned long> Position;	// Вектор смещения нужных моделей в хран-ще
	// Перебор всех записей заголовка хранилища
	for (i = 0; i<N; i++) {
		if (f.eof()) break;
		// Считываение начала Тайм фрейма
		f.read((char*)(&BT), sizeof(double));
		// Проверк попадания Тайм фрейма в заданный интервал времени
		if ((fromTime - BT)*(fromTime - BT - TimeFrame) <= 0 ||
			(toTime - BT)*(toTime - BT - TimeFrame) <= 0 ||
			(BT - fromTime)*(BT - toTime) <= 0) {
			// Нужная модель найдена.
			if (f.eof()) break;
			// Считывание смещения до нужной модели.
			f.read((char*)(&needPos), sizeof(unsigned long));
			// Сохранение считанного смещения.
			Position.push_back(needPos);
		}
		else {
			// Смещение до следующей записи заголовка
			f.seekg(f.tellg() + (streamoff)sizeof(unsigned long));
		}
	}
	// Проверка, найдены ли все модели
	if (i<N) return-1;
	N = Position.size();
	if (!N) return-2;

	//-------------------------------------------------------------------------
	// Собственно считывание моделей
	for (i = 0; i<N; i++) {
		// Смещение до нужной модели
		f.seekg(Position[i]); if (f.eof()) return-3;
		// Увеличение размерности массива моделей
		int J = VM.size();
		VM.resize(J + 1);
		if (VM[J].LoadFromStream(f, TimeFrame)) {
			VM.resize(J);
			return 4;
	}	}

	//-------------------------------------------------------------------------
	// Сортировка моделей по времени
	sort(VM.begin(), VM.end());
	return 0;
}

//-----------------------------------------------------------------------------