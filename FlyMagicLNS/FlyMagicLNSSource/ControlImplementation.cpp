//-------------------------------------------------------------------------------
// ControlImplementation.cpp : 
// А. Николенко 12.10.2018
//-------------------------------------------------------------------------------
#include <stdafx.h>

//---------------------------------------------------------------------------
// Компоненты Fly
#include <FlyMMath.h>		// Математические функции
#include <FlyCore.h>		// Математические функции
#include <FlyMagicLNS.h>	//

//---------------------------------------------------------------------------
// Если данный макрос определён то, 
// определение времени включения и выключения ДУ по заданному аргументу широты
// середины активного участка выполняется с учётом динамики предыдущих включений ДУ.
// 
// В противном случае данная операция выполняется в пассивном полёте.
// Как следствие, расхождения в аргументах приложения импульсов на расчётной траектории
// для второго и третьего включений ДУ со значениями полученными при аналитическом расчёте 
// параметров управления будут тем существеннее, чем активнее маневрирует КА.
#define IS_ESTIMATETIME_FROM_U2_U3

//-------------------------------------------------------------------------------
// Моделирование движения КА с учётом программы управления его движением
// Программа управления задаётся в виде структуры	ZSFlightRule U 
//-------------------------------------------------------------------------------
int ControlImplementation(ZMSC& KA, ZNU& NU, ZCDU& DU, ZSFlightRule& U, ZSC_SI* SI, ZSC_VI* VI, ZNU* RIKNU)
{
	int    i, rc = 0 ;
	int    HSTORYV2 = 0 ;
	double m0 = KA.WeightFullNU() ;
	double dm = 0 ; 
	double dms= 0 ;
	
	// Программа управления движением центра масс - как атрибут иодели движения
	ZPU PU ;	
	// Удаляем какие бы то ни было программы управления
	KA.MPU.Del() ;
	// Сохраняем состояние модели движения
	HSTORYV2 = KA.Story(HSTORYV2) ; if (!HSTORYV2) return 1 ;

#ifndef IS_ESTIMATETIME_FROM_U2_U3
	// Определение времени включения и выключения ДУ по заданному аргументу широты
	// середины активного участка в пассивном полёте
	for (i=0; i<U.n; i++) {
		// Учёт возможности сползвния начала импульсы на предыдущий виток
		// или наоборот на следующий
		long vit = U.vit[i] ;
		double u = U.u0[i] ;
		if (u<0)     { u+= 360.0 ; vit-= 1 ;}
		if (u>360.0) { u-= 360.0 ; vit+= 1 ;}
		rc = KA.GoToVitU(NULL, vit, u, IDSK_ASKTE) ; RRC ; 
		// Время включения ДУ 
		U.t[i] = KA.GetTime() ;
		U.t[i]-= U.dts[i]/2.0/k_cbc ;
	}
#endif 

	//U.t[0]  << DATETIMEDMB(14, 12, 2015, 13, 40, 39, 0.027) ;
	//U.dts[0] = 18.6436676205028 ; 
	//U.t[1]  << DATETIMEDMB(14, 12, 2015, 16, 28, 46, 0.342) ;
	//U.dts[1] = 12.1813314482397 ; 

	//--------------------------------------------------------------------------
	// Моделирование движения КА с учётом программы управления 
	// с одновременным формированием НУ с РИК и параметров движения на витки импульсов
	for (i=0; i<U.n; i++) {
		// Определение времени включения и выключения ДУ по заданному аргументу широты
		// середины активного участка с учётом динамики предыдущих включений ДУ
#ifdef IS_ESTIMATETIME_FROM_U2_U3
		// Выход на середину очередного активного участка
		// для определения времени включения ДУ
		// Необходимо для учёта эволюции параметров орбиты 
		// на предыдущем включении ДУ

		// Учёт возможности сползвния начала импульсы на предыдущий виток
		// или наоборот на следующий
		// Приведение аргумента широты в диапазон [0; 360] град с 
		// одновременной, при необходимости, коррекцией витка. 
		SuitabilityTurnArg(U.u0[i], U.vit[i], 1);

		rc = KA.GoToVitU(U.vit[i], U.u0[i]); RRC;
		// Время включения ДУ 
		U.t[i] = KA.GetTime() ;
		U.t[i]-= U.dts[i]/2.0/k_cbc ;
#endif 

		// Восстанавливаем состояние модели движения
		// (на момент завершения предыдущего включения ДУ)
		rc = KA.ReStory(HSTORYV2) ; RRC ;

		// Создаём программу управления для (i+1)-го включения ДУ
		rc = MagicMakePU(1, m0-dms, &dm, U, DU, PU, i, i) ; if (rc) goto end ;
		dms+= dm ;

		// Выкладываем программу управления в модель движения
		KA.MPU.Add(PU) ;

		// Прогноз параметров движения на начало активного участка
		ZSC_SI SIT ;
		rc = KA.GoToTime(U.t[i], &SIT) ; RRC ;
		// Аргумент широты начала активного участка
		U.us[i] = GradA(SIT.OSKTE[5]) ;
		U.vs[i] = SIT.VitTE ;

		// Прогноз на конец активного участка
		rc = KA.GoToTime(U.t[i]+U.dts[i]/k_cbc, &SIT) ; RRC ;
		// Аргумент широты конца активного участка
		U.ue[i] = GradA(SIT.OSKTE[5]) ;
		U.ve[i] = SIT.VitTE ;

		// Удаляем программу управления
		KA.MPU.Del() ;

		// Сохраняем состояние модели движения 
		// (на момент завершения предыдущего включения ДУ)
		HSTORYV2 = KA.Story(HSTORYV2) ; if (!HSTORYV2) return 1 ;

		// Прогноз на начало витка, следующего за витком (i+1)-го импульса
		rc = KA.GoToVit(U.vit[i]+1) ; RRC ; 
		// Архивирование параметров движения для последующего документирования
		memcpy(&SI[2+i], &KA.FSR, sizeof(SI[2+i])) ;

		// Формирование НУ с РИК		
		RIKNU[i] = NU ;
		RIKNU[i].sk = _SK_ASK2000 ;
		KA.GetVector(RIKNU[i].X, &RIKNU[i].vit, &RIKNU[i].t, &RIKNU[i].MF, RIKNU[i].sk) ;
		RIKNU[i].MF-= RIKNU[i].M0 ;
		RIKNU[i].Key.type = 8 ;
		RIKNU[i].Key.mod  = i+1 ;

		// Моделирование пассивного полёта вдоль витка, 
		// следующего за витком (i+1)-го импульса, с расчётом всех интгральных параметров витка
		rc = KA.GoAlongVit(U.vit[i]+1, _SK_ASKTE) ; RRC ;
		// Архивирование интегральных параметров движения вдоль витка 
		// для последующего документирования
		memcpy(&VI[2+i], &KA.FV, sizeof(VI[2+i])) ;

		// Восстанавливаем состояние модели движения
		// (на момент завершения предыдущего включения ДУ)
		rc = KA.ReStory(HSTORYV2) ; RRC ;
	}

end : ;
	// Удаляем программу управления
	// Это необходимо сделать так как последний импульс может начинаться 
	// на витке V2 а заканчиваться на витке V*, то есть на заданном витке.
	// Тогда при последующем выполнении процедуры KA.GoAlongVit будет 
	// иметь место частичное моделирование движения КА с отрицательным шагом 
	// и при этом повторно будет учтена работа ДУ, что естественно исказит 
	// результаты прогноза.
	KA.MPU.Del() ;
	return rc ;
}

//-------------------------------------------------------------------------------
