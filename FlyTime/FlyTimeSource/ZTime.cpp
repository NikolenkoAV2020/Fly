//-----------------------------------------------------------------------------
// ZTime.cpp
// А. Николенко 03.08.2018
//-----------------------------------------------------------------------------
#include "stdafx.h"

//-----------------------------------------------------------------------------
// Компоненты Fly
#include <FlyMMath.h>		// Математические функции

//-----------------------------------------------------------------------------
#include <FlyTimeSource\\ZTime.h>

//-----------------------------------------------------------------------------
// Вычисление времени в нужной эпохе и в нужном масштабе необходимых
// для астрономических функций
double Astro2000Time(double ta, TIMESCALE Scale, double* ta_)
{
	double t = ta ;
	// Перевод времени в доли юлианского столетия от эпохи J2000
	if ( Scale != 2 ) {
		if ( Scale == 1 ) t = ta+DELTA_2000+del_TDT/k_cbc ;
		// Вычисление IAT по времени от (0h 01.01.2000)
		else ta = t-DELTA_2000-del_TDT/k_cbc ;				
		t = (t-0.5)/36525 ;
	} else {
		// Если flag==2 то мы имеем время уже готовое для вычисления 
		// полиномов АЕ. Вычисление IAT по времени в столетиях 
		// от (12h 01.01.2000)
		ta = t*36525+0.5-DELTA_2000-del_TDT/k_cbc ;			
	}
	if (ta_) *ta_ = ta ;
	return t ;
}

//-----------------------------------------------------------------------------
double  ZTime::Z_DIAT_CurDT   = 0 ;
double	ZTime::Z_DIAT_CurTime =-9999999 ;
double	ZTime::Z_DIAT_NextTime=-9999999 ;
int		ZTime::Z_Count_DIAT   = 17 ;
double	ZTime::Z_DIAT[34] = {
	//t IAT75		dUTC_IAT
	//в ссс			в сек 
	0,				 0.0,	// 01.01.1975 	
    3653.0,			-23.0,	// 01.01.1985 	
	4748.0,			-24.0,	// 01.01.1988 	
	5479.0,			-25.0,	// 01.01.1990 	
	5844.0,			-26.0,	// 01.01.1991 	
	6391.0,			-27.0,	// 01.07.1992 	
	6756.0,			-28.0,	// 01.07.1993 	
	7121.0,			-29.0,	// 01.07.1994 	
	7670.0,			-30.0,	// 01.01.1996 	
	8217.0,			-31.0,	// 01.07.1997 	
	8766.0,			-32.0,	// 01.01.1999 	
	11323.0,		-33.0,	// 01.01.2006 	
	12419.0,		-34.0,	// 01.01.2009 	
	13696.0,		-35.0,	// 01.07.2012 	
	14791.0,		-36.0,	// 01.07.2015 	
	14975.0,		-37.0,	// 01.01.2016 
	9999999999.0,	-37.0	//  
} ;

//-----------------------------------------------------------------------------
// Вычисление модиф юлианской даты на заданную гражданскую дату 
// и 0 часов всемирного времени
//-----------------------------------------------------------------------------
double ZTime::UTCDMYtoMJD(DATE dateUT, double* mjd)
{
	return (UTCDMYHtoMJD(dateUT.d, dateUT.m, dateUT.g, nullptr, mjd)) ; 
}

//-----------------------------------------------------------------------------
double ZTime::UTCDMYtoMJD(int d, int m, int g, double* mjd)
{
	return (UTCDMYHtoMJD(d, m, g, nullptr, mjd)) ;
}

//-----------------------------------------------------------------------------
double ZTime::UTCDMYHMStoMJD(DATETIMEDMB D, double* mjd)
{
    double H = D.h+D.m/60.0+(D.s+D.d)/3600.0 ;
	return(UTCDMYHtoMJD(D.D, D.M, D.G, &H, mjd)) ;
}

//-----------------------------------------------------------------------------
double ZTime::UTCDMYHMStoMJD(int d, int m, int g, int h, int min, double s, double* mjd)
{
    double H = h+min/60.0+s/3600.0 ;
	return (UTCDMYHtoMJD(d, m, g, &H, mjd)) ;
}

//-----------------------------------------------------------------------------
double ZTime::UTCDMYHtoMJD(int d, int m, int g, double* h, double* mjd)
{
	double MJD = (g - 1) * 365l + (g - 1) / 4 - (g - 1) / 100 + 
				 (g - 1) / 400 + 1721425l + (m - 1) * 30 + d - 1;
	if (m>2) {
		MJD -= 2;
		if (g % 4 == 0) {
			MJD+= 1;
			if (g % 100 == 0 && g % 400!= 0) MJD-= 1;
	}	}
    MJD+= 0.5 ;
	if (h  ) MJD+= (*h) / 24.0;
	if (m>8) MJD+= (m + 1) / 2;
	else     MJD+= m / 2;
	MJD -= ZMJD0;
	if (mjd) *mjd = MJD;
	return MJD;
}

//-----------------------------------------------------------------------------
// Вычисление модиф юлианской даты на заданный момент атомного времени
//-----------------------------------------------------------------------------
double ZTime::AtomicTimetoMJD(double AtomicTime, double* mjd) 
{
	// Вычитаем зональную поправку для перехода от ДМВ к UTC
	AtomicTime-= 0.125 ;
	// Преобразование атомного времени в структуру
	DATETIMEDMB DT ; DT<< AtomicTime ;
	double MJD = UTCDMYHMStoMJD(DT) ; 
	if (mjd) *mjd = MJD ;
	return MJD ;
}

//-----------------------------------------------------------------------------
// Вычисление гражданской даты всемирного времени для 
// заданного модиф юлианской даты
//-----------------------------------------------------------------------------
DATE ZTime::MJDtoUTCDMY(double MJD, DATE* dateUT)
{
	long        jdt ; 
	long double d, jd ;
	static int  daym[12]={31,28,31,30,31,30,31,31,30,31,30,31},id,i;
	jd = MJD;
	jd+= ZMJD0;

	jdt = (long)((jd-1721425.5)/365.242198781) ;
	d   = jd-1721425.5-jdt*365-jdt/4+jdt/100-jdt/400 ;
	if (d==365l && (jdt%4)!=0) {
		d-= 365 ; 
		jdt+=1 ; 
	}
	id  =(int)d ; 
	d   = d-id ; 
	jdt+=1 ;

	if (jdt%4==0) daym[1]+= 1 ;
	if (jdt%100==0 && jdt%400!=0) daym[1]-= 1 ;
	for (i=0; i<12; i++) { 
		id-= daym[i] ; 
		if (id<0) break ;
	}
	id+= daym[i]+1 ; 
	daym[1] = 28 ;
	if (id>31) {
		id  = 1 ; 
		i   = 0 ; 
		jdt+= 1 ;
	}
	DATE date;
	date.d = id ; 
	date.m = i+1 ; 
	date.g = jdt ; 
	if (dateUT) *dateUT = date ;
	return date ;
}

//-----------------------------------------------------------------------------
void ZTime::fromTA75(double tIAT75) 
{
	// Атомное время
	t = tIAT75 ;			// От эпохи 1975 г в ссс
	t0= t-ZMJD1975t02000 ;  // От эпохи 2000 г в ссс
	// Поправка к UTC 
	dUTCIAT = Get_DIAT(t);
	// Всемирное координированное время 
	UTCfromIAT( ) ;
	// Дата и Время московские дикретные с учетом поправки (UTC-IAT)
	TA_DMB(0, &dDMB, &tDMB, &t) ;
	// Юлианская модифицированная дата
	MJDfromDMB( ) ;
	// Вообще должно быть так 
	MJD = tIAT75+ZMJD1975h0 ;
	// Земное динамическое в юлианских днях
	TTfromIAT( ) ;
	// Барицентрическое динамическое время в юлианских днях
	TDBfromTT( ) ;
}

//-----------------------------------------------------------------------------
void ZTime::DMBfromMJD(double mjd, DATE& D, TIME& T)
{
	// Не учитывается поправка между UTC и IAT которая заложена в ДМВ ??????
	double	sp, rd ;
	unsigned long nd, nz, na, nb, ma ;
	rd = (unsigned long)(mjd+0.125)-15078.0 ;
	nd = (unsigned long)rd ;
	nz = (unsigned long)(rd/1461.01) ;
	na = nd-1461*nz ;
	nb = (unsigned long)(na/365.25) ;
	D.g= 4*nz+nb+1900 ;
	if (na==1461) {	D.m=2 ; D.d=29 ; }
	else {
		nz = na-365*nb ;
		ma = (unsigned long)((nz-0.5)/30.6) ;
		D.m= ma+3 ;
		D.d= nz-(unsigned long)(30.6*D.m-91.3) ;
		if ( D.m>12 ) { D.m-=12 ; D.g+= 1 ; }
	}
	sp = 24.0*(mjd+0.125-(unsigned long)(mjd+0.125)) ;
	T.h= (short)sp ;
	sp = 60*(sp-T.h) ; 
	T.m= (short)sp ;
	sp = 60*(sp-T.m) ; 
	T.s= (short)sp ;
	T.d= sp-T.s ;
}

//-----------------------------------------------------------------------------
void ZTime::MJDfromDMB( ) 
{
	// Не учитывается поправка между UTC и IAT которая заложена в ДМВ ??????
	double G, M ;
	G = dDMB.g-1900 ;
	M = dDMB.m-3 ; if ( M<0 ) { M+=12 ; G-=1 ; }
	MJD = 15078.0+365.0*G+(int)(G/4.0)+(int)(0.5+30.6*M)+dDMB.d+tDMB.h/24.0+tDMB.m/1440.0+(tDMB.s+tDMB.d)/86400.0-0.125; 
	MJD-= dUTCIAT/86400.0 ;
}

//-----------------------------------------------------------------------------
void ZTime::UTCfromIAT( ) 
{
	// Поправка предполагается отрицательной (то есть обусловлена 
	// замедлением вращения Земли)
	dUTCIAT = Get_DIAT(t);
	UTC = t+dUTCIAT/86400.0 ;
}

//-----------------------------------------------------------------------------
void ZTime::TTfromIAT( ) 
{
	// tiat75 - cтрого говоря это не точно. Надо бы число ссс прошедшие 
	// с момента начала эпохи J1975
	// dUTCIAT = Get_DIAT(t);
	// TT = MJD-dUTCIAT/86400.0 ;

	// Так называемое земное динамическое время отличается 
	// от атомного только началом отсчета 
	// (т.е. на 32.182 секунды больше последнего)
	TT = t + del_TDT; 
}

//-----------------------------------------------------------------------------
void ZTime::TTfromDMB( ) 
{
	TA_DMB(0, &dDMB, &tDMB, &t) ;
	TTfromIAT() ;
}

//-----------------------------------------------------------------------------
void ZTime::TDBfromTT( ) 
{
	// Интервал времени  вюлианских столетиях от J2000 до текущего момента
	// заданного земным динамическим временем TT
	double d = (TT-51544.5)/36525.0 ;
	// Приближенное значение аргумента перигея орбиты Земли в радианах
	double g = 0.0174453*(357.258+35999.05*d) ;
	TDB = TT+(0.001658*sin(g+0.0167*sin(g)))/86400.0 ;
}

//-----------------------------------------------------------------------------
// Выбор поправки (UTC-IAT) из таблицы
double ZTime::Get_DIAT(double tiat75) 
{
	if ( tiat75<Z_DIAT[0]) {
		Z_DIAT_CurDT = 0 ;
		return 0 ;
	}
	if ( Z_DIAT_CurTime>tiat75 || Z_DIAT_NextTime<=tiat75 ) {
		// Поиск участка, соответствующего заданному моменту времени
		for (int i=0 ; i<Z_Count_DIAT-1 ; i++) {
			if ( Z_DIAT[2*i]<=tiat75 && Z_DIAT[2*(i+1)]>tiat75 ) {
				Z_DIAT_CurTime = Z_DIAT[2*i] ;
				Z_DIAT_NextTime= Z_DIAT[2*(i+1)] ;
				Z_DIAT_CurDT   = Z_DIAT[2*i+1] ;
				break ;
	}	}	}
	// Возврат текущей поправки
	return Z_DIAT_CurDT ;
}

//-----------------------------------------------------------------------------