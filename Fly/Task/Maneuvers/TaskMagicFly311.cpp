//-------------------------------------------------------------------------------
// TaskMagicFly311.cpp : 
// А. Николенко 08.10.2018
//
// Пример программы расчёта параметров ТрехИмпульсного орбитального манёвра
// на околокруговой орбите в условиях достаточно близких к импульсному перелёту.
// Речь идет не сколько о "почти импульсном манёвре", что само по себе 
// не представляет интереса, сколько о манёвре НЕ с малой тягой.
//
// В основе алгоритма лежит так называемый "метод узловых точек" что приводит
// к методике расчёта L-манёвра, алтернативой которому может служить 
// так называемый B-манёвр. По сути своей это одно и тоже, но дьявол кроется 
// в деталях. А именно, B-манёвр расчитывается на основе положений вариационного 
// исчисления, линеаризации модели движения и модели управления движением 
// центром масс КА. В результате получается алгоритм обладающий более регулярной
// сходимостью чем алгоритм основанный на методе узловых точек.
// Кроме того, B-манёвр в некоторых случаях (как я понимаю сейчас в случае 
// трехимпульсного перелёта) позволяет получить траектории значительно 
// отличающиеся от L-манёвра. Подтверждение данному факту можно найти в 
// публикациях и выступлениях на конференциях авторов этих методов... 
//
// На основании сказанного собственно и можно позволить себе разделять эти два
// очень похожих манёвра на две различные сущьности - L-манёвр и B-манёвр.
//
// Итак, пример расчёта L-манёвра (точнее говоря LNS-маневра)...
// 
// 311-й вариант LNS-маневра
// T,u,h,Bh или T,u,e,w для ОМИВ, ДУ, ЭО
//-------------------------------------------------------------------------------
#include "stdafx.h"

//---------------------------------------------------------------------------
// Компоненты Fly
#include <FlyMMath.h>		// Математические функции
#include <FlyMagicLNS.h>	// Метод узловых точек

//---------------------------------------------------------------------------
#include <FlyMagicLNSSource/MagicSolution.h>

int TaskMagicFlyBegin(ZSMagicLnsSolution* MS, int task, ZMSC& KA,
	ZNU& NU, ZLSF& LSF, bool ResetNU, ZCPrintManager* PrintMng,
	FILE** pfp);

//-------------------------------------------------------------------------------
int TaskMagicFly311(int TypeOrb)
{
	// идентификатор задачи (иными словами номер варианта маневрирования)
	int indexTask = 311;
	int rc = 0;

	//---------------------------------------------------------------------------
	// Создаём "Модель решения"
	// По сути своей модель решения это контейнер, который содержит: 
	//		- характеристики двигутельной установки, 
	//		- массив параметров задачи (опции),
	//		- задание на решение задачи (массив информации, обычно задаваемый 
	//		  оператором в интерактивном режиме).
	// ... Таким образом эту самую модель перед решением нужно создать.
	//---------------------------------------------------------------------------
	ZSMagicLnsSolution* MS = CreateMagicLnsSolution(); if (!MS) return 1;

	//---------------------------------------------------------------------------
	// TypeOrb - Тип требуемой орбиты
	//		SPO_ORB_EL	- геометрия требуемой орбиты задаётся как e, w.
	//		SPO_ORB_HBH	- геометрия требуемой орбиты задаётся как Hmin, Bhmin.
	//		SPO_ORB_OMIV- параметры требуемой орбиты обеспечивают минимальное.
	//					  изменение высоты на витке (e, w выбираются исходя из 
	//					  условия ОМИВ).
	//		SPO_ORB_DU	- параметры требуемой орбиты обеспечивают динамическую
	//					  устойчивость (e, w выбираются исходя из условия ДУ).
	//---------------------------------------------------------------------------
	MS->MZ.ORB() = TypeOrb;

	//--------------------------------------------------------------------------
	// Инициализация НУ, ЛШС и модели движения, настройка документирования
	//--------------------------------------------------------------------------
	ZNU   NU;			// НУ движения КА.
	ZLSF  LSF;			// Логическая шкала сил в которой выполняется решение. 
	ZMSC  KA;			// Модель движения (или просто КА)
	FILE* fp = nullptr;	// Файл для документирования результатов решения
	// Диспетчер документирования
	// Несмотря на то что диспетчер документирования ZCPrintManager был разработан
	// для документирования результатов прогноза, он находит своё применение и
	// в прикладных задачах, в части касающейся создания документа, вывода 
	// заголовка документа, документирования НУ и ЛШС, документирования 
	// информации о времени расчёта и его длителоьности, форматированного 
	// документирования данных в заданный контекст (просто говоря в звдвнный 
	// файл). 
	// В итоге диспетчер документирования нам нужен!
	ZCPrintManager PrintMng;

	// Инициализация основных данных необходимых для решения тестовых задач
	// расчёта параметров орбитального маневрирования - задание на расчёт
	// "фиксированная" часть. 
	// Данный метод общий для
	// всех тестовых процедур именованных как TaskMagicFly__.
	// В "Prodaction" необходимость в данном методе отпадает. Вся его 
	// функциональная нагрузка ложится на GUI 
	// и/или на средства автоматизации АПК.
	rc = TaskMagicFlyBegin(MS, indexTask, KA, NU, LSF, true, &PrintMng, &fp); 
	if (rc) goto end;

	//--------------------------------------------------------------------------
	// Формирование задания на расёт, "опреративная" часть (формируется в 
	// интерактивном режиме с использованием GUI)
	MS->MZ.VITIMP(0) = 2;	// Виток первого импульса
	MS->MZ.VITIMP(1) = 8;	// Виток второго импульса
	MS->MZ.VITIMP(2) = 9;	// Виток третьего импульса
	MS->MZ.VIT()     = 12;	// Заданный виток на котором контролируются 

	// краевые условия
	// Требуемые параметры орбиты
	MS->MZ.PARL() = 298.0;	// Долгота ВУ
	MS->MZ.PART() = 5327.0;	// Драконический период
	MS->MZ.PARh() = 207.0;	// Минимальная высота
	MS->MZ.PARBh()= 16.5;	// Широта минимальной в
	MS->MZ.PARBv()= 0;		// Широта мин. высоты на восх. ветви
	MS->MZ.PARe() = 0.0002;	//	
	MS->MZ.PARw() = 20.0;	//	
	MS->MZ.PARu() = 118.0;	// Требуемый аргумент широты
	// Время на которое необходимо сформировать требуемый аргумент широты.
	MS->MZ.PARt() << DATETIMEDMB(15, 12, 2015, 4, 45, 0, 0);

	// Взводим флаг уточнения формы орбиты для того чтобы
	// На итерациях изменять прицельные значения минимальной высоты и её широты
	MS->MP.isEstimateOrb = true;

	//--------------------------------------------------------------------------
	// Решение задачи расчёта параметров коррекции по заданию MZ 
	{
		ZSLoopFact		// Параметры движения: 
					P1,	//  - на виток первого имп 
					P2,	//  - на виток второго имп 
					PN,	//  - начальные на заданный виток
					PR;	//  - расчётные конечные на заданный виток 
		ZSFlightRule U; // Прогрмамма управления

		// Процедура итерационного решения формализованной задачи расчёта методом
		// узловых точек. Данная процедура является единой для всех тестовых задач
		// именованных как TaskMagicFly__. 
		rc = MagicSolution(MS, &PrintMng, fp, LSF, KA, NU, nullptr, 
						   &P1, &P2, &PN, &PR, &U);
		// Закрытие документа с результатами решения
		PrintMng.ClosePrint(&fp);
	}
end:;
	//---------------------------------------------------------------------------
	// В завершении удаляем созданную ранее "Модель решения"
	FreeMagicLnsSolution(MS);
	return rc;
}

//-------------------------------------------------------------------------------