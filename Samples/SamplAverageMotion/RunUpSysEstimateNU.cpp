//-----------------------------------------------------------------------------
// RunUpSysEstimateNU.cpp: 
// А. Николенко 10.08.2018
//-----------------------------------------------------------------------------
#include "stdafx.h"

//-----------------------------------------------------------------------------
// Компоненты Fly
#include <FlyCore.h>		// Собственоно сама модель движения
#include <FlyMMath.h>		// Математические функции

//-----------------------------------------------------------------------------
// Правые части внешних дифференциальных уравнений.
// Реалзация перегруженого метода вычисления правых частей внешних
// дифференциальных уравнений.
ZMSC_EXV_BEG(ZModExternEstNU)
	// Переменные:
	//		t	 - Время, атомное
	//		Xmain- Координаты в СК интегрирования СДУ
	// Вычисление координат в Гринвиче
	double GSK[6] ;
	int rc = ZASC1975toGSC(t, Xmain, GSK, 0); if (rc) return rc;
	// Высота широта и долгота...
	double HBL[3] ;
	ZGRtoHBL(GSK, HBL, 0, 0) ;
	// Высота над ОЗЭ выраженная в км.
	Yexe[0] = 1e4*HBL[0] ;
	// В данном случае интегрируется одна переменная Y, ДУ для которой 
	// имеет вид следующий вид.
	// dY
	// --- = H,  Н - это высота полёта над ОЗЭ.
	// dt
ZMSC_END

//-----------------------------------------------------------------------------
// Процедура корректировки НУ NU0 с целью получения из них в поле сил LSF
// НУ орбиты с заданной геометрией (az (или havrz), e1z, e2z) в точке 
// с аргументом широты uz и с заданной средней высотой на витке.
// Результат - начальные условия NUK.
int RunUpSysEstimateNU(
	ZLSF&  LSF,		// Поле сил
	ZNU&   NU0,		// Исходные НУ
	ZNU&   NUK,		// Полученные НУ (результат)
	double uz,		// Аргумент широты на который задаётся геометрия орбиты
	double e1z,		// Геометрия орбиты
	double e2z,
	double az,		// Большая полуось (имеет смысл если не задано havrz)
	double havrz)	// Требуемая средняя высота орбиты
{
	int    count = 0 ;
	int    rc ;
	int    Vit ;
	double da = 0, de1 = 0, de2 = 0; 		
	double at, e1t, e2t ; 
	double epsa = 1e-7 ;	// точность сходимости по высоте в дткм
	double epse = 1e-8 ;	// точность сходимости по эксцентриситету

	ZNU NU = NU0 ;			// Уточняемые НУ
	ZModExternEstNU* KA;	// Модель движения КА

	//-------------------------------------------------------------------------
	// Модель движения КА достаточно большой объект. Поэтому при размещении  
	// его в стеке размер потребного стека необходимого для работы любой 
	// процедуры, использующей объект типа ZMSC (ZModExternEstNU) превышает
	// приемлемые значения ... Поэтому наиболее целесообразным решением
	// является выделение памяти под объект модели движения в куче посредством
	// оператора new ...
	try{
		KA = new ZModExternEstNU();
		if (!KA) return 1;
	}
	catch (...) {
		// Ошибка при создании модели движения
		return 1;
	}

	//-------------------------------------------------------------------------
	Vit = NU0.vit ;			// Виток на котором происходит уточнение НУ
	az /= 1e4 ;				// Пересчёт заданного значения полуоси в ДТКМ

	// Указываем модели движения что СДУ будет содержать одно внешнее уравнение
	// Метод расчёта ПЧ внешних уравнений реализован в классе ZModExternEstNU
	KA->SetExternalEquationsCount(1);
	// Инициализация МД
	try{
		rc = KA->Init(NU, &LSF); 
		if (rc) { 
			delete KA; 
			return 2; 
		}
	} catch (...) {
		// Ошибка при инициализации модели движения
		if (rc) {
			delete KA;
			return 3;
	}	}

	ZSC_SI SI ;
	while(1) {
		// Прогнозирование движения КА до момента начала витка Vit
		rc = KA->GoToVit(Vit, &SI); if (rc) return 4;
		// Оскулирующие параметры на начало витка:
		// большая полуось и вектор эксцентриситета
		at  = SI.OSKTE[0] ;
		e1t = SI.OSKTE[1]*cos(SI.OSKTE[4]) ;
		e2t = SI.OSKTE[1]*sin(SI.OSKTE[4]) ;
		// отклоенния параметров от требуемых значений
		if (az > 0) da = at-az ;
		de1 = e1t-e1z ;
		de2 = e2t-e2z ;

		// Моделирование витка и интегрирование высоты вдоль витка

		if (havrz > 0) {
			// Включаем внешие уравнений. 
			// Одновременно формируются нулевые НУ по внешнему уравнению 
			KA->ExternalEquationsOn();
			double Xexe = 0.0 ;
			KA->SetVectorExe(&Xexe);
		}
		// Моделирование одного витка Vit
		rc = KA->GoAlongVit(Vit); if (rc) return 4;
		if (havrz > 0) {
			// Выключение внешнего уравнения. Одновременно возвращается значение
			// внешней переменной dHAvr в момент завершения моделирования, т.е. 
			// на конец витка dHAvr по смыслу ПЧ реализованной в 
			// ZModExternEstNU::ExternalSph есть численное значение 
			// определённого интеграла по времени от начала витка до конца 
			// витка, где подинтегральной функции является зависимость от 
			// времени высоты КА над ОЗЭ. 
			//
			//         t= вр.кон.вит.   
			//         / 
			// dHAvr = | h(t)*dt
			//         /
			//         t= вр.нач.вит
			//
			double dHAvr = 0 ;
			KA->ExternalEquationsOff(&dHAvr);

			// Оценка средней высоты на витке
			// Расчётные параметры витка 
			// !!!! Переделать в FSUN.ExternalEq[0] находится не верное 
			// не нулевое значение MKA_VI* VI = &KA.FV ;
			// dHAvr =(VI->FSTE.ExternalEq[0]-VI->FSUN.ExternalEq[0]) ;
			// Делим на драконический период получаем осреднённую на витке 
			// среднюю высоту КА над ОЗЭ
			dHAvr /= (KA->FV.Td / k_cbc);
			// dHAvr = KA.FV.HAvr ;
			// Вычитаем требуемое значение и получаем невязку, 
			// требующую устранения
			dHAvr-= havrz ;
			// Для Коррекции среднеё высоты изменяем большую полуось в НУ
			da = dHAvr/1e4 ;
		}

		// Вносим полученные поправки в НУ
		
		// Поправки к геометрии орбиты
		// Текущий вектор эксцентриситета
		double e10 = NU.X[1]*cos(NU.X[4]) ;
		double e20 = NU.X[1]*sin(NU.X[4]) ;
		// Вносим расчитанные ранее поправки в вектор эксцентриситета 
		// и в значение большой полуоси
		e10-= de1 ; 
		e20-= de2 ; 
		// В соответствии с уточнёнными значениями компонент вектора 
		// эксцентриситета вычисляем эксцентриситет и аргумент 
		// перигея уточняемых НУ
		NU.X[1] = sqrt(e10*e10 + e20*e20) ;
		NU.X[4] = Atan2(e20, e10, 0) ;	
		// Вносим поправку в значение большой полуоси
		NU.X[0]-= da ;

		// Проверка сходимости
		if (fabs(da)<epsa) {
			if (fabs(de1)<epse) {
				if (fabs(de2)<epse) break ;
		}	}	

		count++ ;
		// Проверка числа итераций (зацыкливания)
		if (count>50) return-1 ;

		// Задаём новые начальные условия движения КА
		KA->SetVector(NU.X, NU.vit, NU.t, KA->WeightFullNU(), NU.sk);
	}

	// Собственно полученные уточнённые НУ со среднеё высотой 
	// вдоль ближайшего витка равной заданному значению
	NUK = NU ;

	// Удаление созданного ранее в куче объекта модели движения
	delete KA;

	return 0 ;
}

//-----------------------------------------------------------------------------