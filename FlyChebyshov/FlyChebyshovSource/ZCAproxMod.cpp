//-------------------------------------------------------------------------------
// ZCAproxMod.cpp : 
// Контейнер модели апроксимации полиномом таблично заданной функции
// А. Николенко 15.03.2019
//-------------------------------------------------------------------------------
#include "stdafx.h"
#include <FlyChebyshovSource\\ZCAproxMod.h>
#include <FlyChebyshovSource\\ZFChebyshov.h>

ZCAproxMod::ZCAproxMod()
{
	A = NULL;
	ArgArea[0] = ArgArea[0] = 0 ;
	Degree = 0;
}

ZCAproxMod::~ZCAproxMod()
{
	Clear();
}

//-------------------------------------------------------------------------------
// Удвление данных модели
void ZCAproxMod::Clear()
{
	if (A) delete[] A; 
	ArgArea[0] = ArgArea[0] = 0;
	Degree = 0;
}

//-------------------------------------------------------------------------------
// Вычисление значения функции при помощи перегруженного оператора ()
double ZCAproxMod::operator() (double t)
{
	return Calc(t);
}

//-------------------------------------------------------------------------------
// Вычисление значения модели, t- время на которое вычисляется 
// значение модели (полинома)
double ZCAproxMod::Calc(double t)
{
	if (!A || Degree <= 0) {
		assert(0);
	}
	double Value = A[Degree];
	for (int j = Degree; j>0; j--) Value = Value*t + A[j-1];
	return Value;
}

//-------------------------------------------------------------------------------
// Создание полинома по значениям дискретной функции
//		Y   - Массив значений дискретной функции 
//		t   - Массив значений аргумента дискретной функции 
//		N   - Колличество точек дисретной функции 
//		M   - Степень апроксимирующего полинома
//		Mod - Модель (по умолчанию - по Чебышёву)
int ZCAproxMod::Build(double* Y, double* t, int N, int M, APROX_MOD_TYPE Mod)
{
	// Если затребована слишком большая степень полинома, 
	// то создать его не получится. Возврат кода ошибки
	// (-1) - отказ в исполнении всвязи с недостаточночтью или 
	// некорректностью исходных данных...
	if (Degree >= _MAX_STEP_APPROKS_POL) return-1;

	// Проверка корректности исходных данных
	if (!Y || !t || N < 2 || M < 1) return-2;

	// Если полином уже существовал, то проверяем его степень Degree.
	// Возможно размера массива A будет достаточно для формирования
	// массива коэффициентов нового полинома
	if (Degree < M) {
		// Удаление старого массива
		if (A) delete[] A;
		// Выделение нового массива
		A = new double[M + 1];
	}
	// Построение апроксимации по Чебышову и преобразование полученного
	// выражения в алгебраический полином степени Degree
	// Y(t) = A0 + A1*t + A2*t*t + A3*t*t*t + ... + A[Degree]*t*t*...*t.  
	AproxByChebyshevPolinom(t, Y, N, M, A);
	// Сохранение области определения полинома (диапазона на аргумента 
	// котором он постороен) и степени полинома в соответствующих полях класса 
	ArgArea[0] = t[0];
	ArgArea[1] = t[N-1];
	Degree = M ;
	AprType = APRMOD_CHEBYSHEV;

	return 0;
}
