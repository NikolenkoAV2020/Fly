//---------------------------------------------------------------------------
// ZPR.cpp
// А. Николенко 03.08.2018
//---------------------------------------------------------------------------
#include <stdafx.h>
#pragma   hdrstop
#include <FlyMMath.h>
#include <FlyTime.h>

#include <FlyCoreSource\\ModType.h>
#include <FlyCoreSource\\ModGlobal.h>
#include <FlyCoreSource\\ModAstro.h>
#include <FlyCoreSource\\ZPR.h>
#include <FlyCoreSource\\ZCalc.h>

//----------------------------------------------------------------------------
// ПРЕЦЕССИЯ
//----------------------------------------------------------------------------
double Global_m2000_75[9] = {
	 0.999981423814942,   0.00559013887986178,  0.00242947985080896,
	-0.00559013888057073, 0.999984375028524,   -6.79033614644759e-06,
	-0.00242947984917768,-6.79091976566359e-06, 0.999997048786418 } ;

static double	inquiry_eps_t = 1e-3/k_cbc ;	// 1-а тысячная доля секундв	
static double	last_inquiry_tJ2000 =-999999.0 ;// Последнее время на которое запрашвалась матрица прецессии
static double	last_inquiry_PrecessMatr[10] = {	// Последняя расчитанная матрица прецессии
				0, 0, 0, 0, 0, 0, 0, 0, 0, 0} ;

//----------------------------------------------------------------------------
int ZBuildMatrPrecessJ2000(double t, double* M, TIMESCALE Scale, MODEL_PRCJ2000 ModPrc)
{ 
	double ta ;	t = Astro2000Time(t, Scale, &ta) ;

	// Проверка необходимости расчета 
	if (fabs(last_inquiry_tJ2000-ta)<=inquiry_eps_t &&
		(MODEL_PRCJ2000)(int)last_inquiry_PrecessMatr[9]==ModPrc) {
		// Если при предыдущем вызове данной функции матрица уже была 
		// расчитана на момент времени достаточно близкий к ta, то повторный 
		// расчет не выполняется, а просто копируется расчитанная ранее 
		// матрица.
		// Матрица last_inquiry_PrecessMatr запоминается после 
		// каждого нового расчёта.
		memcpy(M, last_inquiry_PrecessMatr, 9*sizeof(double));
		return 0 ;
	}

	// Параметры прецессии по времени от эпохи 1975 года 
	double Pr[3] ;
	ZPrecessJ2000(t, Pr, TIMEJ2000JC, ModPrc) ;

	// Матрица прецесси по вычисленным параметрам
	ZMatrPrecess(Pr, M) ;	

	// Сохранение результатов вычислений
	last_inquiry_tJ2000 = ta ; 
	memcpy(last_inquiry_PrecessMatr, M, 9*sizeof(double));	
	last_inquiry_PrecessMatr[9] = ModPrc ;

	return 0 ;
}

//----------------------------------------------------------------------------
// Расчет параметров прецессии за время tau от эпохи J2000 (12h 01.01.2000)
// Рекомендации MAC 1996 года
// Полиномы приводятся в  "РД 50-25645.325-89"
//		t - время в шкале Scale
// Результат в угловых секундах
//		Pr[0] - Кси
//		Pr[0] - Z
//		Pr[0] - тета
// flag:
//	0 - tau задано в ссс от J2000 (0h 01.01.2000)
//	1 - tau задано в ссс от J1975 (0h 01.01.1975)
//	2 - tau задано в юлианских столетиях от J2000 (12h 01.01.2000)
//
// Прецессионные параметры такого вида применимы ТОЛЬКО!!!! 
// при преобразовании от фундаментальной эпохи J 2000,0 к эпохе t и наоборот
//----------------------------------------------------------------------------
int ZPrecessJ2000(double t, double *Pr, TIMESCALE Scale, MODEL_PRCJ2000 ModPrc)
{
	switch(ModPrc){
		case PRC1976:
		case PRCIAU1976:	ZPrecessJ2000LikeIAU1976(t, Pr, Scale) ; break ;
		case PRC2000:		ZPrecessJ2000LikeIAU2000(t, Pr, Scale) ; break ;
		case PRC2003:		ZPrecessJ2000LikeIAU2003(t, Pr, Scale) ; break ;
		default: assert(0) ;
	}
	return 0 ;
}

//----------------------------------------------------------------------------
// Расчет параметров прецессии от времени t1 до времени t2 
// (в угловых секундах). IAU 1976 precession model.
//----------------------------------------------------------------------------
void Preces1976t1t2(double t1, double t2, double *Precess, TIMESCALE Scale)
{
	assert(0) ;

	// Время начала и время конца интервала за который рассчитываются
	// параметры прецесси а юлианских столетиях от астрономической
	// эпохи J2000
  	t1 = Astro2000Time(t1, Scale, nullptr) ;
  	t2 = Astro2000Time(t2, Scale, nullptr) ;
	// Длительность интервала в юлианских столктиях
	double dt = t2-t1 ;

	static double K[15] = {
		+2306.2181, //  0 - Линейные члены Кси_А, Зет_А
		+1.39656,   //  1 -
		-0.139e-3,  //  2 -
		+0.30188,   //  3 - Квадрат. члены Кси_А
		-0.344e-3,  //  4 -
		+0.017998,  //  5 - Кубичес. член  Кси_А
		+1.09468,   //  6 - Квадрат. члены Зет_А
		+0.66e-4,   //  7 -
		+0.018203,  //  8 - Кубичес. член  Зет_А
		+2004.3109, //  9 - Линейные члены Тет_А
		-0.8533,    // 10 -
		-0.217e-3,  // 11 -
		-0.42665,   // 12 - Квадрат. члены Тет_А
		-0.217e-3,  // 13 -
		-0.041833   // 14 - Кубичес. член  Тет_А
	};
	// угловых секунд в радиане
	double ASTR = 180.0/k_pi*3600.0 ;
	// Расчет параметров прецессии
	double dTemp1 = K[0]+(K[1 ]+K[ 2]*t1)*t1;
	double dTemp2 = K[9]+(K[10]+K[11]*t1)*t1;
	Precess[0]  =(dTemp1 + ((K[ 3]+K[ 4]*t1)+K[ 5]*dt)*dt)*dt*ASTR ; 
	Precess[1]  =(dTemp1 + ((K[ 6]+K[ 7]*t1)+K[ 8]*dt)*dt)*dt*ASTR ;  
	Precess[2]	=(dTemp2 + ((K[12]+K[13]*t1)+K[14]*dt)*dt)*dt*ASTR ;
}

//----------------------------------------------------------------------------
// Расчет параметров прецессии на время t в соответствии с
// рекомендациями IAU 1976 года
//		t - время в шкаде Scale
//		Pr- рассчитываемые параметры прецессии в угловых секундах
//----------------------------------------------------------------------------
int ZPrecessJ2000LikeIAU1976(double t, double *Pr, TIMESCALE Scale)
{
	// В РД говорится что время должно быть барицентрическим динамическим
	// а тут земное динамическое - ?????
	t = Astro2000Time(t, Scale, nullptr) ;

	static double K[3][3] = { 
	{ 2306.2181, 0.30188,  0.017998 },
	{ 2306.2181, 1.09468,  0.018203 },
	{ 2004.3109,-0.42665, -0.041833 } } ;

	for (int i=0; i<3; i++) {
		Pr[i] =(K[i][0]+
		   	   (K[i][1]+
			    K[i][2]*t)*t)*t ;
	}

	return 0 ;
}

//----------------------------------------------------------------------------
// Расчет параметров прецессии на время t в соответствии с
// Resolution of the IAU 2000A (IAU 2000A model)
// Convention IERS 2000
//		t - время в шкаде Scale
//		Pr- рассчитываемые параметры прецессии в угловых секундах
//----------------------------------------------------------------------------
int ZPrecessJ2000LikeIAU2000(double t, double *Pr, TIMESCALE Scale)
{
	t = Astro2000Time(t, Scale, nullptr) ;

	static double K[18] = {
		 2.5976176,    //  0 - Кси_А: подставка
		 2306.0809506, //  1 -        линейная составляющая
		 0.3019015,    //  2 -        **2
		 0.0179663,    //  3 -        **3
		-3.27e-5,      //  4 -        **4
		-2.0e-7,       //  5 -        **5
		-2.5976176,    //  6 - Зет_А: подставка
		 2306.0803226, //  7 -        линейная составляющая
		 1.0947790,    //  8 -        **2
		 0.0182273,    //  9 -        **3
		 4.7e-5,       // 10 -        **4
		-3.0e-7,       // 11 -        **5
		 0.0,          // 12 - Тет_А: подставка
		 2004.1917476, // 13 -        линейная составляющая
		-0.4269353,    // 14 -        **2
		-0.0418251,    // 15 -        **3
		-6.01e-5,      // 16 -        **4
		-1.0e-7,       // 17 -        **5
	};
	for( int i=0; i<3; i++ ) {
		Pr[i] = K[i*6]+
			   (K[i*6+1]+
			   (K[i*6+2]+
			   (K[i*6+3]+
			   (K[i*6+4]+
			    K[i*6+5]*t)*t)*t)*t)*t ;
	}
	return 0 ;
}

//----------------------------------------------------------------------------
// Расчет параметров прецессии на время t в соответствии с
// IERS Convention 2003
//		t - время в шкаде Scale
//		Pr- рассчитываемые параметры прецессии в угловых секундах
//----------------------------------------------------------------------------
int ZPrecessJ2000LikeIAU2003(double t, double *Pr, TIMESCALE Scale)
{
	t = Astro2000Time(t, Scale, nullptr) ;

	static double K[18] = {
		 2.650545,     //  0 - Кси_А: подставка
		 2306.083227,  //  1 -        линейная составляющая
		 0.2988499,    //  2 -        **2
		 0.01801828,   //  3 -        **3
		-5.791e-6,     //  4 -        **4
		-3.173e-7,     //  5 -        **5
		-2.650545,     //  6 - Зет_А: подставка
		 2306.077181,  //  7 -        линейная составляющая
		 1.0927348,    //  8 -        **2
		 0.01826837,   //  9 -        **3
		-2.8596e-5,    // 10 -        **4
		-2.904e-7,     // 11 -        **5
		 0.0,          // 12 - Тет_А: подставка
		 2004.191903,  // 13 -        линейная составляющая
		-0.4294934,    // 14 -        **2
		-0.04182264,   // 15 -        **3
		-7.089e-6,     // 16 -        **4
		-1.274e-7,     // 17 -        **5
	};
	for( int i=0; i<3; i++ ) {
		Pr[i] = K[i*6]+
			   (K[i*6+1]+
			   (K[i*6+2]+
			   (K[i*6+3]+
			   (K[i*6+4]+
			    K[i*6+5]*t)*t)*t)*t)*t ;
	}
	return 0 ;
}

//----------------------------------------------------------------------------
// Вычисление матрицы прецессии M
// Precess - прецессионные параметры вычисленные ранее	
void ZMatrPrecess( double* Precess, double* M)
{
	// Перевод параметров прецесси в радианы
	double P[3] ; 
	for (int i=0; i<3; i++) P[i] = Precess[i]/M_SEKRAD ;

	double S_Pr0, C_Pr0, S_Pr1, C_Pr1, S_Pr2, C_Pr2;
	double C_Pr1_C_Pr2, S_Pr1_C_Pr2;

	S_Pr0 = sin(P[0]);  C_Pr0 = cos(P[0]) ;
	S_Pr1 = sin(P[1]);  C_Pr1 = cos(P[1]) ;
	S_Pr2 = sin(P[2]);  C_Pr2 = cos(P[2]) ;
	C_Pr1_C_Pr2 = C_Pr1*C_Pr2 ;
	S_Pr1_C_Pr2 = S_Pr1*C_Pr2 ;

	// Матрица
	M[0] = C_Pr1_C_Pr2*C_Pr0-S_Pr1*S_Pr0 ;
	M[1] =-C_Pr1_C_Pr2*S_Pr0-S_Pr1*C_Pr0 ;
	M[2] =-C_Pr1*S_Pr2 ;
	M[3] = S_Pr1_C_Pr2*C_Pr0+C_Pr1*S_Pr0 ;
	M[4] =-S_Pr1_C_Pr2*S_Pr0+C_Pr1*C_Pr0 ;
	M[5] =-S_Pr1*S_Pr2 ;
	M[6] = S_Pr2*C_Pr0 ;
	M[7] =-S_Pr2*S_Pr0 ;
	M[8] = C_Pr2 ;
}

//----------------------------------------------------------------------------



