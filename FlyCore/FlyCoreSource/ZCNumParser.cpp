//---------------------------------------------------------------------------
// ZCNumParser.cpp
// А. Николенко 01.02.2019
// 
// ZNumericParser
// Описание класса разбора текстовых файлов содержащих Унифицированные
// Формы Обмена (УОФ). Из самого определения УОФ следует что, данные файлы
// представляют собой короткие текстовые файла, содержащие в основном
// цифровую информацию.
// Суть разбора состояит в декомпозиции исходного текста с
// целью выделения подстрок, содержащих только текст, и подстрок, содержащих
// только числовую информацию в виде целого числа. "Числовая" строка может 
// являться частью числа с плавающей или фиксированной точкой.
//
// После разбиения одним из возможных способов (Execute, ProcessString или <<) 
// всего текста на строки и подстроки можно выполнить операцию 
// поиска целых и дробных чисел, а также строковых переменных функциями:
// FindInt, FindDbl, FindStr.
// 
// Класс позволяет организовать программную расшифровку текстового файла
// максимально независимую от используемых в форме разделителей, в том числе 
// и десятичных, пробелов и так далее. Главное чтоб вся информация лежала 
// в нужной последовательности. 
// Например после координаты X следовала координата Y, а далее координата Z
// и так далее...
//
// На первый взгляд может показаться что алгоритм данного разбора бесполезен
// и является лишним компонентом при интерапритации информации обменных 
// текстовых форм. Но! Пропуская исходный тестовый файл через сито "парсера"
// можно сделать процесс интерпритации текстовой информации более устойчивым
// к возможным незначительным вариациям форматов данных и мелких ошибок...
// Например: следующие строки должны интерпритироваться одинаково
//			2,+3.1415926e3,16-11-1973
//			2,     +3.1415926e+3, 16.11.1973
//			2   3.1415926+3, 16 11 1973
// 
//---------------------------------------------------------------------------
#include <stdafx.h>
#pragma   hdrstop
#include <FlyCoreSource\\ModType.h>
#include <FlyCoreSource\\ZCNumParser.h>

//---------------------------------------------------------------------------
// !!!! Очень Важно !!!!
// 
// ZNumericParser использует шаблоны бмблиотеки STL, а любые операции с ними
// не являются потоко-безопасными, поэтому часть кода где происходит разбор 
// исходного текста на подстроки необходими ограничивать Mutex-ом
// Проще всего ограничить доступ к части программного кода, вызывающего
// методы класса ZNumParser, например тело процедуры LoadNU01 и так далее
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
ZNumericParser::ZNumericParser() 
{
	DecSeparators.push_back('.') ;
	DecSeparators.push_back(',') ;
	StringSeparators.push_back(';') ;
	StringSeparators.push_back(':') ;
	StringSeparators.push_back('/') ;
	StringSeparators.push_back('\\') ;
	CountItem = 0 ;
	CountString = 0 ;
}

ZNumericParser::~ZNumericParser() 
{
	StringSeparators.clear();
	DecSeparators.clear();
	KeyString.clear() ;
	VPI.clear() ;
}

//---------------------------------------------------------------------------
void operator << (VParserItem& VPI, char* S) 
{
	ZNumericParser Parser ;
	Parser.ProcessString(S, VPI) ;
}

//---------------------------------------------------------------------------
void ZNumericParser::operator << (char* S) 
{
	ProcessString(S, VPI) ;
}

//---------------------------------------------------------------------------
// Разбор строки на составляющие её подстроки, целые числа и разделители
int ZNumericParser::ProcessString(char* S, VParserItem& VPI) 
{
	VPI.clear() ;
	ZParserItem PI ;
	while (*S!='\0') {
		int l ;
		// Попытка выделения текстовой подстроки
		if (l = GetText(S, PI)) { 
			VPI.push_back(PI) ; 
			S+= l ; 
		}
		// Попытка выделения подстроки, содержащей целое число
		if (l = GetNum (S, PI)) { 
			VPI.push_back(PI) ; 
			S+= l ; 
		}	
	}

	return 0 ;
}

//---------------------------------------------------------------------------
// Проверка символа - цыфра или нет 
bool ZNumericParser::IsDigit(char c) 
{
	if (c=='0' || c=='1' || c=='2' || c=='3' || c=='4' || 
		c=='5' || c=='6' || c=='7' || c=='8' || c=='9') {
		return true ;
	} 
	return false ;
}

//---------------------------------------------------------------------------
// Проверки на наличие в тексте разделителя
int ZNumericParser::IsSep(char c)  
{
	int r ;
	// Проверка на десятичный разделитель
	r = IsDecSep(c) ; if (r) return r ;
	// Проверка на разделитель строк
	r = IsStrSep(c) ; if (r) return r ;
	return 0 ;
}
int ZNumericParser::IsDecSep(char c)  
{
	int i, n=DecSeparators.size() ;
	for (i=0; i<n; i++) { if (c==DecSeparators[i]) return(21+i) ; }
	return 0 ;
}
int ZNumericParser::IsStrSep(char c)  
{
	int i, n=StringSeparators.size() ;
	for (i=0; i<n; i++) { if (c==StringSeparators[i]) return(31+i) ; }
	return 0 ;
}

//---------------------------------------------------------------------------
int ZNumericParser::GetNum (char* S, ZParserItem& PI) 
{
	int i=0, j=0 ;
	// Начальное значение элемента разбора - пустая строка
	PI.type = 0 ;
	PI.sep = 0 ;
	PI.s = "" ;
	// Проверка первого символа. Если задан знак то он должен 
	// учитываться вместе с числом
	if ((*S=='-' || *S=='+') && IsDigit(*(S+1))) {
		// Сохраняется обнаруженный знак в буфере подстроки и 
		// в элементе разбора	
		SS[0] = *S ;
		SS[1] = '\0' ;
		PI.s  = SS ;
		// Смещение в исходной строке
		//i++;
		j++;
		S++; 
	}
	// Цыкл разбора
	while(1) {
		// Очередной символ исходной строки
		char c = *S ;
		// Если это цифра то записываем её в буфер
		// иначе завершаем цыкл
		if (IsDigit(c)) SS[j] = c ;
		else {
			// Проверка завершениея разделителем
			PI.sep = IsSep(c) ;
			if (PI.sep) i++ ;
			break ;
		}
		// Смещение в исхдной строке и увеличение счётчика
		// найденный символов
		j++ ; 
		S++ ;
	}
	// Закрываем буфер подстроки нулевым символом и сохраняем 
	// найденную подстроку в элементе разбора
	if (j) {
		SS[j] = '\0' ;
		PI.s  = SS ;
	}
	// Признак подстроки - целое число, если конечно не пустая строка
	PI.type = j ? 2:0 ;
	// Возвращаем смещение в исходной строке
	return (j+i) ;
}

//---------------------------------------------------------------------------
int ZNumericParser::GetText(char* S, ZParserItem& PI) 
{
	int   r, i=0, j=0 ;
	char* S0=S ;
	// Начальное значение элемента разбора - пустая строка
	PI.type = 0 ;
	PI.sep = 0 ;
	PI.s = "" ;
	// Цыкл разбора
	while(1) {
		// Пернвый символ подстроки
		char c = *S ;
		// Проверка разделителя
		r = IsSep(c) ;
		if (r) {
			c = '\0' ;
			i++ ; 
			PI.sep = r ;
			break ;
		} 
		if (IsDigit(c)) {
			// Если наткнулись на цыфру то подстроку завершаем
			if (S==S0) {
				// Если с самого начала строки обнаружена цифра,
				// завершаем подстроку безусловно
				break ;
			} else {
				r = IsSep(*(S-1)) ;
				if (*(S-1)==' ' || r) {
					// Если не в начале строки, то
					// завершаем только в том случае когда перед цифрой
					// находится пробел или разделитель
					break ;
			}	}
		} else {
			if ((c=='+' || c=='-') && IsDigit(*(S+1))) {
				// Найден знак перед числом ==> строка заканчивается
				// и нужно перейти к выделению числа
				c = '\0' ;
				break ;
		}	}
		// Достигнут конец разбитаемой строки
		if (c == '\0') break;
		// Новый символ записываем в буфер для подстроки
		SS[j] = c;
		//Увеличиваем число найденных символов
		j++; 
		// Смещаемся в исходной строке
		S++;
	}
	// Закрываем подстроку нулём
	SS[j]   = '\0' ;
	// Значение подстроки сохраняем в элементе разбора
	PI.s    = SS ;		
	// Тип элемента - строка символов 
	PI.type = PI.s.length()>0 ? 1:0 ;	
	// Возвращаем смещение в исходной строке
	return(j+i) ;
}

//---------------------------------------------------------------------------
// Разбор УОФ или любого друго токстового файла или большой строки
// на подстроки символов и целых чисел
// Разбираемая информация берется либо из файла FileName, либо
// читается из уже открытого файла на который указывает pf,
// либо из текстовой строки Text.
//
// Признаком конца формы является: либо конец файла (строки), либо символ
// 'C' в начале очередной строки, либо пустая очередная строка.
// 
// Результаты разбора содержатся в векторе VPI
//---------------------------------------------------------------------------
static int ReadString(FILE* pf, char** Text, char* S)
{
	char ch;
	int  i, n;

	i = 0;
	while (1) {
		if (pf) {
			n = fscanf(pf, "%c", &ch);
			// Проверка корректности считывания символв
			if (n != 1) ch = '\0';
		}
		else {
			ch = *(*Text);
			if (ch != '\0') (*Text)++;
			n = 1;
		}
		if (ch == '\0' || ch == '\n') break;
		if (ch == '\r') continue;
		S[i] = ch;
		i++;
	}
	S[i] = '\0';
	return (ch == '\0' ? -i : i);
}

int ZNumericParser::Execute(char* FileName, FILE* pf, char* Text,
							vector<string>* rows,
							bool PrintToCout)
{
	int  rc = 0 ;
	char S[512] = ""; 
	VParserItem VSPI; // вектор элементов разбора одной строки массива строк
	ZParserItem PI;   // Элемент разбора
	std::string s;

	// Удаление всех прежних результатов разбора
	CountItem = 0 ;
	CountString = 0 ;
	KeyString.clear() ;
	VPI.clear() ;

	//-----------------------------------------------------------------------
	// Должен быть указан один из истояников чтения формы
	if (!FileName && !pf && !Text) { rc = 1 ; goto end ; }
	// Если задано имя файла, то читается данный файл. Его содержимое 
	// записывается в массив строк
	if (FileName) pf = fopen(FileName, "r") ;
	// Задано имя файла но файл открыт не был
	if (FileName && !pf) { rc = 2 ; goto end ; }
	if (!pf && !Text) { rc = 3 ; goto end ; }

	//-----------------------------------------------------------------------
	// Разбор входной информации по строкам - формирование массива строк
	// FileName или pf или Text ===> S 
	// Цыкл чтения строк. Пустые строки пропускаются
	int  n, i = 0, k = 0;
	bool f = false;

	// Признак найденного ключа обозначающего начало УОФ
	bool isFormFind = false;
	bool isNeedFormFind = WhatToLookFor.lf1.length() || 
						  WhatToLookFor.lf2.length();

	if (rows) rows->clear();
	//-----------------------------------------------------------------------
	// Пропускается произвольное число строк до тех пор пока не
	// будет найдена ключевая фраза
	k = 0;
	while (1){
		n = ReadString(pf, &Text, S);
		if (n < 0) {
			// Достигнут конец источника формы
			f = true;
			n = -n;
		}
		if (!n) {
			if (PrintToCout) cout << endl;
			continue;
		}
		if (isNeedFormFind) {
			if (n > 0) {
				s = S;
				k = s.find(WhatToLookFor.lf1, 0);
				if (k != string::npos) break;
				if (WhatToLookFor.lf2.length())	i = s.find(WhatToLookFor.lf2, 0);
				if (k != string::npos) break;
				k = 0;
			}
		}
		if (PrintToCout) cout << S << endl;
		if (f) break;
	}

	while (1) {
		// Разбор строки
		// Разбор выделенной из массива строки
		ProcessString(&S[k], VSPI);
		k = 0;
		n = VSPI.size();
		if (n) {
			// Увеличение общего число найденных элементов разбора
			CountItem += n;
			// Увеличение общего числа найденных строк в массиве строк
			CountString += 1;
			// Индекс первого элемента разбора VSPI[0] для найденной 
			// строки S в общем массиве VPI элементов разбора
			n = VPI.size();
			KeyString.push_back(n);
			// Для последнего элемента разбора в строке устанавлиаем
			// признак разделителя - начало новой строки
			//VSPI[n-1].sep = 36 ;
			// Вставляем полученные элементы разбора VSPI 
			// в общий массив VPI
			VPI.insert(VPI.end(), VSPI.begin(), VSPI.end());
			// Отображение при необходимости на консоли
			if (PrintToCout) cout << S << endl;
			// 
			if (rows) rows->push_back(S);
		}

		// Форма завершена
		if (f) break;

		// Чтение новой строки
		n = ReadString(pf, &Text, S);
		if (n < 0) {
			// Достигнут конец источника формы
			f = true;
			n = -n;
		}
		if (!n || (n == 1 && S[0] == '\n')) break;
	}
		
end: ; 
	// Если в пределах настоящего метода открывался файл для чтения,
	// а это имеет место если задано имя файла FileName,
	// то файл необходимо закрыть.
	if (FileName && pf) { fclose(pf) ; pf = 0 ; }
	return rc ;
}

//---------------------------------------------------------------------------
// Выделение из подстрок с указанным индексом строк, 
// чисел целых и дробных.
// indStr и IndItem указывают на строку и подстроку, 
// начиная с которой необходимо искать число
// Возврат 0 - число (строка) наёдено 
//		   1 - ошибка 
//		  -1 - числа (строки) не найдено 
// После возврата IndItem указывает на последную анализируемую
// подстроку в составе строки indStr
//---------------------------------------------------------------------------
// Выделение из подстрок с указанным индексом целых чисел. 
int ZNumericParser::FindInt(int indStr, int& IndItem, int& D)  
{
	int n = GetCountItems(indStr) ;	// число подстрок в строке
	int i0= KeyString[indStr] ;		// начало строки в общем массиве
	int i1= i0+IndItem ;			// начало перебора в общем массиве	
	int N = i0+n ;					// конец перебора в общем массиве
	int rc= 0 ;
	int i ;
	// Начальное значение искомого числа
	D = 0 ;
	// Перебор подстрок
	for (i=i1; i<N; i++) { 
		// Проверка типа - должно быть целое число
		ZParserItem I = VPI[i] ;
		if (I.type==2) {
			// Индекс следующей проверяемой подстроки
			IndItem = i-i0+1 ;
			// Преобразование строки в число
			// с перехватом возможной исключительной ситуации
			try { 
				D = atoi(I.s.c_str()) ; 
				rc = 0 ; goto end ;
			} catch(...) { 
				// Если имела место исключительная ситуации, 
				// то возвращается код ошибки 
				rc = 1 ; goto end ;
	}	}	}	
	// Индекс следующей проверяемой подстроки
	IndItem = N-i0 ;
	// Целое число в строке не найдено
	rc =-1 ; 
end: ;
	return rc ;
}

// Перегрузка метода для возможности использовать тип short и long
int ZNumericParser::FindInt(int indStr, int& IndItem, short& D)  
{
	int DS ; 
	int rc = FindInt(indStr, IndItem, DS) ;
	D = DS ;
	return rc ;   
}

int ZNumericParser::FindInt(int indStr, int& IndItem, long& D)  
{
	int DS ; 
	int rc = FindInt(indStr, IndItem, DS) ;
	D = DS ;
	return rc ;   
}

//---------------------------------------------------------------------------
// Выделение из подстрок с указанным индексом дробных чисел.
int ZNumericParser::FindDbl(int indStr, int& IndItem, double& D)  
{
	double R ;
	int n = GetCountItems(indStr) ;	// число подстрок в строке
	int i0= KeyString[indStr] ;		// начало строки в общем массиве
	int i1= i0+IndItem ;			// начало перебора в общем массиве	
	int N = i0+n ;					// конец перебора в общем массиве
	int i ;
	int rc= 0 ;
	// Начальное значение искомого числа
	D = 0 ;
	//-----------------------------------------------------------------------
	// Дробное число ищется в виде либо
	// 99999.999, либо 999.99999e-(+)999, либо 999.99999-(+)999.
	// Последний случай есть представление в экспоненциальном виде но
	// только пропущена буква "e".
	// Необходимо отметить что если в тесте встречается число вида
	// 999999 за которым следует НЕ десятичный разделитель, то есть  
	// фактически целое число, то при поиске дробного числа его
	// нужно (возможно нужно) воспринимать как число с фиксированной
	// точкой и с нулевым числом знаков после запятой.
	// Таким образом дробное число может быть представлено от одной 
	// до 4-х подстрок. Например:
	//	1 подстрпока - "9999" 
	//				   число 9999.0
	//	2 подстрпоки - "9999" и "99", где после первой группы 
	//				   стоит обязательно десятичный разделитель,
	//				   число 9999.99
	//	4 подстроки  - "999", "99999", "e" и "-999", где обязательно 
	//				   после первой группы стоит десятичный разделитель,
	//				   после второй и третьей групп разделитель отсутствует,
	//				   число 999.99999е-999
	//	3 подстроки  - "999", "99999" и "-999", где обязательно 
	//				   после первой группы стоит десятичный разделитель,
	//				   после второй группы разделитель отсутствует,
	//				   число 999.99999е-999
	//-----------------------------------------------------------------------
	for (i=i1; i<N; i++) { 
		try {
			ZParserItem I = VPI[i] ;
			if (I.type==2) {
				// Если целое число то это целая часть дробного
				D = (double)atof(I.s.c_str()) ; 
				IndItem = i-i0+1 ;
				// Если правеее в строке подстрок (групп символов) больше 
				// нет, то завершается поиск числа
				if (i==N-1) { rc = 0 ; goto end ; }
				// если десятичный разделитель
				if (I.sep==21 || I.sep==22) {
					// Анализ следующей группы
					i++ ; 
					I = VPI[i] ;
					// Если целое число
					if (I.type==2) {
						R = (double)atof(I.s.c_str()) ; 
						R/= pow(10.0, (double)I.s.length()) ;
						D = (fabs(D)+R)*(D<0 ? -1.0:1.0) ;
						IndItem++ ;
						//---------------------------------------------------
						// Анализ последующей группы символов на наличие
						// экспоненты числа
m_exp: ;
						// Если правеее в строке подстрок (групп символов) 
						// больше нет, то завершается поиск числа
						if (i==N-1) { rc = 0 ; goto end ; }
						// Если после дробной части разделителя нет,
						// то возможно далее следует показатель степени
						// +(-)e999 или e+(-)999 или +(-)999
						if (I.sep==0) {
							// Анализ следующей группы
							i++ ; 
							I = VPI[i] ;
							if (I.type==2) {
								// имеет место показатель степени в формате
								// +(-)999
								R = (double)atoi(I.s.c_str()) ; 
								D*= pow(10.0, R) ;
								IndItem++ ;
								// Найдены целая, дробная часть и 
								// показатель степени
								rc = 0 ; goto end ; 
							} else {
								// Следующая подстрока - строковая переменная
								// Может быть символ экспоненты "e" или "E"
								if (I.type==1 && 
								   (I.s== "e" || I.s== "E" || 
								    I.s=="+e" || I.s=="+E" || 
									I.s=="-e" || I.s=="-E") &&
								    I.sep==0) {
									// Анализ следующей группы
									i++ ; IndItem++ ;
									I = VPI[i] ;
									if (I.type==2) {
										R = (double)atoi(I.s.c_str()) ; 
										D*= pow(10.0, R) ;
										IndItem++ ;
									} else {
										assert(0) ;
									}
								} else {
									// Если не числовая и не строковая 
									// переменная, значит пустая строка,
									// либо строка не содержит формат 
									// показателя степени числа.
									// Значит показателя степени нет и число 
									// содержит только целую и дробную частии
									rc = 0 ; goto end ; 
						//---------------------------------------------------
						}	}	}
					} else {
						// Усли после десятичного разделителя идёт 
						// строковая переменная, значит числа дальше нет
						// и число ограничено целой частью
						rc = 0 ; goto end ; 
					}
				} else {
					if (I.sep>22) {
						// После целой части стоит строковый разделитель
						// Значит число ограничено целой частью	
						rc = 0 ; goto end ;
					}
					// если после целой части нет ни десятичного, 
					// ни какого другого разделителя (VPI[i].sep=0),
					// тогда, возможно далее следует +)-)e999
					goto m_exp ;
			}	}
		} catch(...) { return 1 ; }
	}
	// Число в строке не найдено
	rc =-1 ;

end: ;
	return rc ;
}

// Перегрузка метода для возможности использовать тип float
int ZNumericParser::FindDbl(int indStr, int& IndItem, float& D)  
{
	double DS ; 
	int rc = FindDbl(indStr, IndItem, DS) ;
	D = (float)DS ;
	return rc ;   
}

int ZNumericParser::FindStr(int indStr, int& IndItem, std::string& S, char* key)
{
	int n = GetCountItems(indStr);	// число подстрок в строке
	int i0 = KeyString[indStr];		// начало строки в общем массиве
	int i1 = i0 + IndItem;			// начало перебора в общем массиве	
	int N = i0 + n;					// конец перебора в общем массиве
	int rc = 0;
	int i;
	// Поиск строковой переменной с перехватом возможной 
	// исключительной ситуации
	try {
		// Первоначально делаем строку пустой
		S[0] = '\0';
		// Перебор подстрок
		for (i = i1; i<N; i++) {
			// Проверка типа - должна быть строка
			ZParserItem I = VPI[i];
			if (I.type == 1) {
				int ikey = -1;
				if (key) {
					// Если задана ключевая подстрока то проверяется ее наличие
					ikey = I.s.find(key, 0);
					if (ikey == string::npos) {
						// Если ключ не обнаружен то переход к следующему
						// элементу разьора
						continue;
				}	}
				// Индекс следующей проверяемой подстроки
				IndItem = i - i0 + 1;
				// Копирование найденной строковой переменной
				S = I.s;
				rc = 0; goto end;
	}	}	}
	// Если имела место исключительная ситуации, то возвращается код ошибки 
	catch (...) {
		rc = 1; goto end;
	}
	// Индекс следующей проверяемой подстроки
	IndItem = N - i0;
	// Строковая переменная в строке не найдена
	rc = -1;

end:;
	return rc;
}

//---------------------------------------------------------------------------
// Выделение из подстрок с указанным индексом строковых пременных.
int ZNumericParser::FindStr(int indStr, int& IndItem, char* s, char* key)  
{
	std::string S;
	int rc = FindStr(indStr, IndItem, S, key); if (rc) return rc;
	sprintf(s, "%s\0", S.c_str()); 
	return 0; 
}

//---------------------------------------------------------------------------
// Проверка ключевого слова в указанной позиции
bool ZNumericParser::IsText(int indStr, int IndItem, const char* Text)
{
	int i0= KeyString[indStr] ;		// начало строки в общем массиве
	int i = i0+IndItem ;			// индекс в общем массиве	
	ZParserItem I = VPI[i] ;

	return (I.s==Text ? true:false) ;
}

//---------------------------------------------------------------------------