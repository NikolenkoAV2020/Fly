//-----------------------------------------------------------------------------
// ZCPrintManagerApeak.cpp
// А. Николенко 03.08.2018
// Вертикальное документирование результатов прогноза
//-----------------------------------------------------------------------------
#pragma once
#include <stdafx.h>

#include <FlyCoreSource\\ZMSpaceCraft.h>
#include <FlyCoreSource\\ZCPrintManager.h>
#include <FlyCoreSource\\ZCPrintFormat.h>

//-----------------------------------------------------------------------------
// "Вертикальное", то есть в столбик, документирование параметров движения
//		pKA - модель движения (КА) для которой выполняется документирование,
//		FS  - параметры движения на текущий момент времени,
//		FV  - параметры движения на текущий виток
//		fp  - текстовый файл в который выдаются результаты.
int ZCPrintManager::PrintApeakMSC(
	ZMSC   *pKA,	// модель движения(КА) для которой выполняется документирование,
	ZSC_SI *FS,		// параметры движения на текущий момент времени,
	ZSC_VI *FV,		// параметры движения на текущий виток
	FILE   *fp)		// текстовый файл в который выдаются результаты.
{
	if (pKA) {
		// Если информация о параметрах движения на текущий момент времени
		// и об интегральных параметрах движения не передаётся в качестве
		// аргументов, то данная информация берётся с соответствующих полей 
		// класса модели движения КА.
		if (!FS) FS = &pKA->FSR;
		if (!FV) FV = &pKA->FV;
	}

	// ПРи необходимости передаваемые параметры движения, подлежащие 
	// документированию, накапливаются в буфере PSB и PVB, размер которого
	// равен SIZE_PSB. Когда буфер заполнен все накопленные данные
	// выдаются в документ.
	if ((FS || FV) && countPSB < SIZE_PSB) {
		if (FS) memcpy(&PSB[countPSB], FS, sizeof(ZSC_SI));
		else    memset(&PSB[countPSB], 0, sizeof(ZSC_SI));
		if (FV) memcpy(&PVB[countPSB], FV, sizeof(ZSC_VI));
		else    memset(&PVB[countPSB], 0, sizeof(ZSC_VI));
		countPSB++;
	}
	if (pKA) { 
		if (countPSB < SIZE_PSB) {
			// Если буфер не заполнен то завершение процедуры
			// без фактического документирования результатов - 
			// результаты моделирования движения остаются в буфере
			// PSB и PVB
			return 0;
		}
	} else { if (!countPSB) return 0; }

	if (MPK.fromVit) {
		// В случае прогнозирования движения КА по виткам MPK.fromVit == true,
		// Кинематические параметры движения для заданного момента времени
		// берутся из поля в котором содержатся кинематические парметры движения
		// на момент начала витка, а заданным моментом времени считается 
		// именно момент начала витка.
		for (int i = 0; i < countPSB; i++) {
			memcpy(&PSB[i], &PVB[i].FSUN, sizeof(ZSC_SI));
		}
	}

	// Вывод информации в текстовом формате
	PrintApeakMSCtext(pKA, FS, FV, fp);
	// Вывод информации в формате html
	PrintApeakMSChtml(pKA, FS, FV);

	if (MPF.IsFirstLine()) {
		// В случае, когда в документе впервые отображаются параметры
		// движения КА, как по виткам так и по времени, соответствующая
		// таблица результатов должна начинаться с заголовка.
		// О необходимости документирования заголовка свидетельствует
		// MPF.IsFirstLine() == true.
		// Поэтому после вызова функций документирования в текстовый файл и
		// в файл html необходимо проверить наличие данного флага и если он
		// равен true - отключить его так-как соответствующий заголовок 
		// в этот момент в файл будет уже выведен соответственно мотодами 
		// PrintApeakMSCtext в текстовый документ и PrintApeakMSChtml в
		// документ html.
		MPF.FirstLineOff();
		// Итак флаг, сигнализирующий о необходимости вывода заголовка 
		// таблицы отключён, при последующих вызовах настоящего метода
		// в созданную в документе таблицу выводятся только параметры
		// движения.
	}

	// Все данные из буфера PSB и PVB выведены в файл, поэтому счётчик
	// колличества сохранённых в буфере массивов обнуляется.
	// При очередном вызове настоящего метода параметры движения КА
	// начнут сохранятся в буфере, начиная с индекса 0.
	countPSB = 0;
	return 0;
}

//-------------------------------------------------------------------------------