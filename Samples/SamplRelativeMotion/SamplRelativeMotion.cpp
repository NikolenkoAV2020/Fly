//-----------------------------------------------------------------------------
// SamplRelativeMotion.cpp
// А. Николенко 18.06.2019
//
// Пример прогнозирования относительного движения двух КА в орбитальной СК.
// Фактически программа позволяет сравнивать степень близости НУ - 
// базовых и оцениваемых, которые задаются в качестве исходных данных.
//
// Пример демонстрирует:
//
//		1) Одновременное прогнозирование движения 2-х КА.
//
//		2) Возможность документировать вместе с результатами прогноза
//		   нестандартные параметры движения ... функции :
//		   PrintMng->MPK << ZSUserPrintParam(...
//		   PrintMng->MPK.UPP(i).value =
//		
//		3) Пересчёт фазовых координат в орбитальную систему координат RLN
//		   ZASCtoRLN( ...
//
//		4) Документирование простого текса в виде абзаца
//		   PrintMng->PrintText( ...
//-----------------------------------------------------------------------------
#include "stdafx.h"

//-----------------------------------------------------------------------------
// Компоненты Fly
#include <FlyCore.h>		// Собственоно сама модель движения
#include <FlyMMath.h>		// Математические функции
#include <FlyCoreLink.h>	// Подключение всех библиотек

int TaskRelativeMotion();

void main()
{
	// Вывод кирилицы в консольном приложении 
	//setlocale(LC_CTYPE, "rus");
	SetConsoleCP(1251);
	SetConsoleOutputCP(1251);

	// Инициализация ядра Fly, фактически настройка путей к необходимым 
	// информационным ресурсам, инициализация глобальных переменных,
	// в последствии возможно инициализация соединения с БД...
	int rc = FlyGlobalInit(); if (rc) return;

	// Пример прогнозирования движения КА по виткам
	TaskRelativeMotion();
}

//-----------------------------------------------------------------------------
int TaskRelativeMotion()
{
	cout << "\n   Prediction by Time...\n";

	double t;					// Текущее время  
	double h = 15.0 / 24.0 / 60.0;	// Шаг расчёта параметров движения КА
	int    rc;

	// Начальные условия движения
	ZNU NU1;
	ZNU NU2;

	// Время НУ в ССС от эпохи начала отсчёта времени 
	NU1.t << DATETIMEDMB(1, 1, 2011, 0, 0, 0, 0);
	// Ключи НУ
	NU1.Key = ZKEYNU(1, 12, 4, 0, 1);
	// Условный номер логической шкалы сил (ЛШС). Если при инициализации модели
	// движения ей явно не передаётся структура ЛШС, то модель загружает ЛШС по 
	// данному номеру как по ключу ЛШС из внешнего хранилища.
	// В данном примере ЛШС вормируется явным образом и передаётся в модель 
	// движения как параметр при инициализации.
	NU1.numlsf = 1;						// Ключи НУ
	NU1.vit = 101;						// Виток НУ
	NU1.sk = _SK_OSK2000;				// Система координат - оскулирующие 
	// элементы относительно экватора 
	// эпохи 2000 года
	NU1.X[0] = TO_DTKM(6371 + 740.0);	// Большая полуось в ДТКМ
	NU1.X[1] = 0.0002;					// эксцентриситет
	NU1.X[2] = TO_RAD(60.0);			// наклонение в радианах
	NU1.X[3] = TO_RAD(250.0);			// Абс. долгота восх. узла орбиты 
	NU1.X[4] = TO_RAD(120.0);			// аргумент широты перигея
	NU1.X[5] = TO_RAD(10);				// аргумет широты КА
	NU1.Sb = 0;			// Баллистический коэффициент
	NU1.Kp = 0;			// Коэффициент светового давления
	NU1.M0 = 1000;		// Масса КА не заправленного
	NU1.MF = 200;		// Актуальный запас топлива на борту 

	//-------------------------------------------------------------------------
	// Время НУ в ССС от эпохи начала отсчёта времени 
	NU2.t << DATETIMEDMB(1, 1, 2011, 0, 0, 0, 0);
	// Ключи НУ
	NU2.Key = ZKEYNU(1, 13, 4, 0, 1);
	// Условный номер логической шкалы сил (ЛШС). Если при инициализации модели
	// движения ей явно не передаётся структура ЛШС, то модель загружает ЛШС по 
	// данному номеру как по ключу ЛШС из внешнего хранилища.
	// В данном примере ЛШС вормируется явным образом и передаётся в модель 
	// движения как параметр при инициализации.
	NU2.numlsf = 1;						// Ключи НУ
	NU2.vit = 101;						// Виток НУ
	NU2.sk = _SK_OSK2000;				// Система координат - оскулирующие 
	// элементы относительно экватора 
	// эпохи 2000 года
	NU2.X[0] = TO_DTKM(6371 + 740.1);	// Большая полуось в ДТКМ
	NU2.X[1] = 0.00020001;				// эксцентриситет
	NU2.X[2] = TO_RAD(60.0001);			// наклонение в радианах
	NU2.X[3] = TO_RAD(250.004);			// Абс. долгота восх. узла орбиты 
	NU2.X[4] = TO_RAD(120.00007);		// аргумент широты перигея
	NU2.X[5] = TO_RAD(10);				// аргумет широты КА
	NU2.Sb = 0;		// Баллистический коэффициент
	NU2.Kp = 0;		// Коэффициент светового давления
	NU2.M0 = 1000;	// Масса КА не заправленного
	NU2.MF = 200;	// Актуальный запас топлива на борту 

	//-------------------------------------------------------------------------
	// Время начальное и время конца моделирования движения 
	// выраженное в средних солнечных сутках
	double t0 = NU1.t;
	double tk; tk << DATETIMEDMB(2, 1, 2011, 0, 0, 0, 0);

	//  Логическая шкала сил
	ZLSF LSF;
	LSF.num   = 1;
	LSF.vgpz  = GPZ90;
	LSF.ngpz  = 8;
	LSF.mgpz  = 8;
	LSF.vatm  = ATMSMA81;  // ATMSMA81 ; ATMNULL
	LSF.vsvd  = 0;
	LSF.varsp = 0;
	LSF.vTide = TIDESTEP2; // TIDENULL, TIDESTEP2, TIDEPOSEIDON
	LSF.isDU  = 0;
	LSF.isSun = 1;
	LSF.isMoon= 1;
	memset(LSF.isPlanet, 0, sizeof(LSF.isPlanet));

	//-------------------------------------------------------------------------
	// Модель движения КА
	PZMSC KA1;
	PZMSC KA2;
	// Инициализация модели движения для расчёта от заданных НУ (NU)
	// в заданном поле сил (LSF)
	rc = KA1->Init(NU1, &LSF); if (rc) return rc;
	rc = KA2->Init(NU2, &LSF); if (rc) return rc;
	//-------------------------------------------------------------------------

	// Диспетчер документирования 
	PZCPrintManager PrintMng;
	// Документирование по времени.
	// По умолчанию вертикальное документирование параметров движения
	// то есть в столбик. Поэтому определяем горизонтальное документирование
	PrintMng->MPK.AflatOn();
	// Определяем документирование не по виткам, а по времени.
	PrintMng->MPK.FromVitOff();

	// Добавление документируемых параметров движения
	PrintMng->MPK << MODPR_VIT;
	PrintMng->MPK << MODPRDATETIME;
	PrintMng->MPK << MODPR_T_uTE;

	// Параметризация ПОЛЬЗОВАТЕЛЬСКОГО докумеентирования результатов прогноза.
	// Указыватся: тип параметра, его точность (число знаков после запятой),
	// максимальное колличество символов для представления и название.
	// Значения документируемых параметров задаются далее при помощи
	// функции PMPK.UPP(0).value = ...
	//
	// PrintMng.MPK << ZSUserPrintParam(UPPdouble, 16, 6, "время", "часы") ;
	// PrintMng.MPK.UPP(0).value = 0 ;
	PrintMng->MPK << ZSUserPrintParam(UPPdouble, 16, 6, 
					 "r", "м", "<font face=\"symbol\">r</font>", "м");
	PrintMng->MPK << ZSUserPrintParam(UPPdouble, 16, 6, 
					 "l", "м", "<font face=\"symbol\">t</font>", "м");
	PrintMng->MPK << ZSUserPrintParam(UPPdouble, 16, 6, 
					 "n", "м", "n", "м");
	PrintMng->MPK << ZSUserPrintParam(UPPdouble, 16, 6, 
					 "Vr", "м/сек", 
					 "V<sub><font face=\"symbol\">r</font></sub>", "м/сек");
	PrintMng->MPK << ZSUserPrintParam(UPPdouble, 16, 6, 
					 "Vl", "м/сек", 
					 "V<sub><font face=\"symbol\">t</font></sub>", "м/сек");
	PrintMng->MPK << ZSUserPrintParam(UPPdouble, 16, 6, 
					 "Vn", "м/сек", "V<sub>n</sub>", "м/сек");

	// Создание текстового документа для документирования результатов прогноза
	PrintMng->PrePrint(&KA1, "Прогноз", "SamplRelativeMotion");
	// Заголовок текстового документа
	PrintMng->PrintHeaderDoc("\n   Относительное движение КА\n\n");
	// Опимание решаемой задачи
	PrintMng->PrintText("Вычисление относительного движения второго КА \
(оцениваемого) относительно первого (базового) в орбитальной системе \
координат, связанной с первым КА. Результаты расчёта можно воспринимать \
как оценку эволюции орбиты второго КА относительно орбиты первого КА. \
Или же как оценку степени рассогласования заданных начальных условий.");
	// Документирование НУ и логической шкалы сил
	PrintMng->PrintText("НУ первого, базового КА:");
	PrintMng->PrintNU(NU1, NULL, 3);
	PrintMng->PrintText("НУ второго, оцениваемого КА:");
	PrintMng->PrintNU(NU2, NULL, 3);
	PrintMng->PrintLSF(LSF, 1);

	// Документирование параметров движения 
	PrintMng->PrintMSC(&KA1, NULL, NULL, NULL);
	// Текущее время
	t = KA1->GetTime();
	// Структура для получения всех элементов движения КА на каждом шаге
	ZSC_SI SI1, SI2;

	// Основной цыкл моделирования 
	while (1) {
		// Условие завершение прогнозирования
		if (t + h>tk) break;

		//---------------------------------------------------------------------
		// Прогноз от текущего состояния на шаг по времени h
		// !!!! h не равен шагу интегрирования уравнений движения КА (H)
		// Может иметь место ситуация когда как h > H, так и когда h < H !!!!
		rc = KA1->GoDTime(h, &SI1); if (rc) break;
		rc = KA2->GoDTime(h, &SI2); if (rc) break;

		//---------------------------------------------------------------------
		// Вычисление разности координат и скоростей то есть 
		// движение КА - 2 относительно КА - 1 в координатах АСК ТЭ
		double R[6];
		SubtractVector(SI1.ASKTE, SI2.ASKTE, R, 6);

		// Вычисление отклонений положения КА-2 относительно КА-1 в СК rln
		// связанной с орбитальной системой координат КА-1
		double RLN[6];
		ZASCtoRLN(SI1.ASKTE, R, RLN, true);

		// Значения пользовательских переменных выкладываем в диспетчер 
		// документирования
		for (int i = 0; i < 3; i++) {
			PrintMng->MPK.UPP(i).value = R[i] * 1e7;
			PrintMng->MPK.UPP(i + 3).value = TO_KMS(R[i + 3]) * 1e3;
		}

		// Документирование результатов прогноза 
		PrintMng->PrintMSC(&KA1, &SI1, NULL, NULL);

		// Отображение даты и времени в консоли
		printf("%02d.%02d.%04d    %02d:%02d:%02d\n",
			SI1.Data.d, SI1.Data.m, SI1.Data.g,
			SI1.Time.h, SI1.Time.m, SI1.Time.s);

		// Новое текущее время 
		t = SI1.ta;
	}
	cout << "\n";

	// Завершение документирования
	PrintMng->PostPrint();
	PrintMng->ClosePrint();

	// Просмотр результатов средствами операционной системы
	PrintMng->ShowTextFile();
	PrintMng->ShowHtmlFile();

	return 0;
}

//-----------------------------------------------------------------------------