//-----------------------------------------------------------------------------
// SamplPredictByTurns.cpp
// А. Николенко 14.06.2019
//
// Пример прогнозирования движения КА по виткам по заданным НУ и в заданном 
// поле сил с расчётом интегральных характеристик витка таких как: 
// драконнический период, минимальные и максимальные высоты ти т.д.
//-----------------------------------------------------------------------------
#include "stdafx.h"

//-----------------------------------------------------------------------------
// Компоненты Fly
#include <FlyCore.h>		// Собственоно сама модель движения
#include <FlyMMath.h>		// Математические функции
#include <FlyCoreLink.h>	// Подключение всех библиотек

int TaskTurnsPredictionSimpl();

void main()
{
	// Вывод кирилицы в консольном приложении 
	//setlocale(LC_CTYPE, "rus");
	SetConsoleCP(1251);
	SetConsoleOutputCP(1251);

	// Инициализация ядра Fly, фактически настройка путей к необходимым 
	// информационным ресурсам, инициализация глобальных переменных,
	// в последствии возможно инициализация соединения с БД...
	int rc = FlyGlobalInit(); if (rc) return;

	// Пример прогнозирования движения КА по виткам
	TaskTurnsPredictionSimpl();
}

//-----------------------------------------------------------------------------
// Прогноз движения КА по виткам.
// Демонстрация моделирования движения до начала витка в заданной эпохе
//		Основные демонстрируемые методы и классы: 
//		ZNU    NU			- Начальные условия - структура
//		ZSC_SI SI			- Элементы движения КА - структура
//		ZMSC   KA			- Модель движения, можно полагать её по сути своей 
//							  равной Космическому аппарату (КА) - класс
//		KA.Init(...)		- Инициализация модели движения - метод 
//		KA.GoToVit(...)		- Моделирование движения КА до начала заданного 
//							  витка - метод
//		KA.GoAlongVit(...)	- Прогноз вдоль витка с расчётом интегральных 
//							- параметров витка - метод
//		ZCPrintManager PrintMng - Диспетчер документирования - класс
//-----------------------------------------------------------------------------
int TaskTurnsPredictionSimpl()
{
	cout << "\n   Simple prediction by Turns...\n";

	int  rc = 0;
	long Vit = 105;

	PZCPrintManager PrintMng; // Диспетчер документирования
	ZNU             NU;		 // Начальные условия движения
	PZMSC		    KA;		 // Модель движения КА

	//----------------------------------------------------------------------------
	// НУ
	NU.Key.ka = 1; NU.Key.nom = 15; NU.Key.mod = 0;
	NU.Key.type = 8; NU.Key.bc = 1;
	// Номер логической шкалы сил
	NU.numlsf = 1;						
	DATE dt = DATE(10, 12, 2011);		// Дата НУ
	TIME tm = TIME(12, 15, 54, 0.5432);	// Время НУ ДМВ
	// Переход от ДМВ к равномерно текущему времени в ССС
	TA_DMB(1, &dt, &tm, &NU.t);
	// Виток НУ. !!!! Надо помнить что виток имеет смысл только в связке
	// с номером используемой системе координат, так как в окрестности 
	// начала витка в разных системах координат (в разных эпохах)
	// значение витка может отличаться на 1 - либо конец предыдущего
	// витка, либо начало текущего ... !!!!
	NU.vit = 101;						

	//  Номер системы координат
	NU.sk   = _SK_OSK1975;
	//  большая полуось в ДТКМ
	NU.X[0] = TO_DTKM(15000.0);
	// эксцентриситет
	NU.X[1] = 0.0012;
	// наклонение в радианах 
	NU.X[2] = TO_RAD(69.0);
	// абсолютная долгота узла в радианах
	NU.X[3] = TO_RAD(250.0);
	// аргумент широты перигея в радианах
	NU.X[4] = TO_RAD(125.0);
	// аргумент широты КА в радианах
	NU.X[5] = TO_RAD(15);
	// Баллистический коэффициент
	NU.Sb = 0;
	// Коэффициент светового давления
	NU.Kp = 0;
	// Сухая масса КА
	NU.M0 = 1503;
	// Масса топлива на борту
	NU.MF = 197;

	//----------------------------------------------------------------------------
	// Логическая шкала сил
	ZLSF LSF; memset(&LSF, 0, sizeof(LSF));
	LSF.num   = 1;			// номер ЛШС (пока нигде не используется)
	LSF.vgpz  = GPZ90;		// вариант модели ГПЗ
	LSF.ngpz  = 4;			// число зональных гармоник
	LSF.mgpz  = 4;			// число секториальных гармоник
	LSF.vatm  = ATMNULL;	// вариант модели атмосферы
	LSF.vsvd  = 0;			// вариант модели светового давления
	LSF.varsp = 0;			// зарезервировано и пока не используется
	LSF.vTide = TIDENULL;	// вариант модели учёта гравитационного возмущения 
							// океанических приливов
	LSF.isDU  = 0;			// признак учёта тяги ДУ 
	LSF.isSun = 1;			// признак учёта гравитации Солнца
	LSF.isMoon= 1;			// признак учёта гравитации Луны

	// Инициализация модели движения для расчёта от заданных НУ (NU)
	// в заданном поле сил (LSF)
	rc = KA->Init(NU, &LSF); if (rc) return rc;

	// Создание текстового документа для документирования результатов прогноза
	PrintMng->PrePrint(&KA, "Прогноз", "_TaskTurnsPredictionSimpl");
	PrintMng->PrintHeaderDoc("Прогноз движения КА");
	PrintMng->PrintText("Прогноз параметров движения КА на заданные витки");
	// Документирование НУ и логической шкалы сил
	PrintMng->PrintNU(NU, NULL, 3);
	PrintMng->PrintLSF(LSF, 1);

	// Моделирование движения КА вдоль витка Vit с вычислением
	// интегральных характеристик витка и элементов движения в
	// характерных точках витка (восходящий и нисходящий узел)
	// Предполагается что начало и конец витка определяются моментом 
	// пересечения экватора ТЕКУЩЕЙ ЭПОХИ (_SK_ASKTE) в восходящем узле
	rc = KA->GoAlongVit(Vit, _SK_ASKTE); if (rc) return rc;
	// Документирование результатов прогноза
	PrintMng->PrintMSC(&KA);
	Vit++;

	//----------------------------------------------------------------------------
	// Доступ к результатам иоделирования движения КА
	//----------------------------------------------------------------------------

	// для результатов прогноза - выход на виток, 
	// на аргумент или на время
	// !!!! Очень важное поле! Тут находятся результаты 
	// прогнозирования получаемые посредством ф-ий:
	// GoAlongVit, GoToVit, GoToVitU, GoToU, GoToDU
	// GoToTime, GoDTime. !!!! 
	KA->FSR;
	// Координаты в АСК текущей эпохи
	KA->FSR.ASKTE;
	// Оскулирующие элементы орбиты относительно экватора текущей эпохи
	KA->FSR.OSKTE;
	// и так далее ...

	// Поле для хранения параметров витка при прогнозировании 
	// движения по виткам. Заполняется процедурой 
	// моделирования движения КА вдоль 
	// заданного витка GoAlongVit.
	KA->FV;
	
	//----------------------------------------------------------------------------
	// Повторение для нескольких витков
	//----------------------------------------------------------------------------
	cout << "\r	  Turn  " << Vit << "....     ";
	rc = KA->GoAlongVit(Vit, _SK_ASKTE); if (rc) return rc;
	PrintMng->PrintMSC(&KA);
	Vit++;

	cout << "\r	  Turn  " << Vit << "....     ";
	rc = KA->GoAlongVit(Vit, _SK_ASKTE); if (rc) return rc;
	PrintMng->PrintMSC(&KA);
	Vit += 2;

	cout << "\r	  Turn  " << Vit << "....     ";
	rc = KA->GoAlongVit(Vit, _SK_ASKTE); if (rc) return rc;
	PrintMng->PrintMSC(&KA);
	Vit++;

	cout << "\r	  Turn  " << Vit << "....     ";
	rc = KA->GoAlongVit(Vit, _SK_ASKTE); if (rc) return rc;
	PrintMng->PrintMSC(&KA);
	Vit += 2;

	cout << "\r	  Turn  " << Vit << "....     \n\n";
	rc = KA->GoAlongVit(Vit, _SK_ASKTE); if (rc) return rc;
	PrintMng->PrintMSC(&KA);

	// Завершение документирования
	PrintMng->PostPrint();
	PrintMng->ClosePrint();

	// Просмотр результатов средствами операционной системы
	PrintMng->ShowTextFile();
	PrintMng->ShowHtmlFile();

	return rc;
}

//-----------------------------------------------------------------------------

