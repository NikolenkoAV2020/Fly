//--------------------------------------------------------------------------------
// ZMForceAtmDMA1990_Gost25645115.cpp
// Вычисление плотности динамической атмосферы по 
// ГОСТ Р 25645.115-1990.
// А. Николенко 08.11.2018.
//
// Расчет плотности атмосферы производится на основе модели для баллистического
// обеспечения полетов искусственных спутников Земли, регламентированной
// Государственным стандартом. Модель разработана по данным о движении ИСЗ в
// атмосфере за период 1964-1982 гг. В 1990 году была проведена ее коррекция,
// привлечены новые данные об эволюции орбит КА, учтен опыт применения стандарта
// при баллистическом обеспечении полетов КА и последние достижения по исследованию
// плотности атмосферы и ее пространственно-временных вариаций. В настоящее время
// модель используются в организациях Российской Академии наук, Центре управления
// полетом ЦНИИМАШ и ряде других организаций для баллистико-навигационного
// обеспечения полета околоземных КА.
//--------------------------------------------------------------------------------
#include <stdafx.h>
#pragma   hdrstop
#include <FlyMMath.h>

#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#include <FlyCoreSource\\ZSK.h>
#include <FlyCoreSource\\ZMForceAtmDMA1990_Gost25645115.h>
#include <FlyCoreSource\\ZMForceAtmDMA1990_Gost25645115Data.h>

//--------------------------------------------------------------------------------
//	JD         - Юлианская дата, соответствующая текущему времени, UTC
//	ISA        - Индексы солнечной активности
//	SUNg       - Координаты Солнца в гринвичской вращающейся СК, [км]
//	SUNte	   - Координаты Солнца в АСК текущей эпохи, [км]
//	XYZg       - Координаты КА в гринвичской вращающейся СК, [км]
//	ro         - Искомая плотность атмосферы в кг/м3
//--------------------------------------------------------------------------------
int DMA_GOST_25645_115_1990(double JD, ISA_DMA ISA, double* SUNg, double* SUNte, double* XYZg, double& ro)
{
	int    i, N, rc = 0 ; 
	//double ro0  = 1.58868e-8 ;		// плотность ночной атмосферы на высоте 120 км в кг/м3
	double Re   = 6378.136 ;		// Радиус экватора км
	double alfa = 0.0033528037 ;	// величина геометрического сжатия Земли
	double g0   = 9.80665 ;			// м/сек2
	double pi   = acos(-1.0) ;

	//----------------------------------------------------------------------------
	// Расстояние Земля-Солнце
	double RS  = sqrt(SUNg[0]*SUNg[0]+SUNg[1]*SUNg[1]+SUNg[2]*SUNg[2]) ;
	// Единичный вектор направления на солнце в ГСК
	double SUNg0[3] ; for (i=0; i<3; i++) SUNg0[i] = SUNg[i]/RS ;
	// Расстояние Земля-КА
	double Rka = sqrt(XYZg[0]*XYZg[0]+XYZg[1]*XYZg[1]+XYZg[2]*XYZg[2]) ;
	// Высота КА
	double h   = Rka-Re*(1.0-alfa*XYZg[2]*XYZg[2]/Rka/Rka) ;

	//----------------------------------------------------------------------------
	// Выше 1500 км полагаем атмосферу нулевой
	if (h>1500.0) {	ro = 0 ; return 0 ; }

	//----------------------------------------------------------------------------
	// Если вычисленная высота h менее 120 км, то пространственно-временные вариации 
	// плотности не учитываются. Плотность атмосферы   рассчитывают по формуле
	// для статической стандартной атмосферы (ГОСТ 1981 года)
	if (h<=120.0) {
		if (h<0) h = 0.0 ;
		// Выбор высотного слоя
		N = SIZEOFA(LowAtmDMA1990) ;
		for (i=0; i<N; i++) { if (h<LowAtmDMA1990[i].h) break ; }
		// Начальная и конечная высоты высотного слоя
		double hn= i==0? 0 : LowAtmDMA1990[i-1].h ;
		double hk= LowAtmDMA1990[i].h ;
		// Коэффициенты апроксимации плотности атмосферы
		double a = LowAtmDMA1990[i].a ;
		double k1= LowAtmDMA1990[i].k1 ;
		double k2= LowAtmDMA1990[i].k2 ; 
		// Вычисление плотности статической атмосферы
		ro = a*exp(k1*(h-hn)+k2*(h-hn)*(h-hn)) ;
		return 0 ;
	}

	//----------------------------------------------------------------------------
	// Фиксированный уровень солнечной активности за рассматриваемый период. 
	// Допустимые значения: 75, 100, 125, 150, 175, 200, 250
	double F0   = 125 ;
	// Средне-взвешенное за 81 сутки значение индекса  F107
	double F81  = 125 ;
	// Индекс солнечной активности, равный плотности потока 
	// радиоизлучения Солнца на волне, длиной 10.7 см
	double F107 = 125 ;
	// Квазилогарифмический, планетарный среднесуточный 
	// индекс геомагнитной активности
	double Kp   = 2 ;
	// Модифицированное значение 3-х часовых индексов 
	// геомагнитной возмущенности
	double kpp  = 2 ;

	// Вычисляется значение индексов F107 и F81 для времени, 
	// отстоящего от текущего на -1.7 суток
	F107 = ISA.F107 ;
	F81  = ISA.F81 ;
	Kp   = ISA.Kp ;
	kpp  = ISA.kpp ;

	// Индекс фиксированного ИСА F0
	// Из таблицы возможных значений F выбирается значение, ближайшее к полученному
	int iF0 = 0 ;			
	N = SIZEOFA(F0fix) ;
	for (i=0; i<N-1; i++) {	if ((F81-F0fix[i])*(F81-F0fix[i+1])<=0) break ;	}
	if (i==N-1) iF0 = F81<F0fix[0] ? 0:(N-1) ;
	else iF0 = fabs(F81-F0fix[i])<fabs(F81-F0fix[i+1]) ? i:(i+1) ;
	F0 = F0fix[iF0] ;

	//----------------------------------------------------------------------------
	// Коэффициенты ДМА
	double a[3] ;				// 1-я группа коэффициентов
	double b[3] ;				// 2-я группа коэффициентов
	double c[4], n[2], fi1 ;	// 3-я группа коэффициентов
	double d[3] ;				// 4-я группа коэффициентов
	double e[7] ;				// 5-я группа коэффициентов
	double l[3] ;				// 7-я группа коэффициентов

	// Формирование коэффициэнтов в зависимости от высотного слоя
	double h1 = 180.0 ;
	double h2 = 600.0 ;
	if (h<h1) {
		// Ниржний высотный диапазон
		a[0] = ailow[0][iF0] ; a[1] = ailow[1][iF0] ; a[2] = ailow[2][iF0] ; 
		b[0] = bilow[0][iF0] ; b[1] = bilow[1][iF0] ; b[2] = ailow[2][iF0] ; 
		c[0] = cilow[0][iF0] ; c[1] = cilow[1][iF0] ; 
		c[2] = cilow[2][iF0] ; c[3] = cilow[3][iF0] ; 
		n[0] = nilow[0][iF0] ; n[1] = nilow[1][iF0] ;
		fi1  = filow[iF0] ;
		d[0] = dilow[0][iF0] ; d[1] = dilow[1][iF0] ; d[2] = dilow[2][iF0] ; 
		e[0] = eilow[0][iF0] ; e[1] = eilow[1][iF0] ; e[2] = eilow[2][iF0] ; 
		e[3] = eilow[3][iF0] ; e[4] = eilow[4][iF0] ; e[5] = eilow[5][iF0] ; 
		e[6] = eilow[6][iF0] ; 
		l[0] = lilow[0][iF0] ; l[1] = lilow[1][iF0] ; 
		l[2] = lilow[2][iF0] ; 
	} else {
		if (h<h2) {
			// Средний высотный диапазон
			a[0] = aimid[0][iF0] ; a[1] = aimid[1][iF0] ; a[2] = aimid[2][iF0] ; 
			b[0] = bimid[0][iF0] ; b[1] = bimid[1][iF0] ; b[2] = aimid[2][iF0] ; 
			c[0] = cimid[0][iF0] ; c[1] = cimid[1][iF0] ; 
			c[2] = cimid[2][iF0] ; c[3] = cimid[3][iF0] ; 
			n[0] = nimid[0][iF0] ; n[1] = nimid[1][iF0] ;
			fi1  = fimid[iF0] ;
			d[0] = dimid[0][iF0] ; d[1] = dimid[1][iF0] ; d[2] = dimid[2][iF0] ; 
			e[0] = eimid[0][iF0] ; e[1] = eimid[1][iF0] ; e[2] = eimid[2][iF0] ; 
			e[3] = eimid[3][iF0] ; e[4] = eimid[4][iF0] ; e[5] = eimid[5][iF0] ; 
			e[6] = eimid[6][iF0] ; 
			l[0] = limid[0][iF0] ; l[1] = limid[1][iF0] ; 
			l[2] = limid[2][iF0] ; 
		} else {
			// Верхний высотный диапазон
			a[0] = aihi[0][iF0] ; a[1] = aihi[1][iF0] ; a[2] = aihi[2][iF0] ; 
			b[0] = bihi[0][iF0] ; b[1] = bihi[1][iF0] ; b[2] = aihi[2][iF0] ; 
			c[0] = cihi[0][iF0] ; c[1] = cihi[1][iF0] ; 
			c[2] = cihi[2][iF0] ; c[3] = cihi[3][iF0] ; 
			n[0] = nihi[0][iF0] ; n[1] = nihi[1][iF0] ;
			fi1  = fihi[iF0] ;
			d[0] = dihi[0][iF0] ; d[1] = dihi[1][iF0] ; d[2] = dihi[2][iF0] ; 
			e[0] = eihi[0][iF0] ; e[1] = eihi[1][iF0] ; e[2] = eihi[2][iF0] ; 
			e[3] = eihi[3][iF0] ; e[4] = eihi[4][iF0] ; e[5] = eihi[5][iF0] ; 
			e[6] = eihi[6][iF0] ; 
			l[0] = lihi[0][iF0] ; l[1] = lihi[1][iF0] ; 
			l[2] = lihi[2][iF0] ; 
		}
	}

	//----------------------------------------------------------------------------
	// вычисление угла fi1 
	double cfi1 = cos(fi1) ;
	double sfi1 = sin(fi1) ;
	// косинус угла "фи"
	double cfi  = 1.0/Rka*(
		          XYZg[0]*(SUNg0[0]*cfi1-SUNg0[1]*sfi1)+
		          XYZg[1]*(SUNg0[1]*cfi1+SUNg0[0]*sfi1)+
				  XYZg[2]*SUNg0[2]) ;
	// косинус угла "фи/2"
	double cfi2 = sqrt((1.0+cfi)/2.0) ;

	//----------------------------------------------------------------------------
	// Определяется количество суток d, прошедшее от начала года
	double d1913 = JD-2419768.0 ;
	double my    = (int)((4.0*d1913-1.0)/1461.0) ;
	// Так было в методике написанной по ГОСТу 
	// double dy = d1913-(int)(1461.0*my/4.0)-1.0+0.125 ; 
	// 1) Учтём отсчёт юлианских дат от 12 часов - то есть добавим в 
	//    полученную величину 0,5 суток
	// 2) Учтём тот факт что число суток имеет смысл времени UT1
	//    то есть величину 0.125 добавлять не нужно  
	double dy    = d1913-(int)(1461.0*my/4.0)-1.0+0.5 ; 

	//----------------------------------------------------------------------------
	// Вычисление функции A(d) по таблице
	int    jd = (int)(dy/10) ; 
	double dd = dy-jd*10 ; 
	double Ad = AD[1][jd]+(AD[1][jd+1]-AD[1][jd])/10.0*dd ;

	//----------------------------------------------------------------------------
	// Вычисление коэффициентов 
	double K0 = 1+(l[0]+l[1]*h+l[2]*h*h)*(F81-F0) ; 
	double K1 = 1+(c[0]+c[1]*h+c[2]*h*h+c[3]*h*h*h)*pow(cfi2, n[0]+n[1]*h) ; 
	double K2 = 1+(d[0]+d[1]*h+d[2]*h*h)*Ad ; 
	double K3 = 1+(b[0]+b[1]*h+b[2]*h*h)*(F107-F81)/F81 ;
	double K4 = 1+(e[0]+e[1]*h+e[2]*h*h+e[3]*h*h*h)*(e[4]+e[5]*Kp+e[6]*Kp*Kp) ;

	//----------------------------------------------------------------------------
	// Вычисление плотности
	double roNight = g0*exp(a[0]-a[1]*sqrt(h-a[2])) ;
	ro = roNight*K0*K1*K2*K3*K4 ; 
	return rc ;
}

//--------------------------------------------------------------------------------
