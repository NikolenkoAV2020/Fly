//-----------------------------------------------------------------------------
// SamplPredictByTime.cpp
// А. Николенко 14.06.2019
//
// Прогноз с заданным шагом по времени
//-----------------------------------------------------------------------------
#include "stdafx.h"

//-----------------------------------------------------------------------------
// Компоненты Fly
#include <FlyCore.h>		// Собственоно сама модель движения
#include <FlyMMath.h>		// Математические функции
#include <FlyCoreLink.h>	// Подключение всех библиотек

int TaskTimePrediction();

void main()
{
	// Вывод кирилицы в консольном приложении 
	//setlocale(LC_CTYPE, "rus");
	SetConsoleCP(1251);
	SetConsoleOutputCP(1251);

	// Инициализация ядра Fly, фактически настройка путей к необходимым 
	// информационным ресурсам, инициализация глобальных переменных,
	// в последствии возможно инициализация соединения с БД...
	int rc = FlyGlobalInit(); if (rc) return;

	// Пример прогнозирования движения КА по времени
	TaskTimePrediction();
}

//-----------------------------------------------------------------------------
// Прогноз с заданным шагом по времени
//		Основные демонстрируемые методы и классы: 
//		ZNU    NU		- Начальные условия - структура
//		ZSC_SI SI		- Элементы движения КА - структура
//		ZMSC   KA		- Модель движения, можно полагать её по сути своей 
//						  равной Космическому аппарату (КА) - класс
//		KA.Init(...)	- Инициализация модели движения - метод 
//		KA.GoDTime(...)	- Прогноз по времени с заданным шагом (один шаг) - метод
//-----------------------------------------------------------------------------
int TaskTimePrediction()
{
	cout << "\n   Prediction by Time...\n";

	double t;					// Текущее время  
	double h = 15.0 / 24.0 / 60.0;	// Шаг расчёта параметров движения КА
	int    rc;

	// Начальные условия движения
	ZNU NU;
	// Время НУ в ССС от эпохи начала отсчёта времени 
	NU.t << DATETIMEDMB(1, 1, 2011, 0, 0, 0, 0);
	// Ключи НУ
	NU.Key = ZKEYNU(1, 12, 4, 0, 1);
	// Условный номер логической шкалы сил (ЛШС). Если при инициализации модели
	// движения ей явно не передаётся структура ЛШС, то модель загружает ЛШС по 
	// данному номеру как по ключу ЛШС из внешнего хранилища.
	// В данном примере ЛШС вормируется явным образом и передаётся в модель 
	// движения как параметр при инициализации.
	NU.numlsf = 1;						// Ключи НУ
	NU.vit = 101;						// Виток НУ
	NU.sk = _SK_OSK2000;				// Система координат - оскулирующие 
	// элементы относительно экватора 
	// эпохи 2000 года
	NU.X[0] = TO_DTKM(6371 + 740.0);		// Большая полуось в ДТКМ
	NU.X[1] = 0.0002;					// эксцентриситет
	NU.X[2] = TO_RAD(60.0);			// наклонение в радианах
	NU.X[3] = TO_RAD(250.0);			// Абс. долгота восх. узла орбиты 
	NU.X[4] = TO_RAD(120.0);			// аргумент широты перигея
	NU.X[5] = TO_RAD(10);			// аргумет широты КА
	NU.Sb = 0;		// Баллистический коэффициент
	NU.Kp = 0;		// Коэффициент светового давления
	NU.M0 = 1000;	// Масса КА не заправленного
	NU.MF = 200;		// Актуальный запас топлива на борту 

	// Время начальное и время конца моделирования движения 
	// выраженное в средних солнечных сутках
	double t0 = NU.t;
	double tk; tk << DATETIMEDMB(2, 1, 2011, 0, 0, 0, 0);

	//  Логическая шкала сил
	ZLSF LSF;
	LSF.num = 1;
	LSF.vgpz = GPZ90;
	LSF.ngpz = 8;
	LSF.mgpz = 8;
	LSF.vatm = ATMSMA81;  // ATMSMA81 ; ATMNULL
	LSF.vsvd = 0;
	LSF.varsp = 0;
	LSF.vTide = TIDESTEP2; // TIDENULL, TIDESTEP2, TIDEPOSEIDON
	LSF.isDU = 0;
	LSF.isSun = 1;
	LSF.isMoon = 1;
	memset(LSF.isPlanet, 0, sizeof(LSF.isPlanet));

	//-------------------------------------------------------------------------
	// Модель движения КА
	PZMSC KA;
	// Инициализация модели движения для расчёта от заданных НУ (NU)
	// в заданном поле сил (LSF)
	rc = KA->Init(NU, &LSF); if (rc) return rc;
	//-------------------------------------------------------------------------

	// Диспетчер документирования 
	PZCPrintManager PrintMng;
	// Документирование по времени.
	// По умолчанию вертикальное документирование параметров движения
	// то есть в столбик	
	PrintMng->MPK.FromVitOff();
	// Создание текстового документа для документирования результатов прогноза
	PrintMng->PrePrint(&KA, "Прогноз", "_TaskTimePrediction");
	// Заголовок текстового документа
	PrintMng->PrintHeaderDoc("\n   Прогноз параметров движения КА по времени\n\n");
	// Документирование НУ и логической шкалы сил
	PrintMng->PrintNU(NU, NULL, 3);
	PrintMng->PrintLSF(LSF, 1);

	// Документирование параметров движения 
	PrintMng->PrintMSC(&KA, NULL, NULL, NULL);
	// Текущее время
	t = KA->GetTime();
	// Структура для получения всех элементов движения КА на каждом шаге
	ZSC_SI SI;

	// Основной цыкл моделирования 
	while (1) {
		// Условие завершение прогнозирования
		if (t + h>tk) break;

		//---------------------------------------------------------------------
		// Прогноз от текущего состояния на шаг по времени h
		// !!!! h не равен шагу интегрирования уравнений движения КА (H)
		// Может иметь место ситуация когда как h > H, так и когда h < H !!!!
		rc = KA->GoDTime(h, &SI); if (rc) break;
		//---------------------------------------------------------------------

		// Документирование результатов прогноза 
		PrintMng->PrintMSC(&KA, &SI, NULL, NULL);
		// Отображение даты и времени в консоли
		printf("%02d.%02d.%04d    %02d:%02d:%02d\n",
			SI.Data.d, SI.Data.m, SI.Data.g,
			SI.Time.h, SI.Time.m, SI.Time.s);
		// Новое текущее время 
		t = SI.ta;
	}
	cout << "\n";

	// Завершение документирования
	PrintMng->PostPrint();
	PrintMng->ClosePrint();

	// Просмотр результатов средствами операционной системы
	PrintMng->ShowTextFile();
	PrintMng->ShowHtmlFile();

	return rc;
}

//-----------------------------------------------------------------------------

