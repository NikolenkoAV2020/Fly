//-------------------------------------------------------------------------------
// MagicSolutionPrint.cpp : 
// А. Николенко 12.10.2018
//-------------------------------------------------------------------------------
#include <stdafx.h>

//---------------------------------------------------------------------------
// Компоненты Fly
#include <FlyMMath.h>		// Математические функции
#include <FlyCore.h>		// Математические функции
#include <FlyMagicLNS.h>	//

int MagicSolutionPrint(
	ZSMagicLnsSolution *MS,		// Исходные данны для задачи
	ZCPrintManager *PrintMng,	// Диспетчер документирования
	FILE        *pf,			// файл документа
	ZMSC        &KA,			// Модель движения.
						// Параметры движения КА:
	ZSLoopFact  &P1,	// - после первого имульса;
	ZSLoopFact  &P2,	// - после второго имульса;
	ZSLoopFact  &PN,	// - на заданном витке в пассивном полёте;
	ZSLoopFact  &PR,	// - расчётные на заданном витке;
	ZSC_SI      *SI,	// - на начало заданного витка;
	ZSC_VI      *VI,	// - интегральные на заданном витке.
	ZSFlightRule &U,	// Пар-ы расчитанной программы управления
	ZNU      *RIKNU)	// НУ с РИК, для каждого импульса
{
	if (!pf) return 0 ;

	char S[512] = "";
	int  rc = 0 ;
	// Документирование результатов решения краевой задачи определения
	// параметров программы управления движением КА
	MagicPrint(MS, PrintMng, pf, P1, P2, PN, PR, U) ;

	// Заданный виток 
	long vz = PN.Vit;

	// Признак отсутствия необходимости документировать параметры движения
	// на витке, следующем за витком последнего имульса 
	// Имеет место быть когда данный виток совпадает с заданным витком, потому
	// что заданный виток документируется отдельно
	bool isSimopleParamVZ = ((U.vit[U.n-1]+1)==vz ? true:false) ;   

	// Документирование параметров движения КА вдоль расчётной траектории
	// Документирование параметров движения на заданном витке
	int N = U.n-(isSimopleParamVZ? 1:0) ;
	bool ifLong = (N==1) ? true:false ;
	N = ifLong ? 0:N ;
	if (ifLong) {
		fprintf (pf, "__________________________________________________________________\n" ) ;
		if (U.n==2) fprintf (pf, "                  До коррекции   После коррекции   После 1-го имп.\n" ) ;
		else        fprintf (pf, "                  До коррекции   После коррекции    После импульса\n" ) ;				
	} else {
		fprintf (pf, "________________________________________________\n" ) ;
		fprintf (pf, "                  До коррекции   После коррекции\n" ) ;
	}
	// на заданном витке в пассивном полёте
	rc = PrintMng->PrintMSC(&KA, &SI[0], &VI[0], pf) ; RRC ;
	// на заданном витке после реализации рассчитанной программы управления
	rc = PrintMng->PrintMSC(&KA, &SI[1], &VI[1], pf) ; RRC ;
	// При необходимости параметры движения после первого импульса 
	if (ifLong) { rc = PrintMng->PrintMSC(&KA, &SI[2], &VI[2], pf) ; RRC ; }
	// Принудительный сброс в файл выданных колонок 
	// (если документирование вертикальное)
	PrintMng->PrintMSC(NULL, NULL, NULL, pf) ; 

	if (N>0) {
		int i ;
		sprintf (S, "\n  4. ПАРАМЕТРЫ ДВИЖЕНИЯ ПОСЛЕ ИМПУЛЬСОВ\n" ) ;
		fprintf(pf, "%s", S);
		PrintMng->PrintText(S);

		fprintf (pf, "____________" ) ;
		for (i=0; i<N; i++) fprintf (pf, "__________________" ) ; fprintf (pf, "\n" ) ;
		fprintf (pf, "            " ) ;
		for (i=0; i<N; i++) fprintf (pf, "   После %d-го имп.", i+1) ; fprintf (pf, "\n" ) ;
		fprintf (pf, "____________" ) ;
		for (i=0; i<N; i++) fprintf (pf, "__________________" ) ; fprintf (pf, "\n" ) ;

		for (i=0; i<N; i++) {  
			rc = PrintMng->PrintMSC(&KA, &SI[2+i], &VI[2+i], pf) ; RRC ;
		}
		// Принудительный сброс в файл выданных колонок 
		// (если документирование вертикальное)
		PrintMng->PrintMSC(NULL, NULL, NULL, pf) ; 
	}

	// Документирование НУ с РИК
	if (U.n>1) sprintf(S, "\n  5. НУ С РАСЧЁТНЫМИ ИМПУЛЬСАМИ КОРРЕКЦИИ\n\n");
	else sprintf (S, "\n  5. НУ С РАСЧЁТНЫМ ИМПУЛЬСОМ КОРРЕКЦИИ\n\n" ) ; 
	fprintf(pf, "%s", S);
	PrintMng->PrintText(S);
	for (int i=0; i<U.n; i++) {  
		if (U.n > 1) {
			sprintf(S, " После %d-го импульса коррекции", i + 1);
			PrintMng->PrintText(S);
		}
		PrintMng->PrintNU(RIKNU[i], S, 3, pf) ;
	}

	return 0 ;
}	