//----------------------------------------------------------------------------
// ZERP.cpp
// Вычисление параметров вращения Земли
//
// А. Николенко 01.03.2019
//----------------------------------------------------------------------------
#include <stdafx.h>
#pragma   hdrstop
#include <FlyMMath.h>	// Математические функции
#include <FlyTime.h>	// Всё про время

#include <FlyCoreSource\\ModGlobal.h>
#include <FlyCoreSource\\ZFarg.h>
#include <FlyCoreSource\\ZERP.h>

//----------------------------------------------------------------------------
// Расчет приливных околосуточных поправок к ПВЗ
// 
//	dXp - поправка к координате полюса Xp (если nullptr-не вычисляется)
//	dYp - поправка к координате полюса Yp (если nullptr-не вычисляется)
//	dUT - поправка к UT1-UTC			  (если nullptr-не вычисляется)
//	Scale:
//		0 - t задано в ссс от J2000 (0h 01.01.2000)
//		1 - t задано в ссс от J1975 (0h 01.01.1975)
//		2 - t задано в юлианских столетиях от J2000 (12h 01.01.2000)
void ZErpTide(double t, double *dUT, double *dXp, double *dYp, TIMESCALE Scale) 
{
	t = Astro2000Time(t, Scale, nullptr) ;

	static short 
	AsinDUT1[] = {245, 1210, 286, 864,  -380, -1617, -759, -196},
    AcosDUT1[] = {503, 1605, 516, 1771, -154,  -720,   -4,  -38},
    AsinXp[]   = {-26, -133, -50, -152,  -57,  -330, -145,  -36},
    AcosXp[]   = {  6,   49,  25,   78,  -13,   -28,   64,   17},
    AsinYp[]   = { -6,  -49, -25,  -78,   11,    37,   59,   18},
    AcosYp[]   = {-26, -133, -50, -152,   33,   196,   87,   22};
	static char  
	cf[8][7] = {{-1, 0,-2, 0,-2, 1,-1},
				{ 0, 0,-2, 0,-2, 1,-1},
				{ 0, 0,-2, 2,-2, 1,-1},
				{ 0, 0, 0, 0, 0, 1, 1},
				{-1, 0,-2, 0,-2, 2, 0},
				{ 0, 0,-2, 0,-2, 2, 0},
				{ 0, 0,-2, 2,-2, 2, 0},
				{ 0, 0, 0, 0, 0, 2, 0}};
	double FA[6], Arg, CArg, SArg ;

	// Вычисление фундаментальных аргументов 
	ZFArg(t, FA, 0, TIMEJ2000JC, FARG1980) ;
	double FA1[6] ;
	ZFArg(t, FA1, 0, TIMEJ2000JC, FARG2000) ;
	FA[5] = 648000.0 + 
			(67310.54841 + 
			(876600.0*3600+8640184.812866)*t +
            0.093104*t*t - 6.2e-6*t*t*t)*15.0 ;
	// отбрасываем целое число "витков"
	FA[5] = fmod(FA[5] / M_SEKRAD, k_dwapi);

	// Обнуление поправок
	if (dUT) *dUT = 0.0 ;
	if (dXp) *dXp = 0.0 ;
	if (dYp) *dYp = 0.0 ;

	// Расчет поправок
	for (int i=0; i<8; i++) {
		Arg = cf[i][0]*FA[0] + cf[i][1]*FA[1] +
			  cf[i][2]*FA[2] + cf[i][3]*FA[3] +
			  cf[i][4]*FA[4] + cf[i][5]*FA[5] + cf[i][6]*k_polpi;
		SArg = sin( Arg ); CArg = cos(Arg);
		// Расчет поправки к dUT1
		if(dUT) *dUT+= AsinDUT1[i]*SArg+AcosDUT1[i]*CArg ;
		// Расчет поправки к Xp
		if(dXp) *dXp+= AsinXp[i]*SArg+AcosXp[i]*CArg ;
		// Расчет поправки к Yp
		if(dYp) *dYp+= AsinYp[i]*SArg+AcosYp[i]*CArg ;
	}

	// Перевод поправок в размерность комплекса
	if(dUT) *dUT*=(1.e-8/k_cbc);
	if (dXp) *dXp *= (1.e-6 / M_SEKRAD);
	if (dYp) *dYp *= (1.e-6 / M_SEKRAD);
}

//----------------------------------------------------------------------------


