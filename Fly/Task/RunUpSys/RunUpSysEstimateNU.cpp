//-----------------------------------------------------------------------------
// RunUpSysEstimateNU.cpp: 
// А. Николенко 10.08.2018
//-----------------------------------------------------------------------------
#include "stdafx.h"

//-----------------------------------------------------------------------------
// Компоненты Fly
#include <FlyCore.h>		// Собственоно сама модель движения
#include <FlyMMath.h>		// Математические функции

//-----------------------------------------------------------------------------
#include "RunUpSysBuild.h"

//-----------------------------------------------------------------------------
// Правые части внешних дифференциальных уравнений.
// Реалзация перегруженого метода вычисления правых частей внешних
// дифференциальных уравнений.
ZMSC_EXV_BEG(ZModExternEstNU)
	// Переменные:
	//		t	 - Время, атомное
	//		Xmain- Координаты в СК интегрирования СДУ
	// Вычисление координат в Гринвиче
	double GSK[6] ;
	int rc = ZASC1975toGSC(t, Xmain, GSK, 0); RRC;
	// Высота широта и долгота...
	double HBL[3] ;
	ZGRtoHBL(GSK, HBL, 0, 0) ;
	// Высота над ОЗЭ выраженная в км.
	Yexe[0] = 1e4*HBL[0] ;
	// В данном случае интегрируется одна переменная Y, ДУ для которой 
	// имеет вид следующий вид.
	// dY
	// --- = H,  Н - это высота полёта над ОЗЭ.
	// dt
ZMSC_END

//-----------------------------------------------------------------------------
// Процедура корректировки НУ NU0 с целью получения из них в поле сил LSF
// НУ орбиты с заданной геометрией (az (или havrz, если), e1z, e2z) в точке 
// с аргументом широты uz и с заданной средней высотой на витке.
// Результат - начальные условия NUK.
int RunUpSysEstimateNU(
	ZLSF&  LSF, 
	ZNU&   NU0, 
	ZNU&   NUK, 
	double uz, 
	double e1z, 
	double e2z, 
	double az, 
	double havrz) 
{
	int    count = 0 ;
	int    rc ;
	int    Vit ;
	double da, de1, de2 ; 		
	double at, e1t, e2t ; 
	double epsa = 1e-7 ;	// точность сходимости по высоте в дткм
	double epse = 1e-8 ;	// точность сходимости по эксцентриситету

	ZNU NU = NU0 ;			// Уточняемые НУ
	ZModExternEstNU KA ;	// Модель движения КА

	Vit = NU0.vit ;			// Виток на котором происходит уточнение НУ
	az /= 1e4 ;				// Пересчёт заданного значения полуоси в ДТКМ

	// Указываем модели движения что СДУ будет содержать одно внешнее уравнение
	// Метод расчёта ПЧ внешних уравнений реализован в классе ZModExternEstNU
	KA.SetExternalEquationsCount(1);
	// Инициализация МД
	rc = KA.Init(NU, &LSF); RRC;

	ZSC_SI SI ;
	while(1) {
		// Прогнозирование движения КА до момента начала витка Vit
		rc = KA.GoToVit(Vit, &SI); RRC;
		// Оскулирующие параметры на начало витка:
		// большая полуось и вектор эксцентриситета
		at  = SI.OSKTE[0] ;
		e1t = SI.OSKTE[1]*cos(SI.OSKTE[4]) ;
		e2t = SI.OSKTE[1]*sin(SI.OSKTE[4]) ;
		// отклоенния параметров от требуемых значений
		if (az>0) da = at-az ;
		de1 = e1t-e1z ;
		de2 = e2t-e2z ;

		// Моделирование витка и интегрирование высоты вдоль витка

		if (havrz>0) {
			// Включаем внешие уравнений. 
			// Одновременно формируются нулевые НУ по внешнему уравнению 
 			KA.ExternalEquationsOn() ;
			double Xexe = 0.0 ;
			KA.SetVectorExe(&Xexe) ;
		}
		// Моделирование одного витка Vit
		rc = KA.GoAlongVit(Vit); RRC; 
		if (havrz>0) {
			// Выключение внешнего уравнения. Одновременно возвращается значение
			// внешней переменной dHAvr в момент завершения моделирования, т.е. 
			// на конец витка dHAvr по смыслу ПЧ реализованной в 
			// ZModExternEstNU::ExternalSph есть численное значение 
			// определённого интеграла по времени от начала витка до конца 
			// витка, где подинтегральной функции является зависимость от 
			// времени высоты КА над ОЗЭ. 
			//
			//         t= вр.кон.вит.   
			//         / 
			// dHAvr = | h(t)*dt
			//         /
			//         t= вр.нач.вит
			//
			double dHAvr = 0 ;
			KA.ExternalEquationsOff(&dHAvr) ;

			// Оценка средней высоты на витке
			// Расчётные параметры витка 
			// !!!! Переделать в FSUN.ExternalEq[0] находится не верное 
			// не нулевое значение MKA_VI* VI = &KA.FV ;
			// dHAvr =(VI->FSTE.ExternalEq[0]-VI->FSUN.ExternalEq[0]) ;
			// Делим на драконический период получаем осреднённую на витке 
			// среднюю высоту КА над ОЗЭ
			dHAvr/=(KA.FV.Td/k_cbc) ;							
			// dHAvr = KA.FV.HAvr ;
			// Вычитаем требуемое значение и получаем невязку, 
			// требующую устранения
			dHAvr-= havrz ;
			// Для Коррекции среднеё высоты изменяем большую полуось в НУ
			da = dHAvr/1e4 ;
		}

		// Вносим полученные поправки в НУ
		
		// Поправки к геометрии орбиты
		// Текущий вектор эксцентриситета
		double e10 = NU.X[1]*cos(NU.X[4]) ;
		double e20 = NU.X[1]*sin(NU.X[4]) ;
		// Вносим расчитанные ранее поправки в вектор эксцентриситета 
		// и в значение большой полуоси
		e10-= de1 ; 
		e20-= de2 ; 
		// В соответствии с уточнёнными значениями компонент вектора 
		// эксцентриситета вычисляем эксцентриситет и аргумент 
		// перигея уточняемых НУ
		NU.X[1] = sqrt(e10*e10 + e20*e20) ;
		NU.X[4] = Atan2(e20, e10, 0) ;	
		// Вносим поправку в значение большой полуоси
		NU.X[0]-= da ;

		// Проверка сходимости
		if (fabs(da)<epsa) {
			if (fabs(de1)<epse) {
				if (fabs(de2)<epse) break ;
		}	}	

		count++ ;
		// Проверка числа итераций (зацыкливания)
		if (count>50) return-1 ;

		// Задаём новые начальные условия движения КА
		KA.SetVector(NU.X, NU.vit, NU.t, KA.WeightFullNU(), NU.sk) ; 
	}

	// Собственно полученные уточнённые НУ со среднеё высотой 
	// вдоль ближайшего витка равной заданному значению
	NUK = NU ;
	return 0 ;
}

//-----------------------------------------------------------------------------