//-----------------------------------------------------------------------------
// ZNUT.cpp
//-----------------------------------------------------------------------------
// НУТАЦИЯ
//-----------------------------------------------------------------------------
// Вычисление параметров нутации и матрицы нутации
// Реализованы методы расчёта в зависимости от значения ModNut:
//	NUT1980			// Локальная реализация вычислния нутации 
//					// по рекомендациям IAU 1980 года, тот же алгоритм 
//					// изложен в РД-50...
//	NUT2000			// Локальная реализация вычислния нутации с учётом 
//					// рекомендвций IAU 2000 года относительно расчёта 
//					// фундаментальных аргументов
//	NUT2006			// Локальная реализация модели IAU2000A
//	NUTIAU1980		// Реализация SOFA модели IAU 1980 года
//	NUTIAU2000B		// Реализация SOFA упрощённой модели IAU2000B
//	NUTIAU2000A		// Реализация SOFA полной модели IAU2000A
//	NUTIAU2006		// Реализация SOFA модели Convention 2006
//
// Необхродимо помнить, что для расчёта матрицы нутации необходимо значение
// среднего наклона эклиптики к экваору которвый так же может быть расчитан
// с использованием той или иной полиномиальной модели, которая в рамках 
// данного программного модуля выбирается в соответствии со значением
// ModNut 
//
// А. Николенко 26.02.2019
//-----------------------------------------------------------------------------
#include <stdafx.h>
#pragma   hdrstop

//-----------------------------------------------------------------------------
// Компоненты Fly
#include <FlyTime.h>	// Всё про время
#include <FlySofa.h>	// Функции фундаментальной астрономии

//-----------------------------------------------------------------------------
#include <FlyCoreSource\\ZNUT.h>
#include <FlyCoreSource\\ZFarg.h>
#include <FlyCoreSource\\ZCMiniStackKeeper.h>

// Министек для хранения последних расчитанных параметров нутации,
// применяется для исключения проведения многократных вычислений
// для одного и того же момента времени.
static ZCKeepper3D		NutStack(1e-3 / k_cbc);
static ZCKeepperMart3	NMatrStack(1e-3 / k_cbc);

static double	Nut_inquiry_eps_t = 1e-3/k_cbc ;		// 1-а тысячная доля секундв	
static double	Nut_last_inquiry_tJ2000 =-999999.0 ;	// Последнее время на которое запрашвалась матрица нутации
static double	Nut_last_inquiry_Matr[10] = {			// Последняя расчитанная матрица нутации
				0, 0, 0, 0, 0, 0, 0, 0, 0, 0} ;
static double	NutPar_last_inquiry_tJ2000 =-999999.0 ;	// Последнее время на которое запрашвалась параметры нутации
static double	NutPar_last_inquiry[4] = {				// Последние расчитанные параметры нутации
				0, 0, 0, 0} ;


//-----------------------------------------------------------------------------
// Порядок вычислений. 
// 1) Для вычисления матрицы нутации нужно вызвать ф-ю ZBuildMatrNutJ2000,
//    которая в соответствии со схемой вызывает последовательность функций.
// 2) Для вычисления параметров нутации нужно вызвать ф-ю ZNutJ2000, которая 
//	  так же в соответствии со схемой вызывает последовательно функции
// 
// ZBuildMatrNutJ2000<--ZMatrNut<--ZNutJ2000|<-------|
// 						(выч.матр.)	(выч.пар.)		 |
//													 |
//				   |---------------------------------|
//				   |
//				   |<--- ZNutJ2000Like73790
//						  |
//						  | (либо по соглашению IERS 2003 года
//						  | (либо по "РД-50...")	
//						  |
//						  |<--Z_NUT_IERS2003	
//						  |
//						  |<--Z_NUT_RD_50_25645
//				
// Альтернативой ф-ии ZNutJ2000 является функция ZNutJ2000Like2003, результат
// которой более точный. Алгоритм, реализованный в ZNutJ2000Like2003, 
// соответствует более современным соглашениям IERS, но вычислительные затраты
// на расчёт на порядок выше!
// 				

//-----------------------------------------------------------------------------
// Расчет параметров нутации на время t от эпохи J2000
// Convention 2003 года IERS (локальная не SOFA реализация)
int  ZNutJ2000Like2003(double t, double *Nut, TIMESCALE Scale=TIME1975ASD) ;
// Расчет параметров нутации
// Устаревшая версия полиномов
// !!!! 73790 ЦНИИ-50 !!!!
// Все алгоритмы и полиномы реализованные в данной функции заимствованы
// в когда-то существовавшей вч73790 
void ZNutJ2000Like73790(double t, double *Nut, TIMESCALE Scale=TIME1975ASD, 
					    MODEL_NUTJ2000 ModNut=DEF_MODNUT) ;
// Расчет параметров нутации при помощи библиотеки SOFA.
// SOFA это Open Source бибилиотека, реализующая алгоритмы рекомендованные
// международным астрономическим союзом IAU, и свободно распростроняемая. 
int ZNutJ2000LikeSOFA(double t, double *Nut, TIMESCALE Scale,
					   MODEL_NUTJ2000 ModNut=DEF_MODNUT) ;

//-----------------------------------------------------------------------------
// Расчет матрицы на время t от эпохи J2000
int ZBuildMatrNutJ2000(double t, double* M, TIMESCALE Scale, 
					   MODEL_NUTJ2000 ModNut)
{
	double ta ; 
	t = Astro2000Time(t, Scale, &ta) ;

	// Проверка необходимости расчета 
	if (fabs(Nut_last_inquiry_tJ2000-ta)<=Nut_inquiry_eps_t &&
		(MODEL_NUTJ2000)(int)Nut_last_inquiry_Matr[9]==ModNut) {
		// Если при предыдущем вызове данной функции параметры нутации 
		// уже были расчитаны на момент времени достаточно близкий к ta, 
		// то повторный расчет не выполняется, а просто копируется расчитанный 
		// ранее массив. Матрица Nut_last_inquiry_Matr запоминается после 
		// каждого нового расчёта
		memcpy(M, Nut_last_inquiry_Matr, 9*sizeof(double)) ;
		return 0 ;
	}

	// Парамеьры нутации 
	//		Nut[0] - средний наклон эклиптики к экватору
	//		Nut[1] - нутация в долготе
	//		Nut[2] - нутация в наклоне
	double Nut[3] ; 
	// Вычисление нутации в долготе и в наклоне
	int    rc = ZNutJ2000(t, &Nut[0], 0, TIMEJ2000JC, ModNut) ; RRC ; 
	// Матрица нутации
	ZMatrNut(Nut, M) ;

	Nut_last_inquiry_tJ2000 = ta ; 
	Nut_last_inquiry_Matr[9] = (double)ModNut ;
	memcpy(Nut_last_inquiry_Matr, M, 9*sizeof(double)) ;
	return 0 ;
}
 
//-----------------------------------------------------------------------------
// Расчет параметров нутации на время t
//	Nut[0] - наклон эклиптики к экватору
//	Nut[1] - нутация долготы
//	Nut[2] - нутация наклона
//  dimKey - признак размерности результатов
//		0 - в рарианах
//		1 - в градусах
//		2 - в угловых секундах
//	Scale:
//		0 - t задано в ссс от J2000 (0h 01.01.2000)
//		1 - t задано в ссс от J1975 (0h 01.01.1975)
//		2 - t задано в юлианских столетиях от J2000 (12h 01.01.2000)
//-----------------------------------------------------------------------------
int ZNutJ2000(double t, double *Nut, char dimKey, TIMESCALE Scale, 
			  MODEL_NUTJ2000 ModNut)
{
	// Преобразование времени в масштаб юлианских столетий
	// отсчитываемых от астрономической эпохи 2000 года 
	double ta ; 
	t = Astro2000Time(t, Scale, &ta) ;

	// Проверка необходимости расчета 
	if (fabs(NutPar_last_inquiry_tJ2000-ta)<=Nut_inquiry_eps_t &&
		(MODEL_NUTJ2000)(int)NutPar_last_inquiry[3]==ModNut) {
		// Если при предыдущем вызове данной функции параметры нутации 
		// уже были расчитаны на момент времени достаточно близкий к ta, 
		// то повторный расчет не выполняется, а просто копируется расчитанный 
		// ранее массив NutPar_last_inquiry запоминается 
		// после каждого нового расчёта.
		memcpy(Nut, NutPar_last_inquiry, 3*sizeof(double));
	} else {
		//---------------------------------------------------------------------
		// Собственно расчет параметров нутации (нутация долготы, 
		// нутация наклона) и ср. наклона эклиптики
		switch(ModNut) {
			case NUT1980:
			case NUT2000:
				// Вычисление нутации в долготе и нутации в наклоне
				// Результат в угловых секундах
				ZNutJ2000Like73790(t, &Nut[1], TIMEJ2000JC, ModNut) ; break ;
			case NUT2006: 
				// Вычисление нутации в долготе и нутации в наклоне
				// по модели IAU2000A локальная реализация
				// !!!! В настоящее время не точныое решение - ошибка !!!!
				// Результат в угловых секундах
				ZNutJ2000Like2003(t, &Nut[1], TIMEJ2000JC) ; break ;
			case NUTIAU1980:
			case NUTIAU2000B:
			case NUTIAU2000A:
			case NUTIAU2006:
				ZNutJ2000LikeSOFA(ta, &Nut[1], TIME1975ASD, ModNut) ; break ;
		}
		//---------------------------------------------------------------------
		// Вычисление среднего наклона эклиптики к экватору
		// Результат в угловых секундах
		switch(ModNut) {
			case NUT1980:
				Nut[0] = ZAverageE0RD50(t, TIMEJ2000JC); break ;
			case NUT2000:
				Nut[0] = ZAverageE0IERS2003(t, TIMEJ2000JC); break ;
			case NUT2006: 
				Nut[0] = ZAverageE0IERS2009(t, TIMEJ2000JC); break ;
			case NUTIAU1980:
				Nut[0] = ZAverageE0(t, TIMEJ2000JC, AVRE0IAU1980) ; break ;
			case NUTIAU2000B:
			case NUTIAU2000A:
			case NUTIAU2006:
				Nut[0] = ZAverageE0(t, TIMEJ2000JC, AVRE0IAU2006) ; break ;
		}
		//---------------------------------------------------------------------
		// Архивирование результатов последнего расчёта параметров нутации
		NutPar_last_inquiry_tJ2000 = ta ;
		memcpy(NutPar_last_inquiry, Nut, 3*sizeof(double));
		NutPar_last_inquiry[3] = (double)ModNut ;
	}

	// Перевод угловых секунд в нужную размерность
	if (dimKey<2) {
		double k = 1;
		switch (dimKey) {
			case 0: k = M_SEKRAD; break;
			case 1: k = 3600; break;
		}
		for (int i = 0; i<3; i++) Nut[i] /= k;
	}
	return 0;
}

//-----------------------------------------------------------------------------
// Функция формирования матрицы нутации M
// Nut - параметры нутации в радианах (наклон эклиптики, нутация в долготе 
// и нутация в наклоне)
//-----------------------------------------------------------------------------
void ZMatrNut(double* Nut, double* M)
{
	double S_Nu0, C_Nu0, S_Nu1, C_Nu1, S_Nu2, C_Nu2;
	double C_Nu0_C_Nu1, S_Nu0_C_Nu1;

	S_Nu0 = sin(Nut[0]+Nut[2]);
	C_Nu0 = cos(Nut[0]+Nut[2]);
	S_Nu1 = sin(Nut[1]);  C_Nu1 = cos(Nut[1]);
	S_Nu2 = sin(Nut[0]);  C_Nu2 = cos(Nut[0]);
	C_Nu0_C_Nu1 = C_Nu0*C_Nu1;
	S_Nu0_C_Nu1 = S_Nu0*C_Nu1;

	M[0] = C_Nu1;
	M[1] =-S_Nu1*C_Nu2;
	M[2] =-S_Nu1*S_Nu2;
	M[3] = C_Nu0*S_Nu1;
	M[4] = C_Nu0_C_Nu1*C_Nu2 + S_Nu0*S_Nu2;
	M[5] = C_Nu0_C_Nu1*S_Nu2 - S_Nu0*C_Nu2;
	M[6] = S_Nu0*S_Nu1;
	M[7] = S_Nu0_C_Nu1*C_Nu2 - C_Nu0*S_Nu2;
	M[8] = S_Nu0_C_Nu1*S_Nu2 + C_Nu0*C_Nu2;
}

//-----------------------------------------------------------------------------
// Расчет параметров нутации
// Устаревшая версия полиномов
// !!!! 73790 ЦНИИ-50 !!!!
// Все алгоритмы и полиномы реализованные в данной функции заимствованы
// в когда-то существовавшей вч73790 
// Результат:
//		XN[0] - нутация по долготе в угловых секундах
//		XN[1] - нутация наклона в угловых секундах
//-----------------------------------------------------------------------------
void ZNutJ2000Like73790(double t, double *Nut, TIMESCALE Scale,
					    MODEL_NUTJ2000 ModNut)
{
	// Преобразование времени в масштаб юлианских столетий
	// отсчитаннных от астрономической эпохи 2000 года
	t = Astro2000Time(t, Scale, nullptr) ;

	if (ModNut==NUT2006) {
		ZNutJ2000Like2003(t, Nut, TIMEJ2000JC) ;
		return ;
	}

	static const float am[37]={
		 712.0e0f,	  -7.0e0f,	1426.0e0f,	    54.0e0f,	 -386.0e0f,
		 200.0e0f,	  63.0e0f,	  -2.0e0f, -171996.0e0f,	92025.0e0f,
		-174.2e0f,	 129.0e0f,	 -70.0e0f,  -13187.0e0f,	 5736.0e0f,
		-517.0e0f,	 224.0e0f,	 217.0e0f,	   -95.0e0f,	 2062.0e0f,
		-895.0e0f,	 -51.0e0f,	  27.0e0f,	 -2274.0e0f,	  977.0e0f,
		-301.0e0f,	 129.0e0f,	 123.0e0f,	   -53.0e0f,	  -59.0e0f,
		  26.0e0f,	-158.0e0f,	  -1.0e0f,	    63.0e0f,	  -33.0e0f,
		 -58.0e0f,	  32.0e0f};
	float  S[6],C[6];
	double U[5],XND,XNN,X,Y;
	static const short LOGIK[13]={
	01346,	0656,	0260,	01620,	0550,
	0130,	0353,	0130,	01313,	0340,
	01140,	0150,	01510 };
	short I,I1,I2,I3,I4,J;

	// Вычисление фундаментальных аргументов
	switch(ModNut) {
		case NUT1980: ZFArg(t, U, 0, TIMEJ2000JC, FARG1980); break;
		case NUT2000: ZFArg(t, U, 0, TIMEJ2000JC, FARG2000); break;
		case NUT2006:
		default: assert(0);	break;
	}

	U[2]=2*U[2]+U[4];
	U[3]=2*U[3];

	XNN = 0 ;
	XND = 0 ;
	I   =-1 ;
	J   = 0 ;
	short METKA = 9 ;

met9: 
	I=I+1;
	if (I==5) goto met15;
	X=U[I];
	Y=sin(X);
	X=cos(X);
met1: 
	XND=am[J]*Y+XND;
	J=J+1;
	XNN=am[J]*X+XNN;
	J=J+1;
	if (I<0) goto met8;
	S[I]=(float)Y;
	C[I]=(float)X;
	if (METKA==8) goto met8;
	else goto met9;
met15:
	XND=am[J]*t*S[4]+XND;
	J=J+1;
	METKA=8;
	I4=-1;
met8: 
	I4=I4++;
	if (I4==13) goto met7;
	I=-1;
	I2=-1;
	I1=LOGIK[I4];
met2: 
	I3=I1/8;
	I1=I1-I3*8;
	if (I>=0) goto met3;
	I=I2;
	I2=I1;
	I1=I3;
	goto met2;
met3: 
	if (I3>0) goto met4;
	Y=-1;
	goto met5;
met4: 
	Y=1;
met5:
	I1--;
	I2--;
	I--;
	X=C[I1]*C[I2]+Y*S[I2]*S[I1];

	if(I==-1) goto met6;
met6:
	Y=S[I1]*C[I2]-Y*S[I2]*C[I1];
	goto met1;
met7:

	// Преобразование в угловые секунды
	Nut[0]=XND*1.0e-4;
	Nut[1]=XNN*1.0e-4;
	return ;
}

//-----------------------------------------------------------------------------
// Расчет параметров нутации при помощи библиотеки SOFA.
// SOFA это Open Source бибилиотека, реализующая алгоритмы рекомендованные
// международным астрономическим союзом IAU, и свободно распростроняемая. 
// Результат:
//		XN[0] - нутация по долготе в угловых секундах
//		XN[1] - нутация наклона в угловых секундах
// Единственной проблемой данной функции является необходимость подать 
// на вход библиотеке правильное время в нужном формате. Для этого 
// используется разработанный класс универсаьного времени TheTimes
//-----------------------------------------------------------------------------
int ZNutJ2000LikeSOFA(double t, double *Nut, TIMESCALE Scale,
					   MODEL_NUTJ2000 ModNut)
{
	// Преобразование времени в масштаб юлианских столетий
	// отсчитаннных от астрономической эпохи 2000 года
	double ta ;
	Astro2000Time(t, Scale, &ta) ;
	// "Двойное" время
	// Вычитается 0.5 для учёта разницы начала эпохи J1975 (12h)
	// и начала отсчёта времени от 1975 года (0h)
	TheDblTime Dblt = ta-0.5 ; 
	// Пересчёт в юлианскую дату
	Dblt+= TheT_JD1975 ;
	// Универсальное время 
	TheTimes TheT ; 
	TheT.fromIAT(Dblt) ;

	double dpsi ;	// Нутация в наклоне
	double deps ;	// Нутация в долготе
	switch(ModNut) {
		case NUTIAU1980:
			// Nutation, IAU 1980 model.
			iauNut80(TheT.TT.D1(), TheT.TT.D2(), &dpsi, &deps) ; break ;
		case NUTIAU2000B:
			// Nutation, IAU 2000B model.
			iauNut00b(TheT.TT.D1(), TheT.TT.D2(), &dpsi, &deps) ; break ;
		case NUTIAU2000A:
			// Nutation, IAU 2000A model (MHB2000 luni-solar and planetary nutation
			// with free core nutation omitted).
			iauNut00a(TheT.TT.D1(), TheT.TT.D2(), &dpsi, &deps) ; break ;
		case NUTIAU2006:
			// IAU 2000A nutation with adjustments to match the IAU 2006
			// precession.
			iauNut06a(TheT.TT.D1(), TheT.TT.D2(), &dpsi, &deps) ; break ;
		default:
			assert(0) ;
	}
	
	// Преобразование из радиан в угловые секунды
	Nut[0] = dpsi*180*3600.0/k_pi ;
	Nut[1] = deps*180*3600.0/k_pi ;

	return 0 ;
}

//-----------------------------------------------------------------------------


