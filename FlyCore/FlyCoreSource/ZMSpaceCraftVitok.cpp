//-------------------------------------------------------------------------------
// ZMSpaceCraftVitok.cpp
// А. Николенко 03.08.2018
//-------------------------------------------------------------------------------
#pragma once
#include <stdafx.h>

//---------------------------------------------------------------------------
// Компоненты Fly
#include <FlyMMath.h>	// Математические функции

//---------------------------------------------------------------------------
#include <FlyCoreSource\\ModGlobal.h>
#include <FlyCoreSource\\ZMSpaceCraft.h>

//-------------------------------------------------------------------
// Методы для рассчёта ЗРВ, точнее отслеживания на лету, то есть одновременно
// с обычным прогнозом параметров движения, событий ЗРВ (вход, выход, параметр) 
//-------------------------------------------------------------------
// Инициализация начала отслеживания ЗРВ
int ZMSC::RunUpZRV(int CountNip, int* NipIndexes ) 
{
	int rc ;
	rc = EventMng.RunUpZRV(CountNip, NipIndexes) ; RRC ;
	rc = EventMng.CalcParams(this, nullptr) ;
	return rc ;
} 

//-------------------------------------------------------------------------------
// Завершение отслеживания ЗРВ
void ZMSC::CompletZRV() 
{
	EventMng.CompletZRV() ;
} 

//-------------------------------------------------------------------------------
// Инициализация начала отслеживания событий витка
int ZMSC::RunUpVit() 
{
	// Обнуление всех переменных диспетчера событий, отвечающих
	// за отслеживание событий витка.
	// Активирование функции автоматического отслеживания событий 
	// виткаи и при необходимости (то есть при обнаружении 
	// в пределах шага) уточнения данных событий
	EventMng.RunUpVit() ; 
	// Обнуление полей структуры интегральных параметров витка,
	// предназначенных жля хранения экстремальных значений
	// радиуса и высоты, характеристик событий достижения 
	// данных экстремальных значений, а так же событий
	// пересечений восходящего и нисходящего узла орбиты.
	int S = sizeof(ZSC_VP) ;
	memset(&FV.Hmin, 0, S) ; 
	memset(&FV.Hmin2,0, S) ; 
	memset(&FV.Hmin3,0, S) ; 
	memset(&FV.Hmax, 0, S) ; 
	memset(&FV.Hmax2,0, S) ; 
	memset(&FV.Hmax3,0, S) ; 
	memset(&FV.Rmin, 0, S) ; 
	memset(&FV.Rmin2,0, S) ; 
	memset(&FV.Rmin3,0, S) ; 
	memset(&FV.Rmax, 0, S) ; 
	memset(&FV.Rmax2,0, S) ; 
	memset(&FV.Rmax3,0, S) ; 
	memset(&FV.UN,   0, S) ; 
	memset(&FV.DN,   0, S) ; 
	//
	int rc ; 
	if (FSP.E.ID != ModEvent_EMPTY) {
		// Формирование массива информации для отслеживания событий витка
		// по параметрам движения на предшествующем шаге
		// Однако, полученные характеристики записываются в переменные для 
		// текущего шага !!!! 
		rc = EventMng.CalcParams(this, &FSP) ; 
	} else {
		rc = EventMng.CalcParams(this, &FSC) ; 
	}
	RRC ; 
	// Тест контролируемых событий
	// При обнаружении события в пределах последнего шага 
	// событие автоматически уточняется
	//
	// В пределах нижевызываемой функции выполняется:
	//   1) перемещение полученных характеристик в массив характеристик 
	//      предшествующего шага 
	//      ...PreTest() ;
	//   2) Формирование массива информации для отслеживания событий витка
	//      по параметрам движения текущего шага
	//      ...CalcParams(this, &FSC) ; 
	//
	// !!!! Проверка наличия событий и их уточнение проводится в пределах
	// от FSP до FSC !!!! 
	rc = EventMng.TestEvents(this, &FSC) ; 
	return 0 ; 
}

//-------------------------------------------------------------------------------
// Завершение отслеживания событий витка
void ZMSC::CompletVit() 
{
	EventMng.FinalityVit() ;
}

//-------------------------------------------------------------------------------
int ZMSC::OnVitokEvent(ZMOD_EVENT& E, ZSC_SI* SI) 
{
	ZSC_VP* P = nullptr ;
	switch (E.ID) {
		case ModEvent_VITVU: 
			P = &FV.UN ;
			FV.FSUN =*SI ;
			break ;
		case ModEvent_VITNU: 
			P = &FV.DN ;   
			FV.FSDN =*SI ;
			break ;
		case ModEvent_HMIN : P = &(FV.Hmin.isFind ? (FV.Hmin2.isFind ? FV.Hmin3:FV.Hmin2):FV.Hmin) ; break ;
		case ModEvent_HMAX : P = &(FV.Hmax.isFind ? (FV.Hmax2.isFind ? FV.Hmax3:FV.Hmax2):FV.Hmax) ; break ;
		case ModEvent_RMIN : P = &(FV.Rmin.isFind ? (FV.Rmin2.isFind ? FV.Rmin3:FV.Rmin2):FV.Rmin) ; break ;
		case ModEvent_RMAX : P = &(FV.Rmax.isFind ? (FV.Rmax2.isFind ? FV.Rmax3:FV.Rmax2):FV.Rmax) ; break ;
	}
	if (P) {
		P->isFind = true ; 
		P->t = E.ta ;
		P->R = 1e4*FR(SI->ASK1975) ;
		P->H = SI->THBLFR[1] ;
		P->B = SI->THBLFR[2] ;
		P->L = SI->THBLFR[3] ;
		P->ute = TO_GRAD(SI->OSKTE[5]) ;
		P->tmssvv = SI->tmss ;
	}
	return 0 ;
}

//-------------------------------------------------------------------------------
int ZMSC::OnUserEvent(ZMOD_EVENT& E, ZSC_SI* FSCE) 
{
	return 0 ;
}

//-------------------------------------------------------------------------------
int ZMSC::OnZRVEvent(ZMOD_EVENT& E, ZSC_SI* FSCE) 
{
	return 0 ;
}

//-------------------------------------------------------------------------------
int ZMSC::RestartFromEvent() 
{
	// Если не было заказано переразгона МД то просто выходим из
	// процедуры
	if (!IsRestart()) return 0 ; 

	// Если был заказап переразгон (не важно одношаговый метод или многощаговый),
	// то есть было установлено значение CountGI=0, топереразгоняемся от момента 
	// времени соответствующего последнему событию, в том числе: выход на время, на виток, 
	// на заданный аргумент.
	// В качестве НУ движения используются параметры движения из структуры FSE

	// Принудительное задание значения интегрируемого вектора функцией SetVector
	// приводит к дальнейшему переразгону с минимальным начальным шагом
	// Поэтому для повышения быстродействия сохраним текущий шаг и потом восстановим его значение 
	double old_step = m_step ;
	// Задаём в иетеграторе значения кормпонент интегрируемого вектора, время и массу 
	SetVector(FSE.ASK1975, FSE.Vit75, FSE.ta, FSE.m, _SK_ASK1975) ;
	// Задаём начальные значения для внешних уравнений 
	if (IsExtEqOn()) { 
		if (FSE.ExternalEqOn && FSE.ExternalEqCount>0) {
			SetVectorExe(FSE.ExternalEq) ;
	}	}
	// Расчёт контролируемых параметров 
	StepCalc(0) ;
	// Восстановление предыдущего значения шага интегрирования
	m_step = old_step ;
	return 0 ;
}

//-------------------------------------------------------------------------------
int ZMSC::GoAlongVit(long Vit, SK_TYPE sk) 
{
	int rc = 0 ;

	// Обнуляем признаки обнаружения всех возможных событий на витке
	FV.UN.isFind = FV.DN.isFind = 
	FV.Hmin.isFind = FV.Hmax.isFind = FV.Hmin2.isFind = FV.Hmax2.isFind =
	FV.Rmin.isFind = FV.Rmax.isFind = FV.Rmin2.isFind = FV.Rmax2.isFind = false ;

	// Интегрирование до заданного начального витка (ВУ)
	ZSC_SI SI ; 
	rc = GoToVit(Vit, &SI, false, sk); RRC;
	// !!!! После завершения данной (GoToVit) функции всегда будет 
	// определено событие "выход на начало витка"
	// Структура FSE будет заполнена параметрами движения в ВУ орбиты
	// время FSE.ta будет лежать между временем FSP.ta и временем FSC.ta !!!!

	int SizeExtEq = ExtEqDef.Size() ;
	if (SizeExtEq) ExternalEquationsOn() ;

	long   Vitn= Vit ;
	long   Vitt= Vit ;
	long   Vitk= Vit+1 ;
	double tt  = SI.ta ;
	double tp  = tt ;
	double Zt  = KoordVitSK(&SI, sk) ;
	double Zp  = Zt ;
	int    dir = 1 ;

	// Для переразгона если это необходимо вызывается RestartFromEvent
	// Переразгон необходим при использовании метода Адамся
	// для интегрирования СДУ или в следующем случае...
	//
	// Если модель движения находится в состоянии когда сформированы результаты
	// прогнозирования (на заданное время, на виток или арг. широты), то 
	// дальнейший прогноз необходимо начать не с момента времени FSC, а с момента 
	// времени FSR. 
	// В ходе прогнозирования по шагам 
	//		FSC = FSR, FSE != FSC или FSE.E.ID = ModEvent_EMPTY.
	// При прогнозировании до заданного времени, до витка или аргумента
	//		FSC > FSR > FSP, FSE = FSR и FSE.E.ID = ModEvent_ONVIT или иное.
	//
	// Конечно же переразгон от события будет иметь место если его необходимость 
	// отмечсена ранее функуией Restart. Подобное имеет место например: 
	//		- при начале интегрирования внешних уравнений от заданных НУ этих 
	//		  уравнений; 
	//		- при формировании программы управления движением ЦМ КА и 
	//		  отображении данной программы управления в соответствующих полях 
	//		  модели сразу после выполнения прогноза до заданного момента 
	//		  времени, витка или аргумента широты.
	rc = RestartFromEvent() ; RRC ;

	// Тест контролируемых событий, инициализация процесса отслеживания
	// событий витка
	rc = RunUpVit() ; RRC ;

	// Заполнение структуры характеризующей виток параметрами
	// движения на момент начала витка.
	// Структура FV в методе RunUpVit() обнуляется.
	memset(&FV, 0, sizeof(FV));
	memcpy(&FV.FSUN, &SI, sizeof(ZSC_SI));	// Кинематические параметры движения
	FV.UN.isFind = true;					// Признак того что элементы движения в ВУ определены
	FV.UN.R = 1e4*FR(SI.ASK1975);			// Радиус в км, высота, 
	FV.UN.H = SI.THBLFR[1];					// широта... в градусах
	FV.UN.B = SI.THBLFR[2];
	FV.UN.L = SI.THBLFR[3];
	FV.UN.t = SI.ta;						// Атомное время
	FV.UN.ute = TO_GRAD(SI.OSKTE[5]);		// Арг. шир. КА в текущей эпохе
	FV.UN.tmssvv = SI.tmss;					// Местное 

	FV.Td = FV.UN.t;
	FV.dL = FV.UN.L;
	double osk_a = SI.OSKTE[0];
	double osk_e = SI.OSKTE[1];
	double Rmin = osk_a*(1 - osk_e);
	double Rmax = osk_a*(1 + osk_e);
	FV.HAvr = 1e4*((Rmin + Rmax) / 2.0 - k_rcp);

	//---------------------------------------------------------------------------
	// Прогнозирование параметров движения до заданного витка
	// с точностью до шага
	while (1) {
		// Один шаг с автоматическим выбором его величины
		rc = GoStepA(nullptr, dir) ; if (rc) goto end ;
		// Текущие параметры на момент конца выполненного шага и
		// контроль завершения витка
		Vitt = GetVitok(sk) ;			// Текущий виток 
		tt   = GetTime() ;				// Текущее время
		Zt   = KoordVitSK(nullptr, sk) ;	// Текеущая координата, определяющая момент смены номера витка
		if (Vitt>=Vitk) break ;			// Условие достижения заданного витка
		tp   = tt ;
		Zp   = Zt ;
	}

	// Точный выход конец заданного витка (т.е. на начало следующего)
	rc = ZMSC::ClarifyVit(&SI, tp, Zp, tt, Zt, false, sk) ; if (rc) goto end ;	
	// кинематические параметры на точный момент завершения витка
	memcpy(&FV.FSTE, &SI, sizeof(ZSC_SI));

	// Событие "выход на момент начала витка" следующего за витком вдоль которого
	// требовалось выполнито моделирование является результатом прогноза,
	// поэтому копируем FSE в FSR
	memcpy(&FSR, &FSE, sizeof(FSR)) ;

	// Исчисление интегральных параметров витка
	FV.Td  = k_cbc*(GetTime()-FV.Td) ;				// Драконический период 
	FV.dL  = SI.THBLFR[3]-FV.dL ;						// Межвитковый сдвиг трассы в ВУ
	FV.dL  = FV.dL> 180?(FV.dL-360):FV.dL ;
	FV.dL  = FV.dL<-180?(FV.dL+360):FV.dL ;	
	FV.Ks  = (short)floor(360.0/fabs(FV.dL)+0.5) ;	// Колличество витков в сутки
	FV.dLs = ValiDA(FV.dL*FV.Ks, 1) ;				// Суточный сдвиг трассы
	osk_a = SI.OSKTE[0] ;
	osk_e = SI.OSKTE[1] ;
	Rmin  = osk_a*(1-osk_e) ;
	Rmax  = osk_a*(1+osk_e) ;

	//ZSC_VP* VPHMIN = HMIN_VI(FV) ; 
	//ZSC_VP* VPHMAX = HMAX_VI(FV) ; 
	//FV.HAvr = (VPHMIN->H+VPHMAX->H)/2.0 ;
	//FV.HAvr= 1e4*(pow(FV.Td/k_cbc/k_dwapi, 2.0/3.0)*pow(k_b0, 1.0/3.0)-k_rcp) ; 
	FV.HAvr = 1e4*((Rmin+Rmax)/2.0-k_rcp) ;

	if (SizeExtEq) {
		double ExtEqRezult[EXTEQ_MAXCOUNT] ;
		ExternalEquationsOff(ExtEqRezult) ;
		double Td = FV.Td/k_cbc ;
		for (int i=0; i<SizeExtEq; i++) {
			unsigned int IDExt = ExtEqDef.ID[i] ;
			switch(IDExt) { 
			case EXTEQ_ID_avrT_H : FV.HAvr  = ExtEqRezult[i]/Td ; break ;
			case EXTEQ_ID_avrT_ex: FV.exAvr = ExtEqRezult[i]/Td ; break ;
			case EXTEQ_ID_avrT_ey: FV.eyAvr = ExtEqRezult[i]/Td ; break ;
			case EXTEQ_ID_avrT_ix: FV.ixAvr = ExtEqRezult[i]/Td ; break ;
			case EXTEQ_ID_avrT_iy: FV.iyAvr = ExtEqRezult[i]/Td ; break ;
	}	}	}
end : ;
	CompletVit() ;
	return rc ;
}

//-------------------------------------------------------------------------------
double ZMSC::KoordVit(double* pX) 
{
	double* X = (pX ? pX:(&((*this)[1]))) ;
	//double* X = (pX ? pX:&FSC.ASK1975[0]) ;
	// Базовая плоскость 0 - экватор, 1 - XOZ, 2 - YOZ
	return (KA.bpl==1 ? X[1]:X[KA.bpl==2?0:2]) ;
}

//-------------------------------------------------------------------------------
double ZMSC::KoordVVit(double* pX) 
{
	double* X = (pX ? pX:(&((*this)[1]))) ;
	//double* X = (pX ? pX:&FSC.ASK1975[0]) ;
	// Базовая плоскость 0 - экватор, 1 - XOZ, 2 - YOZ
	return (KA.bpl==1 ? X[4]:X[KA.bpl==2?3:5]) ;
}

//-------------------------------------------------------------------------------
double ZMSC::KoordVitSK(ZSC_SI* SI, SK_TYPE sk ) 
{
	if (!SI) SI = &FSC ;
	double* X ;
	switch(sk) {
		case _SK_ASK1975 : X = SI->ASK1975 ; break ;
		case _SK_ASK2000 : X = SI->ASK2000 ; break ;
		case _SK_ASKTE   : X = SI->ASKTE ; break ;
		case _SK_ASKTES  : X = SI->ASKTES ; break ;
		default: return 0 ;
	}
	return(KoordVit(X)) ;
}

//-------------------------------------------------------------------------------
double ZMSC::KoordVVitSK(ZSC_SI* SI, SK_TYPE sk) 
{
	if (!SI) SI = &FSC ;
	double* X ;
	switch(sk) {
		case _SK_ASK1975 : X = SI->ASK1975 ; break ;
		case _SK_ASK2000 : X = SI->ASK2000 ; break ;
		case _SK_ASKTE   : X = SI->ASKTE ; break ;
		case _SK_ASKTES  : X = SI->ASKTES ; break ;
		default: return 0 ;
	}
	return(KoordVVit(X)) ;
}

//-------------------------------------------------------------------------------
void ZMSC::PreTestVit() 
{
	TestVit75Z0 = KoordVit(FSC.ASK1975) ;
}

//-------------------------------------------------------------------------------
void ZMSC::TestVit() 
{
	double Z0 = TestVit75Z0 ;
	double Z1 = KoordVit() ;
	int dir = GetDirect() ;
	if (dir<0) { if (Z0>=0 && Z1<0) Vitok75-- ; }
	else { if (Z0<0 && Z1>=0) Vitok75++ ; }
}

//-------------------------------------------------------------------------------
long ZMSC::VitSK( double* Ask1, long Vit1, double* Ask2 ) 
{
	long   Vit2 = Vit1 ;
	double Z1  = KoordVit ( Ask1 ) ;
	double VZ1 = KoordVVit( Ask1 ) ;
	double Z2  = KoordVit ( Ask2 ) ;
	if (Z1< 0.0 && Z2>=0.0 && VZ1>0.0) Vit2++ ;
	if (Z1>=0.0 && Z2< 0.0 && VZ1>0.0) Vit2-- ;
	return Vit2 ;
}

//-------------------------------------------------------------------------------
int ZMSC::TestEpsVit(SK_TYPE sk1, double* X1, long Vit1, SK_TYPE sk2, double* X2, long& Vit2) 
{
	double e1, e2, V1=1.0 ;
	// Значение контрольной величины для смены витка 
	// в исходной системе координат
	switch(sk1) {
		case _SK_GSK : 
		case _SK_ASK1975 : 
		case _SK_ASK2000 : 
		case _SK_ASKTE   : 
		case _SK_ASKTES  : 
			e1 = KoordVit(X1) ; 
			V1 = KoordVVit(X1) ; 
			break ;
		case _SK_OSK1975 : 
		case _SK_OSK2000 : 
		case _SK_OSKTE   : 
		case _SK_OSKTES  : 
			e1 = ValiDA(X1[5], 0) ; 
			V1 = (e1>k_polpi && e1<k_t2pi) ? -1.0:1.0 ;
			break ;
		default: assert(0) ;
	}
	// Значение контрольной величины для смены витка 
	// в конечной системе координат
	switch(sk2) {
		case _SK_GSK : 
		case _SK_ASK1975 : 
		case _SK_ASK2000 : 
		case _SK_ASKTE   : 
		case _SK_ASKTES  : 
			e2 = KoordVit(X2) ; 
			break ;
		case _SK_OSK1975 : 
		case _SK_OSK2000 : 
		case _SK_OSKTE   : 
		case _SK_OSKTES  : 
			e2 = ValiDA(X2[5], 0) ; 
			break ;
		default: assert(0) ;
	}
	// Поправка к значению витка
	int dV = 0 ;
	if (V1>0 && e1*e2<=0) {
		if (e1>=0 && e2<0) dV =-1 ;
		else {
			if (e1<0 && e2>=0) dV = 1 ;
	}	}
	// Новое значение витка
	Vit2 = Vit1+dV ;
	return dV ;
}

//-------------------------------------------------------------------------------
// Проверка того находится ли МД в ВУ или в НУ
int ZMSC::CheckVitEvent(ZSC_SI* SI, bool fronNUZ, SK_TYPE sk)  
{
	// Проверка необходимости расчета
	// Возможно ранее уже было обнаружено событие начала данного витка
	if (!fronNUZ) { 
		// Если проверяется начало витка то выполняется проверка
		// наступления события "выход на начало витка" или "прохождение
		// восходящего узла орбиты" на последнем шаге интегрирования.
		// Данные об этих собятиях, если одно из них имело место быть на 
		// предыдущем шаге, находятся в структуре FSE
		if (FSE.E.ID==ModEvent_ONVIT || FSE.E.ID==ModEvent_VITVU) {  
			// Если задан адрес структуры параметров дижения, то 
			// параметры движения на момент наступления события копируются
			// в данную структуру.
			if (SI) memcpy(SI, &FSE, sizeof(ZSC_SI)) ;
			// Если на шаге имело место событие ModEvent_ONVIT или 
			// ModEvent_VITVU, значит модель движения находится в состоянии
			// начала витка. Если решалась задача выхода на начало 
			// витка, то FSE = FSR. 
			// Возврат признака обнаружения проверяемого состояния МД.
			return 1 ;
		}
	} else {
		// Если проверяется факт пересечения нисходящего узла орбиты,
		// то это означает, что проерке подвергается условие 
		// наличия события ModEvent_VITVU
		if (FSE.E.ID==ModEvent_VITVU) {  
			// Копируются параметры движения соотыетствующие моменту
			// пересечения нисходящего узла, если это конечно необходимо
			if (SI) memcpy(SI, &FSE, sizeof(ZSC_SI)) ;
			// Возврат признака обнаружения проверяемого состояния МД.
			return 1 ;
		}
	}

	//---------------------------------------------------------------------------
	// Возможно начало витка не было обнаружено но текущие параметры движения
	// соответствуют, с точностью до допустимой погрешности, именно началу 
	// заданного витка. Подобное может быть если были заданы НУ на момент 
	// начала витка и прогнозирование на начала витка данной функцией есть 
	// первая операция моделирования движения КА от этих НУ. 
	//---------------------------------------------------------------------------
	long   Vitn = GetVitok(sk);			// Текущее значение витка.
	double Zt   = KoordVitSK(nullptr, sk) ;// Значение координаты, смена знака 
										// которой определяет начало витка.
	double V = KoordVVitSK(nullptr, sk) ;	// Скорость изменения данной координаты.
	double epsZ = 1e-6/1e4 ;			// Точность по координате.
	// Проверка нисходящего узла. 
	if (fabs(Zt)<epsZ && V<0 && fronNUZ) {
		// Считаем событие "пересечение нисходящего узла" обнаруженным.
		// Формирование структуры параметров движения соответствующей событию.
		memcpy(&FSE, &FSC, sizeof(ZSC_SI)) ; 
		FSE.E.ID    = ModEvent_VITNU ;
		FSE.E.Value = (double)Vitn ;
		FSE.E.Value2 = FSE.E.Value3 = FSE.E.Value4 = 0.0 ;
		FSE.E.Value5 = 0 ;
		// Если задан адрес структуры параметров дижения, то 
		// параметры движения на момент наступления события копируются
		// в данную структуру.
		if (SI) memcpy(SI, &FSE, sizeof(ZSC_SI)) ;
		// Событие обнаружено.
		return 1 ;
	}
	// Проверка восходящего узла
	// Либо чуть выше экватора, либо чуть ниже и при этом dZ/dt>0...
	if (V>0 && !fronNUZ && ((Zt>=0 && Zt<epsZ) || (Zt<0 && Zt>-epsZ))) {
		// ВУ витка - начало заданного витка
		long Vitk = Vitn ;
		if (Zt<0) { 
			// ВУ витка - конец предыдущего витка
			// В рамках проекти считается что виток начинается в момент когда
			// u>=0 ну или Z>=0. То есть виток это когда u принадлежит интервалу
			// [0, 2*pi). Поэтому.
			// !!!! В случае "чуть ниже экватора" обнуляем координату Z
			// в ГСК и АСК текущей эпохи и номер витка увеличиваем на 1. 
			// Делать такое с вычислительной точки зрения не совсем корректно, 
			// но... !!!!
			// Иными словами корректируем текущие (FSC) параметры движения.
			Vitk++ ;
			FSC.VitTE    = Vitk ;
			FSC.ASKTE[2] = 0.0 ;
			FSC.GSK[2]   = 0.0 ;
			if (FSC.E.ID!=ModEvent_INIT) FSC.E.ID = ModEvent_VITVU ;
			FSC.E.Value = (double)Vitk ;
			FSC.E.Value2 = FSC.E.Value3 = FSC.E.Value4 = 0.0 ;
			FSC.E.Value5 = 0 ;
			FSC.E.ta    = FSC.ta ;
		}
		// Считаем событие "пересечение восходящего узла" обнаруженным.
		// Формирование структуры параметров движения соответствующей событию.
		memcpy(&FSE, &FSC, sizeof(ZSC_SI)) ; 
		FSE.E.ID = ModEvent_ONVIT ;
		// Если задан адрес структуры параметров дижения, то 
		// параметры движения на момент наступления события копируются
		// в данную структуру.
		if (SI) memcpy(SI, &FSE, sizeof(ZSC_SI)) ;
		return 1 ;
	}	
	// Если задан адрес структуры параметров дижения, то 
	// несмотря на то что проверяемые события не обнаружены,  в данную 
	// структуру копируются текущие параметры движения.
	if (SI) memcpy(SI, &FSC, sizeof(ZSC_SI)) ;
	// Собитий пересечения экватора не обнаружено
	return 0 ;
}

//-------------------------------------------------------------------------------
// Прогнозирование параметров движения до заданного витка (ВУ или НУ)
//	 Vk		-	заданный виток на который необходимо выйти
//	 idsk	-	указывает относительно какого экватора отсчитываются витки и 
//				и может принимать значения IDSK_ASKTE, IDSK_ASK2000, IDSK_ASK1975
//   fronNUZ-	признак расчета для НУ	
// Модель движения останавливается таким образом что координата Z имеет некоторое
// пренебрежимо малое но всегда положительное значение т.е.
// Zk принадлежит промежутку [0, +e] ;
int ZMSC::GoToVit(long Vk, ZSC_SI* _SI, bool fronNUZ, SK_TYPE sk)
{
	// Результаты прогнозирования параметров движения
	ZSC_SI SI ;
	int    rc ;

	// Для учёта программ управления движением центра масс, если
	// таковые имеют место быть (созданы, описаны, заданы все их параметры),
	// инициализируем диспетчер программ управления MPU
	MPU.Init() ;

	// Текущий виток
	// !!!! Если на предыдущем шаге было обнаружено событие, !!!!
	// то возвращается виток данного события
	long Vn = GetVitok(sk);

	//---------------------------------------------------------------------------
	// Проверка необходимости расчета
	// Возможнж ранее уже было обнаружено событие начала данного витка
	if (CheckVitEvent(_SI, fronNUZ, sk)) {
		Vn = GetVitok(sk);
		if (Vn==Vk) return 0 ;
	}

	//---------------------------------------------------------------------------
	// Далее собственно прогнозируем по шагам до ВУ или НУ витка
	// и уточняем найденное событие
	//---------------------------------------------------------------------------

	long   Vt = Vn ;
	// Если патаметры движения на текущем и предыдущем шаге 
	// рассчитаны (...E.ID!=ModEvent_EMPTY)
	// Текущие и предыдущие виток, время и координата Z
	// Время
	double tc = FSC.ta ;
	double tp = FSP.E.ID!=ModEvent_EMPTY ? FSP.ta : tc ;
	// Координата Z
	double Zc = KoordVitSK(&FSC, sk) ;
	double Zp = FSP.E.ID!=ModEvent_EMPTY ? KoordVitSK(&FSP, sk) : Zc ;
	// Виток
	long   Vc = GetVitok(sk, &FSC) ;
	long   Vp = FSP.E.ID!=ModEvent_EMPTY ? GetVitok(sk, &FSP) : Vc ;

	//---------------------------------------------------------------------------
	// Проверка необходимости прогнозирования.
	// Требуемый восходящий или нисходящий узел орбиты может находиться между
	// точками орбиты полученными на текущем и предыдущем шагах.
	// В таком случае требуется только процедура уточнения момента
	// времени соответсвенно начала или конца витка (ClarifyVit).
	bool notPredict = false ;
	if(FSC.E.ID!=ModEvent_EMPTY && FSP.E.ID!=ModEvent_EMPTY) {
		if (fronNUZ) {
			// Проверка для нисходящего узла
			if (Vt==Vk) {
				// Если было интегрирование вперёд
				// Если время текущего шага FSC.ta больше чем 
				// время предыдущего FSP.tp, то значит имело место
				// интегрирование СДУ вперёд.
				// FSC.ta = FSC.tp + h ;
				if (tc>tp && Zp>0 && Zc<=0) notPredict = true ;
				// Если было интегрирование назад
				// FSC.ta = FSC.tp - h ;
				if (tc<tp && Zp<0 && Zc>=0) notPredict = true ;
			}
		} else {
			// Проверка для восходящего узла
			// Если было интегрирование вперёд
			// FSC.ta = FSC.tp + h ;
			if (tc>tp && Vp<Vk && Vc>=Vk) notPredict = true ;
			// Если было интегрирование назад
			// FSC.ta = FSC.tp - h ;
			if (tc<tp && Vc<Vk && Vp>=Vk) notPredict = true ;
		}
		// если notPredict = true, то прогнозировать движение КА для определения
		// момента пересечения экватора с точностью до шага не нужно,
		// искомое пересечение экватора имело место в пределах последнего
		// шага интегрирования СДУ.
	}

	//---------------------------------------------------------------------------
	// Прогноз параметров движения для отыскания восходящего или 
	// нисходящего витка с точностью до шага интегрирования
	if (!notPredict) {
		//-----------------------------------------------------------------------
		// Определяем направление прогнозирования (вперёд или назад)
		int dir = Vk>Vn?1:(Vk<Vn?-1:(fronNUZ?(Zc>0?1:-1):-1)) ;
		// Прогнозирование параметров движения до заданного витка
		// с точностью до шага
		while (1) {
			rc = GoStepA(&SI, dir) ; RRC ;
			Vt = GetVitok(sk) ;
			tc = GetTime() ;
			Zc = KoordVitSK(nullptr, sk) ;
			if (fronNUZ) {
				if (Vt==Vk) {
					if (dir>0 && Zc<=0 && Zp>0) break ;
					if (dir<0 && Zc>=0 && Zp<0) break ;
				}
			} else {
				if (dir>0 && Vt>=Vk) break ;
				if (dir<0 && Vt< Vk) break ;
			}
			tp = tc ;
			Zp = Zc ;
	}	}

	//---------------------------------------------------------------------------
	// Точный выход в заданную точку
	rc = ClarifyVit(&SI, tp, Zp, tc, Zc, fronNUZ, sk) ; RRC ;
	if (_SI) memcpy(_SI, &SI, sizeof(ZSC_SI));
	// Событие "выход на момент начала витка" или "прохождение нисходящего узла"
	// одновременно является результатом прогноза, поэтому копируем FSE в FSR
	memcpy(&FSR, &FSE, sizeof(FSR)) ;

	return 0 ;
}

//-------------------------------------------------------------------------------
// Моделирование движения КА до момента пересечения заданного аргумента
// широты Uk на витке Vk, аргумент широты отсчитывается от экватора в чистеме
// координат sk.
// Результат вычислений в виде параметров движения записывается по адресу
//										RSI, если он не нулевой, 
// а также в поле текущих параметров	FSC,
// и поле результатов модели			FSR. 
int ZMSC::GoToVitU(long Vk, double Uk, ZSC_SI* RSI, SK_TYPE sk)
{
	// Точность уточнения по аргументу широты в радианах
	double epsU = 1e-7 ;
	// Максимальное число итераций уточнения
	int MaxCountIter = 100 ;
	int rc = 0 ; 

	// Перевод конечного (требуемого) аргумента широты из градусов в радианы
	Uk = TO_RAD(Uk) ; 
	
	// Виток на текущем и предыдущем шаге
	long   Vc = GetVitok(sk, &FSC) ;
	long   Vp = FSP.E.ID!=ModEvent_EMPTY ? GetVitok(sk, &FSP) : Vc ;
	// Аргумент широты на текущем и предыдущем шаге
	double Uc = GetU(sk, &FSC) ;
	double Up = FSP.E.ID!=ModEvent_EMPTY ? GetU(sk, &FSP) : Uc ;
	// Отклонение заданного аргумента широты Uk от значений
	// на текущем и предыдущем шаге.
	double dUc= (Vk-Vc)*k_dwapi+(Uk-Uc) ;
	double dUp= FSP.E.ID!=ModEvent_EMPTY ? (Vk-Vp)*k_dwapi+(Uk-Up) : dUc ;
	// Время на текущем и предыдущем шаге.
	double tc = FSC.ta ;
	double tp = FSP.E.ID!=ModEvent_EMPTY ? FSP.ta : tc ;
	// Направление отшагивания
	int dir= dUc>=0?1:-1 ;

	MPU.Init() ;

	// Проверка необходимости прогнозирования.
	// Требуемый аргумент широты может находиться между
	// точками орбиты полученными на текущем и предыдущем шагах.
	// В таком случае требуется только процедура уточнения момента
	// времени, соответствующего заданному аргументу широты
	if(FSC.E.ID!=ModEvent_EMPTY && FSP.E.ID!=ModEvent_EMPTY) {
		// Если патаметры движения на текущем и предыдущем шаге 
		// рассчитаны (...E.ID!=ModEvent_EMPTY)
		//
		// Проверка условия попадания заданного аргумента широты Uk в 
		// интервал между значениями аргумента широты на текущем и 
		// предыдущем шаге [Up, Uc]
		if (dUp*dUc<=0) {
			// Если условие верно, то прогнозирование не нужно,
			// значит нужно непосредственно перейти к уточнению момента времени,
			// соответствующего Uk
			//
			// !!!! В логике интегратора была заложена ошибка следующего характера !!!! 
			// Если не предыдущем шаге интегрирования было найдено "Событие" и структура
			// FSE заполнена то процедура "отшагивания назад" (BackStep) в качестве 
			// текущего состояния воспринимает данные именно из FSE, а не из FSC, 
			// как это должно быть.
			// Поэтому перед уточнением нового события - выход на заданный аргумент 
			// широты - обнулим информацию о рпанее найденном событии
			// memset(&FSE, 0, sizeof(FSE)) ;
			// !!!! Данная проблема требует своего корректного решения !!!!
		}
		// Данная проверка необходима для того случая когда необходимо выполнить прогноз
		// с достаточно малым шагом по аргументу широты, иными словами когда 
		// в одном шаге интегрирования по времени содержится более одного значения
		// необходимых аргументов широты.
		// В результате сделав один шаг интегрирования, в пределах этого шага 
		// уточняем несколько (более одного) событий выхода на заданные значения 
		// аргумента широты. Для этого несколько раз обращаемся к настоящей функции
		// с различными значениями Vk и Uk.
	}

	//---------------------------------------------------------------------------
	// Прогнозирование параметров движения до заданного витка и аргумента
	// с точностью до шага, если это необходимо
	if (dUp*dUc>0) {
		while ( 1 ) {
			// Один шаг интегрирования СДУ движения КА по времени 
			// с автомитическим выбором шага	
			rc = GoStepA(nullptr, dir) ; RRC ;
			// Текущий виток
			Vc = GetVitok(sk, &FSC) ;
			// Текущий аргумент широты
			Uc = GetU(sk, &FSC) ;
			// Текущие значения (время и невязка аргумента широты) 
			// становятся предыдущими
			dUp= dUc ;
			tp = tc ;
			// Новые текущие значения времени и невязки аргумента широты. 
			// Отклонение положения на орбите от требуемого, заданного Vitk и Uk
			dUc= (Vk-Vc)*k_dwapi+(Uk-Uc) ;
			// Текущее время
			//tc = GetTime() ;
			tc = FSC.ta ;
			// Проверка условия завершения прогноза
			if (dUp*dUc<=0) break ;
	}	}

	//---------------------------------------------------------------------------
	// Точный выход в заданную точку
	//---------------------------------------------------------------------------

	// Сохраняем состояние модели движения
	// (только интегрируемый вектор)
	FastStory() ;

	int    CountIter = 0 ; 
	double dU, t, ht ;
	double dUs = 0 ;
	ZSC_SI SI ;
	// Итерации по уточнению аргумента широты - собственно точный выход 
	// !!!! Плохая сходимость по аргументу широты !!!!
	while (1) {
		// Значени величины отшагивания от текущего состояния (FSC)
		// с учётом невязки dUs. 
		ht = (dUc+dUs)/(dUp-dUc)*(tc-tp) ;
		// отшагивание назад по времени на ht
		rc = BackStep(&SI, ht, ModEvent_ONARG) ; RRC ;
		// Текущие виток, аргумент широты и время
		// Всё берётся из структуры FSE (событие - отшагивание)
		double Vt = GetVitok(sk, &SI) ;
		double Ut = GetU(sk, &SI) ;
		t  = SI.ta ;
		// Восстановление состояния модели движения (исходное положение).
		// После восстановления внутренне состояние интегратора (m_a) 
		// соответствует структуре данных результатов текущего шага (FSC)
		FastReStory() ;
		// Невязка - отклонение положения на орбите от требуемого, 
		// заданного Vitk и Uk
		dU = (Vk-Vt)*k_dwapi+(Uk-Ut) ; 
		// Проверка условия завершения итераций
		// Необходимо уточнить момент, соответствующий Uk с точностью
		// до epsU 
		if (fabs(dU)<epsU) break ;
		// Увеличение счётчика числа итераций
		CountIter++ ;
		if (CountIter>MaxCountIter) { 
			// Итераций не может быть слишком мнго,
			// иначе в вычислительном процессе имеется та или иная ошибка
			AddErrorMSG( "Ошибка прогноза. При уточнении времени заданного витка и аргумента широты превышено допустимое число итераций" ) ; 
			return 1 ;
		}
		// Суммарная невязка для решения задачи уточнения момента времени,
		// соответствующего заданному аргументу широты Uk, методом Промаха.
		dUs+= dU ;
	}
	// Числовые характеристики события (выхода на заданный аргумент и виток)
	// Всё берётся из структуры FSE (событие - отшагивание)
	FSE.E.Value = GradA(GetU(sk)) ;
	FSE.E.Value2= GetVitok(sk) ; 
	FSE.E.Value3= sk ;
	// Событие "выход на заданный аргумент" одновременно является 
	// результатом прогноза, поэтому копируем FSE в FSR
	memcpy(&FSR, &FSE, sizeof(FSR)) ;
	if (RSI) memcpy(RSI, &FSE, sizeof(FSR)) ;

	return rc ;
}

//-------------------------------------------------------------------------------
// Уточнение момента начала витка или момента прохождения нисходящего узла
// если fronNUZ==true 
int ZMSC::ClarifyVit(ZSC_SI* SI, double tp, double Zp, double tt, double Zt, bool fronNUZ, SK_TYPE sk)
{
	int    rc = 0 ;
	double epsZ = 1e-6/1e4 ;		// Точность по координате
	double epsT = 0.001/86400.0 ;	// Точность по времени
	int    MaxCountIter = 100 ;

	// Сохраняем состояние модели движения
	// (только интегрируемый вектор)
	FastStory() ;

	// Уточняем момент начала витка
	int CountIter = 0 ; 
	double t, dht, ht = 0, dZ = Zt ;

	while (1) {
		// Текущая поправка ко времени начала витка, на данной итерации
		dht= dZ/(Zp-Zt)*(tt-tp) ;
		// Уточняем время начала витка. Суммарная поправка
		ht+= dht ;
		// Подшагивание до уточнённого времени начала витка
		rc = BackStep(SI, ht, fronNUZ?ModEvent_VITNU:ModEvent_ONVIT) ; if (rc) goto end ;
		// Координата Z
		dZ = KoordVitSK(SI, sk) ;
		// Расчётное время начала витка
		t  = SI->ta ;
		// Изменение интервала - смещение левой или правой границы 
		if (dZ*Zt>= 0) { Zt = dZ ; tt = t ; }
		else { Zp = dZ ; tp = t ; }
		// Проверка условия сходимости 
		if (fabs(dZ)<epsZ || fabs(dht)<epsT) {
			// Контролируемый параметр должен быть немного больше нуля
			// !!! Только для восходящего узла !!!
			if (dZ<0 && !fronNUZ) {
				// Если он отцательный то подшагиваем немного вперёд
				// Определяем поправку ко времени исходя из значения координаты Z
				dht= dZ/(Zp-Zt)*(tt-tp) ;
				// Поправку удваиваем, чтоб из малого отрицательного значения получить 
				// такое же малое положительное значение координаты Z
				ht+= 2*dht ;
				// Восстанавливаем состояние модели
				FastReStory() ;
				// Отшагиваем назад
				rc = BackStep(SI, ht, fronNUZ?ModEvent_VITNU:ModEvent_ONVIT) ; if (rc) goto end ;
				dZ = KoordVitSK(SI, sk) ;
			}
			break ;
		} 
		// Увеличиваем счётчик числа итераций
		CountIter++ ;
		// Контроль колличества итераций
		if (CountIter>MaxCountIter) { 
			AddErrorMSG( "Ошибка прогноза. При уточнении времени заданного витка превышено допустимое число итераций" ) ; 
			rc =-2 ; goto end ; 
		} 
		// Воостанавливаем состояние МД на момент последнего (ло уточнения) шага
		// (только интегрируемый вектор)
		FastReStory() ;
	}
end: ;	 
	// Восстанавливаем состояние модели
	FastReStory() ;
	// При успешном завершении процедуры искомый момент начала витка а также
	// все параметры движения на даный момент времени содержатся в структуре 
	// ZSC_SI* SI
	// Состояние модели соответствует состоянию до начала уточнения

	//Проверка корректности формирования события (начало витка)
	if (!fronNUZ) {
		// На начало витка всегда, в рамках настоящего проекта, полагаем
		// координату Z равной пренебрежимо малой положительной величине
		// порядка машинного нуля
		// Данная мера необходима во избежания коллизий и вычислительных
		// ошибок связанных с недостоверным исчислением номера витка
		// вдоль прогнозируемой траектории.
		if (SI->ASKTE[2]<0) {
			// Если это условие не выполняется, тогда принудительно
			// Значение витка увеличивается на единицу
			// а значение аргумента широты обращается в НОЛЬ.
			SI->VitTE++ ;
			SI->ASKTE[2] = 0.0 ;
		}
	}
	// Заполнение характеристик события
	SI->E.Value = (double)SI->VitTE ;
	return rc ;
}

//-------------------------------------------------------------------------------