//-----------------------------------------------------------------------------
// ZCAlgebraicMDF.cpp
// А. Николенко 01.04.2019
//
// Алгебраическая апроксимация (модель) дискретно заданной функции.
// Функция апроксимируется полиномами Чебышёва.
// 
// Предполагается следующее:
//		- аргументом апроксимируемой функции является время,
//		- единицей измерения времени являются среднии солнечные сутки,
//		- при определении дискретной функции время задаётся модифицированной 
//		  юлианской датой,
//		- В пределах модели (полинома) время отсчитывается от нуля 
//		  в юлианских днях.
//-----------------------------------------------------------------------------
#include <stdafx.h>

#include <FlyChebyshov.h>
#include <FlyCoreSource\\ZCAlgebraicMDF.h>

//-----------------------------------------------------------------------------
// Оператор сравнения полиномиальных моделей для возможности сортировки 
// их массива.
bool operator < (const ZCAlgebraicMDF& M1, const ZCAlgebraicMDF& M2)
{
	if (M1.begTime < M2.begTime) return true;
	return 0;
}

//-----------------------------------------------------------------------------
ZCAlgebraicMDF::ZCAlgebraicMDF() 
{
	// Обнуляем все атрибуты модели
	Clr();
}

//-----------------------------------------------------------------------------
// Конструктор копирования 
ZCAlgebraicMDF::ZCAlgebraicMDF(const ZCAlgebraicMDF& M) 
{
	// Обнуляем все атрибуты модели
	Clr();
	// Просто запускаем процедуру копирования объекта
	Cpy(M);
}

//-----------------------------------------------------------------------------
// Конструктор переноса
ZCAlgebraicMDF::ZCAlgebraicMDF(ZCAlgebraicMDF&& M)
{
	// Обнуляем все атрибуты модели
	Clr();
	// Перенос данных
	Move(M);
}

//-----------------------------------------------------------------------------
// Генерирующий конструктор
ZCAlgebraicMDF::ZCAlgebraicMDF(double* T, double* Y, const int N, const int D)
{
	// Обнуляем все атрибуты модели
	Clr();
	// Проверка корректности исходных данных
	if (!T ) throw 1;
	if (!Y ) throw 2;
	if (N<5) throw 3;
	if (D<2) throw 4;
	// Создание апроксимирующего полинома по Чебвшёву 
	if (Build(T, Y, N, D)) throw 5;
}

//-----------------------------------------------------------------------------
// Оператор копии
ZCAlgebraicMDF& ZCAlgebraicMDF::operator = (const ZCAlgebraicMDF& M)
{
	// Просто запускаем процедуру копирования объекта
	Cpy(M);
	// Возвращаем самого себя
	return (*this);
}

//-----------------------------------------------------------------------------
// Опереатор переноса
ZCAlgebraicMDF& ZCAlgebraicMDF::operator = (ZCAlgebraicMDF&& M)
{
	// Перенос данных
	Move(M);
	// Возвращаем самого себя
	return (*this);
}

//-----------------------------------------------------------------------------
void ZCAlgebraicMDF::Del() 
{
	if (A) delete[] A;
	Clr();
}

//-----------------------------------------------------------------------------
void ZCAlgebraicMDF::Clr()
{
	A = nullptr;
	Degree  = 0;
	begTime = 0;
	endTime = 0;
	isGenerated = false;
}

//-----------------------------------------------------------------------------
// Конструктор копирования 
void ZCAlgebraicMDF::Cpy(const ZCAlgebraicMDF& M)
{
	if (!M.A) {
		// Если модель M не содержит коэффициентов, то this нужно обнулить
		// и память под коэффициенты если они есть освободить 
		if (A) delete[] A;
		// Обнуление всех полей (то есть атрибутов модели this)
		Clr();
		return;
	}

	// Сравниваем размерность полинома если он существует с размерностью
	// модели M.
	if (A && Degree < M.Degree) {
		// Если массив коэффициентов существует но его размер не достаточен
		// для того чтоб скопировать массив коэффициентов из модели M,
		// то A освобождается для дальнейшегог выделения необходимого
		// колличества памяти
		delete[] A; A = nullptr;
	}
	// Если необходимо то выделяем нужное колличество памяти
	if (!A)	A = new double[M.Degree];
	// Копируем коэффициенты модели M
	memcpy(A, M.A, M.Degree*sizeof(double));
	// Копируем все остальные атрибуты модели M
	Degree = M.Degree;
	begTime = M.begTime;
	endTime = M.endTime;
	isGenerated = M.isGenerated;
}

//-----------------------------------------------------------------------------
void ZCAlgebraicMDF::Move(ZCAlgebraicMDF& M)
{
	// Если this чтото и содержал, то данные эти больше не нужны и просто
	// их удаляем.
	Del();
	// Захватываем адрес памяти в которой располагаются коэффициенты
	// модели M.
	A = M.A;
	// Копируем все остальные атрибуты модели M.
	Degree = M.Degree;
	begTime = M.begTime;
	endTime = M.endTime;
	isGenerated = M.isGenerated;
	// Обнуляем все поля модели M.
	M.Clr();
}

//-----------------------------------------------------------------------------
ZCAlgebraicMDF::~ZCAlgebraicMDF()
{
	if (A) delete[] A;
}

//-----------------------------------------------------------------------------
double ZCAlgebraicMDF::Calc(double t) const
{
	double F = A[Degree];
	for (int i = Degree; i>0; i--) F = F*t + A[i - 1];
	return F;
}

bool ZCAlgebraicMDF::IsDomainFrom(double t) const
{
	if (!A || !Degree) return false;
	if (t >= begTime && t <= endTime) return true;
	return false;
}

//-----------------------------------------------------------------------------
int ZCAlgebraicMDF::Build(double* T, double* Y, int N, int D) 
{
	// Проверка корректности исходных данных
	if (!T || !Y || N<5) return-1;
	// При необходимости удаляем созданный ранее массив коэ-ов
	if (A && Degree<D) { delete[] A; A = nullptr; }
	// При необходимости создаём массив коэффициентов
	if (!A) A = new double[D + 1];
	// Степень полинома
	Degree = D;

	// Функция расчета коэфф. Чебышева и их пересчета в коэфф.степенного полинома
	AproxByChebyshevPolinom(T, Y, N, Degree, A);
	// Время начала и время конца интервала в течении которого
	// Модель представленная полиномом является адекватной реальности
	begTime = T[0];
	endTime = T[N - 1];
	// Взводится признак генерации модели
	isGenerated = true;
	return 0;
}

//-----------------------------------------------------------------------------
// Создание с простым выделением памяти без расчёта полинома
int ZCAlgebraicMDF::Create(int D, double TB, double TE) 
{
	if (A && D > Degree) { delete[] A; A = nullptr; }
	if (!A) A = new double[D + 1];
	begTime = TB;
	endTime = TE;
	isGenerated = false;
	return 0;
}

//-----------------------------------------------------------------------------
// Загрузка из двоичного хранилища моделей
int ZCAlgebraicMDF::LoadFromStream(ifstream& f, double TimeFrame) 
{
	if (f.eof()) return-1;
	// Время начала Тайм фрейма
	f.read((char*)(&begTime), sizeof(double));
	// Время конца Тайм фрейма
	endTime = begTime + TimeFrame;
	// Степеннь полинома
	if (f.eof()) return 1;
	f.read((char*)(&Degree), sizeof(int));
	// Массив коэффициентов
	if (f.eof()) return 2;
	if (Create(Degree, begTime, begTime + TimeFrame)) return 3;
	f.read((char*)A, (Degree + 1)*sizeof(double));
	return 0;
}

//-----------------------------------------------------------------------------
// Сохранение в двоичном хранилище моделей
int ZCAlgebraicMDF::StoryToStream(ofstream& f) 
{
	// Время начала Тайм фрейма
	f.write((const char*)(&begTime), sizeof(double));
	// Степень полинома
	f.write((const char*)(&Degree), sizeof(int));
	// Массив коэффициентов
	if (A) {
		f.write((const char*)(A), (Degree + 1)*sizeof(double));
	}
	return 0;
}

//-----------------------------------------------------------------------------