//-------------------------------------------------------------------------------
// ZCEventManager.cpp
// А. Николенко 03.08.2018
//-------------------------------------------------------------------------------
#include <stdafx.h>

#include <FlyMMath.h>	// Математические функции
#include <FlyTime.h>	// Всё про время

#include <FlyCoreSource\\ModType.h>
#include <FlyCoreSource\\ModGlobal.h>
#include <FlyCoreSource\\ZMSpaceCraft.h>
#include <FlyCoreSource\\ModSK.h>
#include <FlyCoreSource\\ZCEventManager.h>
#include <FlyCoreSource\\ZSK.h>
#include <FlyCoreSource\\ZHBL.h>
#include <FlyCoreSource\\ZCalc.h>
#include <FlyCoreSource\\ZNIP.h>

//------------------------------------------------------------------------------- 
// Проверка типа события 
//------------------------------------------------------------------------------- 
// Является ли событие событием Зоны Радиовидимости (засечки характерных точек ЗРВ)
bool IsZRVEvent (ModEventName e){ return (e>=ModEvent_ZRVBEG ? true:false) ; } 
// Является ли событие событием витка (засечки характерных точек витка)
bool IsVITEvent (ModEventName e){ return ((e>=ModEvent_VITVU && e<=ModEvent_SHADOWEND) ? true:false) ; } 
// Является ли событие событием подшагивания
bool IsGOEvent  (ModEventName e){ return ((e>=ModEvent_ONBREAKTIME && e<=ModEvent_ONARG) ? true:false) ; } 
// Является ли событие событием моделирования работы двигательной установки
bool IsDUEvent  (ModEventName e){ return ((e>=ModEvent_DUON && e<=ModEvent_DUOFF) ? true:false) ; } 
bool IsUserEvent(ModEventName e){ return (e>=ID_USEREVENT_FIRST ? true:false) ; } 
bool IsModEvent (ModEventName e){ return ((e>=ModEvent_BEG && e<=ModEvent_END) ? true:false) ; } 

//-------------------------------------------------------------------------------
// Идентификатор события ЗРВ (начало, конец или параметр)
int IDZRVEvent(ModEventName e)
{
	int k = (int)(e-ModEvent_ZRVBEG) ;
	// Определение события: начало, конец или параметр зоны
	ModEventName EN ;
	if ((k/3)*3 == k) EN = ModEvent_ZRVBEG ;
	else EN =((k+2)/3)*3==(k+2) ? ModEvent_ZRVEND : ModEvent_ZRVPARAM ; 
	return EN ;
}

//-------------------------------------------------------------------------------
// Индекс НИПа по событию ЗРВ
int IndNipZRVEvent(ModEventName e) 
{
	int k = (int)(e-ModEvent_ZRVBEG) ;
	return ((int)(k/3)) ;
}

//-------------------------------------------------------------------------------
// Диспетчер событий
//-------------------------------------------------------------------------------
ZCEventManager::ZCEventManager() : ZCEventCase()
{
}

//-------------------------------------------------------------------------------
ZCEventManager::~ZCEventManager()
{
}

//-------------------------------------------------------------------------------
int ZCEventManager::CalcParams(ZMSC* KA, ZSC_SI* SI, int indPar, double* P, double* D)
{
	if (!SI) SI = &KA->FSC ; 
	timet = SI->ta ;

	// Проверка корректности структуры с параметрами движения КА
	if (!SI || SI->E.ID==ModEvent_EMPTY) {
		assert(0) ;
	}

	// При необходимости рассчитываем параметры событий витка
	// начало витка, нисходящий узел, минимальные и максимальные высота и радиус
	if (isNeedTestVit) {
		// Ипользуется поле THBLFR структуры ZSC_SI в котором в том числе хранится
		// информация о параметрах характеризующих события витка: высоты, радусы, 
		// координата витка
		if (indPar<=0 || indPar==ModEvent_VITNU) {
			IP(ModEvent_VITNU) = true ; 
			// Координата смены витка с обратным знаком для контроля события
			// прохождения низходящего узла орбиты
			PutVITParam(indPar, 0,-SI->THBLFR[8], ModEvent_VITNU, P, D) ;
		}

		if (indPar<=0 || (indPar>=ModEvent_HMIN && indPar<=ModEvent_RMAX)) {
			IP(ModEvent_HMIN) = true ; 
			IP(ModEvent_HMAX) = true ; 
			IP(ModEvent_RMIN) = true ; 
			IP(ModEvent_RMAX) = true ; 
			PutVITParam(indPar, SI->THBLFR[1], SI->THBLFR[6], ModEvent_HMIN, P, D) ;
			PutVITParam(indPar, SI->THBLFR[1],-SI->THBLFR[6], ModEvent_HMAX, P, D) ;
			PutVITParam(indPar, SI->THBLFR[5], SI->THBLFR[7], ModEvent_RMIN, P, D) ;
			PutVITParam(indPar, SI->THBLFR[5],-SI->THBLFR[7], ModEvent_RMAX, P, D) ;
	}	}

	// При необходимости рассчитываем параметры ЗРВ
	// Контроль вход в ЗРВ, выход и момента параметра
	if (isNeedTestZRV) {
		bool isZRVEvent = IsZRVEvent((ModEventName)indPar) ;
		if ((indPar<0 && IsNeedTrackingZRV()) || isZRVEvent) {
			double Params[7] ;
			int    i ; 
			int    i0 = isZRVEvent ? IndNipZRVEvent((ModEventName)indPar) : 0 ;
			int    N  = isZRVEvent ? i0+1 : CountNips() ;
			// Перебор по НИПам
			for (i=i0; i<N; i++) {
				IP(ModEvent_ZRVBEG+i*3) = true ; 
				IP(ModEvent_ZRVEND+i*3) = true ; 
				IP(ModEvent_ZRVPARAM+i*3) = true ; 
				// Индекс НИПа в массиве НИПов
				int indNip = INips(i) ;
				// Расчёт параметров взаимного положения НИП-КА
				CalcZRVParams(&ALLNIPS[indNip], SI->GSK, Params) ;
				// Для входа - контрольный параметр - угол места
				// Минимальнодопустимый угол места
				double Gmin = ALLNIPS[indNip].MinGam ;
				CT(ModEvent_ZRVBEG+i*3) = Params[0]-Gmin ;
				PT(ModEvent_ZRVBEG+i*3) = Params[1] ;
				// Для выхода - контрольный параметр - 
				// угол места со знаком минус
				// !!!!! Знак минус нужен так как событие идентифицируется 
				// тогда, когда контрольный параметр переходит из 
				// отрицательной в положительную зону !!!!!!!!
				CT(ModEvent_ZRVEND+i*3) =-(Params[0]-Gmin) ;
				PT(ModEvent_ZRVEND+i*3) =-Params[1] ;
				// Для параметра - контрольный параметр - 
				// скорость изменения угола места со знаком минул
				CT(ModEvent_ZRVPARAM+i*3) =-Params[1] ;
				PT(ModEvent_ZRVPARAM+i*3) = 0 ;
				//
				if (isZRVEvent && D) {
					int ID = IDZRVEvent((ModEventName)indPar) ;
					if (ID==ModEvent_ZRVPARAM) *D =-Params[1] ;
					else {
						if (ID==ModEvent_ZRVEND) *D =-(Params[0]-Gmin) ;
						else *D =(Params[0]-Gmin) ;
					}
	}	}	}	}
	
	return 0 ;
}

//-------------------------------------------------------------------------------
void ZCEventManager::PutVITParam(int indI, double Pc, double Dc, int indC, double* P, double* D) 
{
	if (indI>0 && indI!=indC) return ;
	if (!D || !P) {	PT(indC) = Pc ;	CT(indC) = Dc ; }
	else { *P = Pc ; *D = Dc ; }
}

//-------------------------------------------------------------------------------
// При численном моделировании движения КА может иметь место ситуация когда
// на одном шаге интегрирования наблюдаются все три события: вход выход и параметр.
// При этом на начало шага и на конец шага значение угла места будут меньше 
// минимального значения, как следствие, алгоритм основанный на смене знака 
// контролируемого параметра не сработает. Именно для такого случая и нужна данная 
// функция.
// Признаком ситуации служит засечка параметра с углом места больше минимального,
// то есть грубо говоря, параметр определяется над горизонтом, и одновременно 
// значения угла места на начало и на конец шага интегрирования меньше минимального
// значения, то есть ниже горизонта.
// Функция принудительно генерирует необходимость уточнения начала и конца ЗРВ и 
// вызывает функции OnEvent и OnFullZRV.
//
// Если значение угла места в момент параметра меньше минимального значения, то
// это означает что ЗРВ нет.
int ZCEventManager::TestZRV(ZMSC* KA, ZSC_SI& EVSI, int& i, int& j)
{
	int rc = 0 ;

	// Если событие не является событием ЗРВ, то просто выход
	if (!IsZRVEvent(ie[i])) return 0 ;
	// Тип события ЗРВ (вход, выход, параметр)
	ModEventName en = (ModEventName)IDZRVEvent(ie[i]) ;	

	// Индекс номера НИПа
	int indNum = IndNipZRVEvent(ie[i]) ;
	// Индекс НИПа в массиве характеристик и координат НИП
	int indNip = INips(indNum) ;
	// Номер НИПа
	int NumNip = ALLNIPS[indNip].Num ;
	// Минимальный допустимый угол места
	double Gmin= ALLNIPS[indNip].MinGam ;
	ZZRV*  Z = &ZRV[indNum] ; 

	// Заполнение характеристик ЗРВ соответственно для
	// входа, выхода и параметра ЗРВ
	switch(en) {
		case ModEvent_ZRVBEG:
			// Архивируем характеристики входа в ЗРВ
			Z->Vit= EVSI.VitTE ;
			Z->G1 = EVSI.E.Value ;
			Z->A1 = EVSI.E.Value2 ;
			Z->t1 = EVSI.E.ta ;
			Z->Nip= NumNip ;
			Z->KA = KA->NU.Key.ka ;
			Z->isFound|= 1 ;
			// Архивируем текущие кинематические параметры движения
			memcpy(Z->X, EVSI.ASK1975, 6*sizeof(double)) ;
			Z->X[6] = EVSI.m ;
			//
			PostFindZRV(KA, EVSI, Z) ;
			break ;
		case ModEvent_ZRVPARAM:
			if (EVSI.E.Value<Gmin) {
				// Если угол места на параметре меньше минимально
				// допустимого, то такая ЗРВ игнорируется
				return-1 ;
			} else {
				if (!(Z->isFound&1 || Z->isFound&2) && CP(ie[i]-2)<Gmin && CT(ie[i]-1)<Gmin) {
					// Обнаружена "одношаговая зона"
					// В этом случае ни вход ни выход из ЗРВ на этом шаге 
					// не определяются.
					// Для их нахождения шаг искусственно делится на две части
					//	1 - от начала шага до параметра
					//  2 - от параметра до конца шага
					// В каждой из этих частей тогда возможно определить 
					// соответственно вход и выход из ЗРВ

					//-----------------------------------------------------------
					// Время от параметра до конца шага
					double Gmax = EVSI.E.Value ;
					double tp   = EVSI.E.ta ;
					double dh   = timet-tp ; 

					// timet     - время на текущем шаге интегрирования из данных
					//             из данных диспетчера событий 
					//             ZCEventCase ==> ZCEventManager.
					// EVSI.E.ta - Время обнаруженного и уточнённого события (параметрт).
					//             EVSI - структура с элементами движения КА на момент события
					//             EVSI.E - структура с характеристиками события
					//             Именно время EVSI.E.ta сохраняется в характеристиках ЗРВ
					//             как время прохождения параметра Z->tp.

					//-----------------------------------------------------------
					// Засечка момента входа в ЗРВ

					// Сохраняем значение угла места в конце шага
					// ie[i]   - идентификатор события - параметр
					// ie[i-1] - идентификатор события - выход изи ЗРВ
					// ie[i-2] - идентификатор события - вход в ЗРВ
					// На момент обнаружения одношаговой ЗРВ 
					// ie[i-1] = ie[i-2] = ModEvent_EMPTY, то есть вход и выход не 
					// обнаружены - в этом и есть суть одношаговой ЗРВ
					double OldCT = CT(ie[i]-2) ;
					double oldtt = timet ;
					// Моделируем условия возникновения события - вход в ЗРВ
					//
					// Фактически принудително разбиваем шаг точкой параметра на две части
					// и вводим два события - начало и конец ЗРВ - те события которые на шаге
					// интегрирования засечь по прямому признаку изменения знака контролируемого
					// параметра не удалось.
					// На начало шага угол места ниже горизонта, на параметре - выше, следовательно
					// имеет место засечка события начала ЗРВ
					// Аналогично для конца ЗРВ...
					CT(ie[i]-2) = Gmax-Gmin ;			// Значение контролируемого параметра
					timet = tp ;						// Время
					ie[j] = (ModEventName)(ie[i]-2) ;	// Новое "фиктивное" событие - начало ЗРВ 
					// Уточняем момент входа в ЗРВ
					ZSC_SI SI ;
					rc = ClarifyEvent(KA, ie[j], &SI, &dh) ; RRC ;
					// Отменяем моделирование условий возникновения события - вход в ЗРВ
					CT(ie[i]-2) = OldCT ;		// Восстанавливаем значение угла места на конец шага
					timet = oldtt ;				// Восстанавливаем текущее время
					ie[j] = ModEvent_EMPTY ;	// Обнуляем идентификатор "фиктивного" события
					// Если не "обнулить" идентификатор "фиктивного" события, то при завершении функции
					// и выходе из неё в цыкле уточнения обнаруженных событий, вход в 
					// ЗРВ будет уточняться повторно, что приведёт к ошибке!!!!
					//
					// Архивируем характеристики входа в ЗРВ
					Z->Vit= SI.VitTE ;
					Z->G1 = SI.E.Value ;
					Z->A1 = SI.E.Value2 ;
					Z->t1 = SI.E.ta ;
					Z->Nip= NumNip ;
					Z->KA = KA->NU.Key.ka ;
					Z->isFound|= 1 ;
					// Архивируем текущие кинематические параметры движения
					memcpy(Z->X, SI.ASK1975, 6*sizeof(double)) ;
					Z->X[6] = SI.m ;
					// Вызов функции для реакции на вход в ЗРВ
					KA->OnEvent(SI.E, &SI) ;
					j++ ; 

					//-----------------------------------------------------------
					// Фиксируется факт прохождения параметра
					// Архивируем характеристики прохождения параметра ЗРВ
					Z->Gmax = EVSI.E.Value ;
					Z->Ap   = EVSI.E.Value2 ;
					Z->tp   = EVSI.E.ta ;
					Z->isFound|= 2 ;
					// Вызов функции для реакции на достижение параметра
					KA->OnEvent(EVSI.E, &EVSI) ;

					//-----------------------------------------------------------
					// Засечка момента выхода из ЗРВ

					// Сохраняем значение угла места на начало шага
					double OldCP = CP(ie[i]-1) ;
					double oldtp = timep ;
					// Моделируем условия возникновения события - выход из ЗРВ
					CP(ie[i]-1) =-(Gmax-Gmin) ;
					timep = tp ;
					ie[j] = (ModEventName)(ie[i]-1) ; 
					// Уточняем момент выхода из ЗРВ
					rc = ClarifyEvent(KA, ie[j], &SI, nullptr) ; RRC ;
					// Отменяем моделирование условий возникновения события - выход из ЗРВ
					CP(ie[i]-1) = OldCP ;	  // Восстанавливаем значение угла места и время на начало шага
					timep = oldtp ;			  // Восстанавливаем время на начало шага
					ie[j] = ModEvent_EMPTY ;  // Обнуляем идентификатор "фиктивного" события
					// Если не "обнулить" идентификатор "фиктивного" события, то при завершении функции
					// и выходе из неё в цыкле уточнения обнаруженных событий, выход из 
					// ЗРВ будет уточняться повторно, что приведёт к ошибке!!!!
					//
					// Архивируем характеристики выхода из ЗРВ
					Z->G2 = SI.E.Value ;		// Угол места на параметре, град	
					Z->A2 = SI.E.Value2 ;		// Азимут на параметре, град
					Z->t2 = SI.E.ta ;			// Время прохождения параметра, ссс
					Z->isFound|= 4 ;			// Признак найденного события "Параметр"
					// 
					PostFindZRV(KA, SI, Z) ;
					j++ ;
					return-1 ;
				} else {
					// Фиксируется факт прохождения параметра
					// Архивируем характеристики прохождения параметра ЗРВ
					Z->Gmax = EVSI.E.Value ;
					Z->Ap   = EVSI.E.Value2 ;
					Z->tp   = EVSI.E.ta ;
					Z->isFound|= 2 ;
					//
					PostFindZRV(KA, EVSI, Z) ;
				}
			}
			break ;
		case ModEvent_ZRVEND:
			// Архивируем характеристики выхода из ЗРВ
			Z->G2 = EVSI.E.Value ;
			Z->A2 = EVSI.E.Value2 ;
			Z->t2 = EVSI.E.ta ;
			Z->isFound|= 4 ;
			//
			PostFindZRV(KA, EVSI, Z) ;
			break ;
		default: assert(0) ;
	}

	// Проверка особенностей события прохождения параметра 	
	if (en==ModEvent_ZRVPARAM) {
		// Проерка возвышения КА над "горизонтом" в момент
		// прохождения параметра
		if (EVSI.E.Value<Gmin) {
			// Если угол места на параметре меньше минимально
			// допустимого, то такая ЗРВ игнорируется
			return-1 ;
	}	}

	return 0 ;
}

//-------------------------------------------------------------------------------
// Соранение характеристик ЗРВ в буфере ZF потому-что
// при вызове OnEvent при сформированной ЗРВ она архивируется
// и характеристики её обнуляются. А ведь ещё нужно вызвать
// метод OnFullZRV, куда следует передать все расчитанные 
// характеристики ЗРВ.
void ZCEventManager::PostFindZRV(ZMSC* KA, ZSC_SI& SI, ZZRV* Z)
{
	ZZRV ZF =*Z ;
	// Реализация возможности реакции на найденное событие
	// (Вызов функции для реакции на отдельное событие ЗРВ)
	KA->OnEvent(SI.E, &SI) ;
	// Реакция на полную найденную ЗРВ...
	if (ZF.isFound==7) {
		// Реакция на полную найденную ЗРВ
		KA->OnFullZRV(&ZF, &SI) ;
		// Обнуление буфера
		memset(Z, 0, sizeof(ZZRV)) ;
		Z->Nip =-1 ;
	}
}

//-------------------------------------------------------------------------------
int ZCEventManager::TestEvents(ZMSC* KA, ZSC_SI* SI)
{
	// Если нет необходимости контроля событий то просто вызходим из функции
	if (!isNeedTestZRV && !isNeedTestVit) return 0 ;
	// Текущие элементы движения КА
	if (!SI) SI = &KA->FSC ;

	// Сохраняем расчитанные ранее параметры прошлого шага
	PreTest() ;
	// Расчитываем все контролируемые параметры для текущего шага
	// В том числе параметры контролируемых событий витка  
	// (макс и мин высота и радиус, начало витка и нисходящий узел), 
	// и параметры контролируемых событий ЗРВ (вход, выход, параметр)
	int rc = CalcParams(KA, SI) ; RRC ;

	//---------------------------------------------------------------------------
	// Проверки наступления контролируемых событий витка
	// (имальные и максимальные высота и радиус, восходящий и нисходящий
	// узел орбиты)
	int i, j=0 ;
	if (isNeedTestVit) {
		// Проверка контролируемых параметров, а именно момента когда 
		// каждый из них меняет знак с минуса на плюс
		for(i=ModEvent_BEG ; i<=ModEvent_END ; i++) {
			if (IP(i) && CP(i)<=0 && CT(i)>=0) {
				ie[j] = (ModEventName)i ; 
				j++ ; 
	}	}	}

	//---------------------------------------------------------------------------
	// Проверка параметров ЗРВ
	if (isNeedTestZRV) {
		for(i=ModEvent_ZRVBEG ; i<ModEvent_ZRVBEG+3*CountNips() ; i++) {
			if (IP(i) && CP(i)<=0 && CT(i)>=0) {
				ie[j] = (ModEventName)i ; 
				j++ ; 
	}	}	}

	//---------------------------------------------------------------------------
	// Уточнение нуля найденных контролируемых параметров, 
	// меняющих в пределах предыдущего шага свой знак с минуса на плюс
	ZSC_SI EVSI ;
	for(i=0; i<COUNT_ModEvents; i++) {
		// Если очередной идентификатор события нулевой, значит на шаге
		// нет больше ни одного события
		if (!ie[i]) break ;
		// Обнуление структуры параметров движения КА в момент наступления
		// уточняемого события
		memset(&EVSI, 0, sizeof(EVSI));

		//-----------------------------------------------------------------------
		// Уточнение момента наступления события, когда 
		// контролируемый параметр переходит из отрицательной 
		// области значений в положительную.
		rc = ClarifyEvent(KA, ie[i], &EVSI) ; RRC ;
		//-----------------------------------------------------------------------
		// Проверка засечки параметра ЗРВ ниже "горизонта"
		// Проверка "одношаговой" ЗРВ
		// Проверка наличия на шаге того или иного события ЗРВ...
		rc = TestZRV(KA, EVSI, i, j) ;
		if (rc) {
			// Если событие найдено...
			if (rc==-1) { 
				// Если событие ЗРВ обнаружено и уточнено (rc=-1), 
				// то в рамках ф-ии TestZRV соответствующие функции 
				// реакции на событие уже вызваны
				rc = 0 ; 
				continue ; 
			}
			return rc ;
		}

		//-----------------------------------------------------------------------
		// Реализация возможности реакции на найденное событие
		KA->OnEvent(EVSI.E, &EVSI) ;
	}
	return 0 ;
}

//-------------------------------------------------------------------------------
int ZCEventManager::ClarifyEvent(ZMSC* KA, ModEventName indEvent, ZSC_SI* SI, double* ddh)
{
	int    rc=0 ;
	int    MaxCountIter=100 ;
	double eFSCZ=1e-6/1e4 ;			// Точность по координате
	double eFSCT=0.001/86400.0 ;	// Точность по времени

	// Сохраняем состояние модели движения
	// (только интегрируемый вектор)
	KA->FastStory() ;

	double Zt=CT(indEvent) ; 
	double Zp=CP(indEvent) ;
	double tt=timet ;
	double tp=timep ;

	// Уточняем момент начала витка
	int CountIter=0 ; 
	double t, dht, ht=0, dZ=Zt, dZP ;
	//
	if (ddh) ht =-(*ddh) ;
	// Итерационный процесс уточнения момента события
	while (1) {
		// Поправка ко времени начала витка
		dht=-dZ/(Zt-Zp)*(tt-tp) ;
		// Уточняем время начала витка
		ht+= dht ;
		// Подшагивание до уточнённого времени пересечения нулевого значения
		// контролируемым параметром
		rc = KA->BackStep(SI, ht, indEvent) ; if (rc) goto end ;
		// Расчёт контролируемого параметра
		CalcParams(KA, SI, indEvent, &dZP, &dZ) ;
		t  = SI->ta ;
		// Изменение интервала - смещение левой или правой границы 
		if (dZ*Zt>= 0) { Zt = dZ ; tt = t ; }
		else { Zp = dZ ; tp = t ; }
		// Проверка условия сходимости 
		if (fabs(dZ)<eFSCZ || fabs(dht)<eFSCT) {
			// Контролируемый параметр должен быть немного больше нуля
			if (dZ<0) {
				// Если он отцательный то подшагиваем немного вперёд
				dht= dZ/(Zp-Zt)*(tt-tp) ;
				ht+= 2*dht ;
				// Восстанавливаем состояние модели
				KA->FastReStory() ;
				// Отшагиваем назад
				rc = KA->BackStep(SI, ht, indEvent) ; if (rc) goto end ;
				// Расчёт контролируемого параметра
				rc = CalcParams(KA, SI, indEvent, &dZP, &dZ) ; if (rc) goto end ;
			}
			break ;
		} 
		// Увеличиваем счётчик числа итераций
		CountIter++ ;
		// Контроль колличества итераций
		if (CountIter>MaxCountIter) { rc =-2 ; goto end ; }
		// Воостанавливаем состояние МД на момент последнего (ло уточнения) шага
		// (только интегрируемый вектор)
		KA->FastReStory() ;
	}

end: ;
	// Восстанавливаем состояние модели
	KA->FastReStory() ;
	// Восстанавливаем значение контролируемого параметра
	// на момент последнего шага
	CalcParams(KA, &KA->FSC, indEvent, nullptr, nullptr) ;

	// При успешном завершении процедуры искомый момент события а также
	// все параметры движения на даный момент времени содержатся в структуре 
	// ZSC_SI* SI
	// Состояние модели соответствует состоянию до начала уточнения

	//Проверка корректности формирования события (начало витка)
	if (indEvent==ModEvent_VITVU) {
		if (SI->ASKTE[2]<0) {
			SI->VitTE++ ;
			SI->ASKTE[2] = 0.0 ;
		}
		SI->E.Value = (double)SI->VitTE ;
	}

	return rc ;
}

//-------------------------------------------------------------------------------
