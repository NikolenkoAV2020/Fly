//-----------------------------------------------------------------------------
// ZCEopManager.cpp
// Диспетчер параметров вращения Земли (Eath orientation parameters)
//
//-----------------------------------------------------------------------------
// Диспетчер ПВЗ объект который создаётся только однажды полсле загузки 
// библиотеки модели движения. Все объекты модели ZMSC обращаются к одному 
// и тому же объекту ZCEopManager.
// 
// Любому объекту модели движения, так же как и любой прикладной программе 
// доступна глобальная переменная ZCEopManager CEopMng. 
//
// А. Николенко 01.05.2019
//-----------------------------------------------------------------------------
#include <stdafx.h>

//-----------------------------------------------------------------------------
// Компоненты Fly
#include <FlySofa.h>		// Функции фундаментальной астрономии

//-----------------------------------------------------------------------------
#include <FlyCoreSource\\ZCEopManager.h>
#include <FlyCoreSource\\ZCStorageBinaryFile.h>

//-----------------------------------------------------------------------------
ZCEopManager CEopMng;

//-----------------------------------------------------------------------------
ZCEopManager::ZCEopManager()
{
	Clear();

	// Имя файла внешнего источника данных ПВЗ - публикуется IERS
	IersFileName = EOP_IERS_FILE_NAME;

	// Даты начала файлов бинарного архива ПВЗ
	DATETIMEUTC UTC(1, 1, EOP_STORAGE_ORIGIN_Y, 0, 0, 0, 0);
	for (int i = 0; i < EOP_STORAGE_FILE_COUNT; ++i) {
		ZCEopManager::UtcToMjd(UTC, MjdF[i]);
		UTC.G += 10;
	}

	// Дата начала апостериорной оценки точности прогнозируемых
	// ПВЗ, публикуемых IERS.
	UTC.G = EOP_IERS_EST_ORIGIN_Y;
	ZCEopManager::UtcToMjd(UTC, MjdEstEopPredict);
}

//-----------------------------------------------------------------------------
ZCEopManager::~ZCEopManager()
{
	Clear();
}

//-----------------------------------------------------------------------------
int ZCEopManager::UtcToMjd(DATETIMEUTC& UTC, float& Mjd)
{
	double D, D2;
	int rc = iauDtf2d("UTC", UTC.G, UTC.M, UTC.D, UTC.h, UTC.m,
					  UTC.s + UTC.d, &D, &D2);
	// rc +1 Дата преобразуемя в MJD слишком далёкая для того чтоб
	//		 гарантировать точное преобразование... Нет прогнозного
	//		 значения секунд координации UTC - IAT
	//    +2 Время задано таким образом что оно больше 24 часов... не фатально
	//    +3 Оба выше перечисленных случая одновременно.
	// Если код ошибки отрицательный значит ошибка в исходных данных - они
	// заданы неверно. 
	if (rc < 0) return rc;
	// По двойной JD вычисляем MJD
	Mjd = (float)(D + D2 - ZMJD0);
	return 0;
}

//-----------------------------------------------------------------------------
int ZCEopManager::MjdToUtc(float& Mjd, DATETIMEUTC& UTC)
{
	double d = Mjd + ZMJD0, d2 = 0;
	int    ihmsf[4];

	int rc = iauD2dtf("UTC", 7, d, d2, &UTC.G, &UTC.M, &UTC.D, ihmsf);
	// rc +1 Дата преобразуемя в MJD слишком далёкая для того чтоб
	//		 гарантировать точное преобразование... Нет прогнозного
	//		 значения секунд координации UTC - IAT
	// Если код ошибки отрицательный значит ошибка в исходных данных - они
	// заданы неверно. 
	if (rc < 0) return rc;
	UTC.h = ihmsf[0];
	UTC.m = ihmsf[1];
	UTC.s = ihmsf[2];
	UTC.d = ihmsf[3]/1e7;
	return 0;
}

//-----------------------------------------------------------------------------
void ZCEopManager::Clear()
{
	memset(&EopLoadReport, 0, sizeof(EopLoadReport));
	// Имя файла внешнего источника данных ПВЗ - публикуется IERS
	IersFileName = "";
}

//-----------------------------------------------------------------------------
// Расшифровка одной строки стандартного формата IERS, содержащего ПВЗ.
// Резултат в структуре ZSEopItem I.
int ZCEopManager::DecodeIersString(char* S, ZSEopItem* I)
{
	if (strlen(S) < 75) return -1;

	int   n, rc = 0;
	char  *s = &S[0], C, SD[64];
	float F;
	DATETIMEUTC UTC;

	// Считывание даты
	memcpy(SD, s, 2); SD[2] = '\0'; s += 2;
	n = sscanf(SD, "%d", &UTC.G); if (n != 1) { rc = -10; goto end; }
	memcpy(SD, s, 2); s += 2;
	// Преобразование года из формата XX в формат XXXX
	if (UTC.G > 50) UTC.G += 1900;
	else UTC.G += 2000;
	// Считывание месяца и дня
	n = sscanf(SD, "%d", &UTC.M); if (n != 1) { rc = -10; goto end; }
	memcpy(SD, s, 2); s += 2;
	n = sscanf(SD, "%d", &UTC.D); if (n != 1) { rc = -10; goto end; }

	// Считывание MJ
	n = sscanf(s, "%f", &I->MJD); if (n != 1) { rc = -11; goto end; }
	s = SkipSpace(s);
	s = SkipToSpace(s);

	// Проверка данных о дате
	{
		double D, D2;
		rc = iauDtf2d("UTC", UTC.G, UTC.M, UTC.D,
			UTC.h, UTC.m, UTC.s + UTC.d, &D, &D2);
		if (rc) { rc = -30; goto end; }
		// По двойной JD вычисляем MJD
		D = D + D2 - ZMJD0;
		// Собственно сама проверка  
		if (fabs(I->MJD - D) > 0.001) { rc = -30; goto end; }
	}

	// Считывание ключевого символа формата файла
	s = SkipSpace(s);
	n = sscanf(s, "%c", &C); if (n != 1) { rc = -12; goto end; }
	if (C != 'I' && C != 'P') { rc = -13; goto end; }
	s = SkipSpace(s); s++;

	// Признак достоверности данных - апостериорные данные (1) или
	// прогноз IERS (1)
	I->key = (C == 'I' ? 1 : 2);

	// Считывание Xp
	n = sscanf(s, "%f", &I->Xp); if (n != 1) { rc = -14; goto end; }
	// Перевод из секунд в милисекунды (угловые разумеется)
	I->Xp *= 1e3;
	s = SkipSpace(s);
	s = SkipToSpace(s);

	// Точность Xp - она не нужна
	n = sscanf(s, "%f", &F); if (n != 1) { rc = -15; goto end; }
	s = SkipSpace(s);
	s = SkipToSpace(s);

	// Считывание Yp
	n = sscanf(s, "%f", &I->Yp); if (n != 1) { rc = -16; goto end; }
	// Перевод из секунд в милисекунды (угловые разумеется)
	I->Yp *= 1e3;
	s = SkipSpace(s);
	s = SkipToSpace(s);

	// Точность Yp - она не нужна
	n = sscanf(s, "%f", &F); if (n != 1) { rc = -17; goto end; }
	s = SkipSpace(s);
	s = SkipToSpace(s);

	// Считывание ключевого символа формата файла
	s = SkipSpace(s);
	n = sscanf(s, "%c", &C); if (n != 1) { rc = -18; goto end; }
	if (C != 'I' && C != 'P') { rc = -19; goto end; }
	s = SkipSpace(s); s++;

	// Считывание отклонения UT1 от UTC
	n = sscanf(s, "%f", &I->UT1mUTC); if (n != 1) { rc = -20; goto end; }
	// Перевод из секунд в милисекунды
	I->UT1mUTC *= 1e3;

	// Остальные данные даже если они и есть не нужны -
	// символы до конца строки игнорируются
end:;
	return rc;
}

//-----------------------------------------------------------------------------
// Загрузка апостериорных данных из внешненго истояника - текстового файла
// полученного с интернет-ресурса Международной службы вращения Земли IERS.
// Под апостериорными данными понимаются данные публикуемые
// IERS (уклонение полюса X,Y в угловых милисекундах 
// и разность UTC1-UTC в милисекундах)
//
// В случае неудачной загрузки массива априорных ПВЗ прогнозирование
// параметров движения будет проходить с нулевыми значениями уклонения
// полюса и разности между UT1 и UTC.
// Данная ситуация не является фатальной и приведёт только к незначительному
// снижению точности результатов прогнозирования. При этом полученные 
// погрешности будут иметь только периодическую составляющую, то есть с течением
// времени ошибка прогноза из-за отсутствия ПВЗ накапливаться не будет.
// Справедливости ради необходимо заметить, что сложившаяся практика 
// навигационно-баллистического обеспечение такова, что НЕУЧЁТ ПВЗ является
// скорее правилом чем исключением. В большинстве программно-аппаратных 
// комплексов и соответствующем СМПО НБО управления полётами современных 
// космических средств учёт ПВЗ не реализован. Как правило ПВЗ учитываются
// при решении только прецезионных задач динамики орбитального полёта, 
// таких как например НБО полёта КА системы "Ураган".
//
// Одновременно с загрузкой текстового файла в формате IERS формируется бинарный 
// сокращённый файл, содержащий только координаты полюса и отклонение UTC1-UTC, 
// для последующей быстрой загрузки этих данных. 
// Кроме того может формироваться текстовый файл, содержащий загруженные данные 
// ПВЗ для быстрого интерактивного контроля и анализа полученной информации
// (isNeedSaveAsShortTxt = true).
// 
// Если isNeedVaracitiPredictEst = true то параллельно с загрузкой выполняется
// оценка ранее прогнозируемых службой IERS данных. Результаты оценки 
// записываются в соответствующее хранилище.
// 
// Если isNeedBuilModels  = true, то в соответствии с загруженными ПВЗ
// на всём интервале данных формируется массив частных алгебраических моделей
// координат полюса и отклонения UTC-UTC1 в виде полиномов чебышёва.
// Именно данные модели используются в дальнейшем для прогнозирования движения
// КА.
// Построение частных алгебраических моделей может так же выполняться в 
// дальнейшем как самостоятельная операция по данным ПВЗ хранящимся в
// бинарном хранилище.
//-----------------------------------------------------------------------------
int ZCEopManager::LoadFromIersFormat(
	// Загружать данные IERS из этого файла
	char* SpecifiedIersFile,
	// Необходимость оценки точности предыдущего прогноза
	bool isNeedVaracitiPredictEst,
	// Сохранять загруженные данные в виде сокращённого текстового формата
	bool isNeedSaveAsShortTxt,
	// Необходимость построения по полученным данным частных алг. моделей
	bool isNeedBuilModels)
{
	// Время начала загрузки
	time_t startTIME = clock();

	// Удаление ранее загруженной информации о ПВЗ
	Clear();

	int  rc = 0,
		 NumBinFile = -1,
		 newNumBinFile = -1;
	long fromMjd = 0,
		 toMjd = 0,
		 SumCountItems = 0;
	char S[1025];
	ZSEopItem I, IR, DI;

	//-------------------------------------------------------------------------
	// Имя текстового документа IERS
	string NameFileTxt = (char*)GetIersFileName(SpecifiedIersFile);
	// Проверка того что файл действительно текстовый
	int extPos;
	{
		// Для корректности поиска расширения переводим имя файла в нижний 
		// регистр. !!!! Работает всегда только для латиницы !!!!
		string SFT = NameFileTxt;
		std::transform(SFT.begin(), SFT.end(), SFT.begin(), tolower);
		// Поиск нужного расширения
		extPos = SFT.find(".txt", 0);
		// Если файл не текстовый то парсинг файла проводить нет смысла
		if (extPos == string::npos) return -1;
	}

	//-------------------------------------------------------------------------
	// Текстовый документ с ПВЗ в формате IERS
	ifstream FileTxt;
	FileTxt.open(NameFileTxt, ios::in);
	if (FileTxt.fail() || FileTxt.eof()) return-1;

	//-------------------------------------------------------------------------
	// Сокращённый текстовый документ дублирующий результаты загрузки
	ofstream FileTxtShort;
	if (isNeedSaveAsShortTxt) {
		// Имя документа
		NameFileTxt.insert(extPos, "Short", 5);
		// Открытие нового пустого файла для дублирования загружаемых
		// данных в сокращённом текстовом виде
		FileTxtShort.open(NameFileTxt, ios::out | ios::trunc);
		if (FileTxtShort.fail() || FileTxtShort.eof()) return-1;
	}

	// Бинарное хранилище ПВЗ, точнее интерфейс доступа к файлам-хранилищам
	ZCEopIersBinFile     BinEopStorage;
	// Бинарное хранилище прогнозируемых ПВЗ
	ZCEopPredictBinFile  BinPredictStorage;
	// Бинарное хранилище результатов оценки точности прогнозирования ПВЗ
	ZCEopEstimateBinFile BinEstimateStorage;

	//-------------------------------------------------------------------------
	// Цыкл считывания текстового файла по строкам
	// и формирования файлов бинарного хранилища данных ПВЗ.
	while (1) {
		// Проверка завершения загрузки массива
		if (FileTxt.eof()) break;

		//---------------------------------------------------------------------
		// Считывание данных ПВЗ из текстового файла в формате IERS

		// Считывание строки целиком 10294
		FileTxt.getline(S, 1024, '\n');

		// Расшифровка строки и заполнение полей структуры ZSEopItem I
		rc = DecodeIersString(S, &I);
		if (rc == -1) {
			// Строка не полная или отсутствует - значит достигнут конец файла
			// и данных больше нет. Цыкл завершается.
			rc = 0; break; 
		}
		if (rc) {
			// При расшифровке данных произошла ошибка, возможно неверный 
			// формат данных. прерывание процесса загрузки с ошибкой.
			if (!SumCountItems) {
				// Если не одной записи прочитано не было, значит формат
				// файла не соответствует требуемому.
				goto end;
			} else {
				// Если хоть какие-то данные из файла были прочитаны, значит
				// скорее всего просто достигнут конец файла, значит корректное
				// завершение цикла !!!!
				rc = 0; break;
		}	}

		// Определения номера файла-хранилища.
		// Файл-хранилище с определённым номером соответствует определённому
		// периоду времени.
		int newNumBinFile = GetNumBinFile(I.MJD, NumBinFile);
		// Если данные о ПВЗ относятся к дате ранее чем 01.01.1980
		// то такие данные игнорируются и в бинарное хранилище
		// не записываются (в этом случае newNumBinFile < 0)
		if (newNumBinFile < 0) continue;

		//---------------------------------------------------------------------
		// Запись ПВЗ в сокращённый текстовый файл
		if (isNeedSaveAsShortTxt && FileTxtShort.is_open()){
			sprintf(S, "%10.1lf	%12.6lf	%12.6lf	%12.6lf\n", I.MJD, I.Xp, I.Yp, I.UT1mUTC);
			FileTxtShort << S;
		}

		//---------------------------------------------------------------------
		// Запись ПВЗ в бинарный файл хранилища ПВЗ

		// Проверка необходимости открытия нового файла 
		// бинарного хранилища
		if (newNumBinFile != NumBinFile) {
			// Необходимо открыть/создать файл бинарного хранилища

			// Отмечен новый номер файла бинарного хранилища
			NumBinFile = newNumBinFile;

			// Создание/открытие файла-хранилища загружаемых ПВЗ
			rc = BinEopStorage.Open(NumBinFile, MjdF[NumBinFile]);
			if (rc) goto end;

			// Создание/открытие файла-хранилища прогнозируемых ПВЗ
			rc = BinPredictStorage.Open(NumBinFile, MjdF[NumBinFile]);
			if (rc) goto end;

			if (isNeedVaracitiPredictEst) {
				// Создание/открытие файла-хранилища оценки качества 
				// прогнозируемых ранее ПВЗ
				rc = BinEstimateStorage.Open(NumBinFile, MjdF[NumBinFile]);
				if (rc) goto end;
			}
		}

		// Сохрание текущей зпаписи (только что прочитанной из файла в формате
		// IERS) в бинарном хранилище ПВЗ
		BinEopStorage << I;

		// Если текущая запись ПВЗ является прогнозируемой, то есть I.key = 2
		// или I.key = 3, то необходимо данную запись также поместить в 
		// хранилище прогнозируемых ПВЗ
		if (I.key > 1) {
			BinPredictStorage << I;
		}

		if (isNeedVaracitiPredictEst && I.key == 1) {
			IR.MJD = I.MJD;
			if ((BinPredictStorage >> IR) == true) {
				// В хранилище прогнозируемых ПВЗ уже есть 
				// запись для текущей MJD
				// Сохранение информации о разности прогнозируемых 
				// ПВЗ и апостериорных ПВЗ. 
				DI.key = 1;
				DI.MJD = I.MJD;
				DI.Xp  = I.Xp - IR.Xp;
				DI.Yp  = I.Yp - IR.Yp;
				DI.UT1mUTC = I.UT1mUTC - IR.UT1mUTC;
				BinEstimateStorage << DI;
		}	}

		(SumCountItems ? toMjd : fromMjd) = (long)I.MJD;
		// Увеличение общего колличества записей записанных в
		// хранилище ПВЗ
		++SumCountItems;
	}

end:;
	// Если при загрузке данных произошла ошибка, что может быть скорее всего
	// из-за не правильного формата файла, то просто удаляем содержимое
	// диспетчера ПВЗ
	if (rc) Clear();
	else {
		// Заполняем отчёт о загрузке данных
		// Время завершения загрузки  
		time_t endTIME = clock();
		// Длительность загрузки в милисекундах
		EopLoadReport.Duration = (long)(endTIME - startTIME);
		// Источник загрузки IERS
		EopLoadReport.source = 0;
		EopLoadReport.CountItems = SumCountItems;
		EopLoadReport.fromMjd = fromMjd;
		EopLoadReport.toMjd = toMjd;
	}
	EopLoadReport.ExitCode = rc;

	//Закрытие текстового файла IERS
	if (FileTxt.is_open())	FileTxt.close();
	//Закрытие сокращённого текстового файла с загруженными ПВЗ
	if (FileTxtShort.is_open())	FileTxtShort.close();
	// Бинарные файлы-хранилища: загруженных ПВЗ, прогнозируемых ПВЗ
	// и оценки точности прогнозирования ... закрываются автоматически при 
	// разрушении соответствующих им объеутов ZCStorageBinaryFile

	return rc;
}

//-----------------------------------------------------------------------------
char* ZCEopManager::SkipSpace(char* s)
{
	while (*s == ' ') {
		if (*s == '\n' || *s == '\r' || *s == '\0') break;
		s++;
	}
	return s;
}

//-----------------------------------------------------------------------------
char* ZCEopManager::SkipToSpace(char* s)
{
	while (*s != ' ') {
		if (*s == '\n' || *s == '\r' || *s == '\0') break;
		s++;
	}
	return s;
}

//-----------------------------------------------------------------------------
int ZCEopManager::PutHeaderItemToStorage(ZSEopModHeaderItem& I)
{
	return 0;
}

//-----------------------------------------------------------------------------
int ZCEopManager::PutModToStorage(ZSEopModHeaderItem& I, ZSAlgLocalMod& M)
{
	return 0;
}

//-----------------------------------------------------------------------------