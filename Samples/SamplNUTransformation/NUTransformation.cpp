//-----------------------------------------------------------------------------
// NUTransformation.cpp
//
// А. Николенко 12.06.2019
// 
// 1) Демонстрируется: загрузка НУ из УОФ НУ01, преобразование НУ в систему  
// координат отличную от исходной.
// 
// 2) Проверка корректности вычисления матриц прецессии, нутации 
// и вращения земли.
// Если получить одни и те же НУ но в различных системах координат из
// внешнего независимого источника, загрузить их через УОФ НУ01, далее
// преобразовать в другую систему координат и после сранить с НУ в той же 
// системе координат, но полученными из внешнего независимого истояника,
// то тем самым можно проверить корректность расчёта матриц прецессии,
// нутации и вращения Земли.
// Действительно при пересчёте например из АСК-2000 в АСК текущей эпохи вектор
// фазовых координат умножается на матрицу прецессии  и на матрицу нутации,
// если расчёт данных матриц правильный, то полученный вектор координат будет
// совпвдвть с координатами в АСК ТЕ, полученными из внешненго источника.
// Точнее говоря расчёт прецессии и нутации посредством проверяемых программных
// средств будет соответствовать тем же расчётам во внешнем независимом 
// источнике. Если данный источник считать эталоном, то можно считать
// что проверяемые программные средства дают достоверные результаты.
// 
// Описанным образом можно проводить сверку расчёта матрицы прецессии, нутации
// и матрицы вращения Земли (звёздного времени).
//-----------------------------------------------------------------------------
#include "stdafx.h"

//-----------------------------------------------------------------------------
// Компоненты Fly
#include <FlyCore.h>
#include <FlyCoreLink.h>

// Подключение библиотек Fly

int TestAgeValidation();

void main()
{
	// Вывод кирилицы в консольном приложении 
	//setlocale(LC_CTYPE, "rus");
	SetConsoleCP(1251);
	SetConsoleOutputCP(1251);

	// Инициализация ядра Fly, фактически настройка путей к необходимым 
	// информационным ресурсам, инициализация глобальных переменных,
	// в последствии возможно инициализация соединения с БД...
	int rc = FlyGlobalInit(); if (rc) return;

	// Тест трансформации НУ в различные СК и тем самым косвенная проверка
	// корректности и достоверности расчёта характеристик прецессии, нутации,
	// звёздного времени и параметров вращения Земли (ПВЗ)
	// Конечно же для такой проверки необходим ряд НУ на один и тот же момент  
	// времени для одной и той же орбиты но в различных СК, такие НУ которые 
	// получены из внешнего независимого источника и которые можно считать
	// эталонными - то есть истинными и точными...
	TestAgeValidation();
}

//-----------------------------------------------------------------------------
// Название системы координат по её идентификатору
string NameSK(SK_TYPE sk)
{
	switch (sk) {
	case _SK_ASKTE:   return("АСК-ТЕ");
	case _SK_ASK1975: return("АСК-1975");
	case _SK_ASK2000: return("АСК-2000");
	case _SK_GSK:     return("ГСК");
	}
	return "";
}

//-----------------------------------------------------------------------------
// Преобразование НУ fromNU в систему координат sk, в которой заданы
// и НУ referenceNU, и стравнение полученного результата с
// эталонными НУ referenceNU.
// Документирование полученного результата.
void PrintDifNU(ZNU&    fromNU,		// Проверяемые НУ	
				SK_TYPE sk,			// СК для преобразования проверяемых НУ	
				ZNU&    referenceNU,// Эталонные НУ
			    ZCHtmlBuilder* HB,	// Интерфейс Html-документа 
				int varInd)			// Колонка таблицы Html-документа для 
{									// записи результатов
	int i;
	ZNU NU;	NU = fromNU;

	// Преобразование НУ из исходной СК в СК сравнения
	ConvertSkNu(NU, sk);

	// Название исходной СК
	string nameSk1 = NameSK(fromNU.sk);
	// Название конечной СК
	string nameSk2 = NameSK(sk);

	// Трансляция в консоль происходящего 
	string S;
	S = nameSk1; S += " ---> "; S += nameSk2;
	cout<< "     " << S << endl;
	cout<< "     Отклонения НУ трансформированных проверяемым СМПО от НУ,"
		<< endl
		<< "     заданных в " << nameSk2 << " и полученных из независимого"
		<< endl
		<< "     прецезионного источника"
		<< endl << endl;

	// Вычисление отклонений трансформированных НУ от эталонных
	double dX[6];
	for (i = 0; i < 3; ++i) {
		// Отклонения координат в сантиметрах
		// Полученную разность из ДТКМ переводим в см (...*1e9)
		dX[i] = (NU.X[i] - referenceNU.X[i])*1e9;
		// Отклонения скоростей в мм/сек.
		// Сперва разность из ДТКМ/ССС переводим в км/сек, а после
		// в мм/сек.
		dX[i + 3] = TO_KMS(NU.X[i + 3] - referenceNU.X[i + 3])*1e6;
	}

	// От ображение отклонений в консоли
	for (i = 0; i < 6; ++i) {
		cout << "     " << (i < 3 ? "[cм]    " : "[мм/сек]") << dX[i] << endl;
	}
	cout << endl;

	if (!HB) return;

	// Получение индекса элемента по маркеру
	ZSMarkItem mi = HB->GetItemsMark("Rezult");
	// Получение элемента Html-документа по индексу
	ZСHtmlItem& I = (*HB)(mi[0]);

	// Заголовок
	S = nameSk1; S += " --> "; S += nameSk2;
	I(0)(varInd).txt = S;

	// Заголовок
	I(1)(varInd).txt = "";
	char s[128];
	for (i = 0; i < 6; ++i) {
		if (i<5) sprintf(s, "%lf<br>\0", dX[i]);
		else	 sprintf(s, "%lf\0", dX[i]);
		I(1)(varInd).txt+= s;
	}

	// Отклонение радиус-вектора
	double dR = ModVector(dX, 3);
	sprintf(s, "%lf\0", dR);
	I(2)(varInd).txt = s;

	// Отклонение вектора скорости
	double dV = ModVector(dX + 3, 3);
	sprintf(s, "%lf\0", dV);
	I(3)(varInd).txt = s;
}

//-----------------------------------------------------------------------------
int NULoadPrintHtml(int indNU, char* fileName, ZNU& NU, ZCHtmlBuilder* HB)
{
	// Сообщенине на консоль о начале загрузки НУ01
	cout << "  НУ" << indNU + 1 << ":" << endl;

	// Массив строк с формой НУ01
	vector<string> snu;
	// Загрузка НУ01 из файла fileName с одновременной трансляцией 
	// в консоли содержания формы. Результат - данные о ну в стуктуре NU,
	// Текстовое содержание формы в массиве строк snu.
	int rc = LoadNU01(fileName, NULL, NULL, NU, HB ? &snu : nullptr, true);
	if (rc) return rc;

	// Если Html-писатель отсутствует, то завершаем процедуру
	if (!HB) return 0;
	// Если он задан, то документируем загруженные НУ в элемент
	// Html-документа который помечен маркером "NU01Tabl", предполагается
	// что заданы первые два индекса элемента - mi[0] и mi[1].

	// Получение индекса элемента по маркеру
	ZSMarkItem mi = HB->GetItemsMark("NU01Tabl");
	// Получение элемента Html-документа по индексу
	ZСHtmlItem& I = (*HB)(mi[0])(mi[1]);
	// Колличество строк в УОФ
	int countRow = snu.size();

	// Документирование УОФ как многострочного текста в дочерний элемент 
	// с индексом indNU 
	I(indNU).txt = "";
	for (int i = 0; i < countRow; ++i) {
		I(indNU).txt += snu[i];
		// Добавить переход на новую строчку -
		// В тексте элемента I(indNU) делаем инъекцию Html-кода в виде
		// тега перехода на новую строку "<br>", и таким образом формируем
		// многострочный текст.
		if (i < countRow - 1) I(indNU).txt += "<br>";
	}

	return 0;
}


//-----------------------------------------------------------------------------
// Формирование шаблона Html-документа.
// Можно было бы обойтись и без него, но формирование шаблона позволяет
// осмыслить внешний вид документа и расставить в его структуре маркеры для
// облегчения доступа к "узловым" элементам документа.
//-----------------------------------------------------------------------------
void BuildDocTamplate(ZCHtmlBuilder& HB)
{
	// Формирование таблицы стилей CSS 
	HB.S.cssLocation = 1;
	HB.BuildStyles();

	// Инициализация создания документа 
	HB.Init("Тест Расчёта прецессии и нутации",
		"Сверка расчёта прецессии и нутации.", 3, nullptr);

	// j - индекс описываемого элемента документа
	int j;

	// Горизонтальная линия
	j = HB.CountItems();
	HB(j).n = "hr";	j++;

	// Пустая строка
	HB(j).n = "br";	j++;

	// Текст - описание задачи форматированное как параграф
	HB(j).n = "p";
	HB(j).txt = "Сверка расчёта параметров прецессии и нутации \
посреством трансформации НУ в различные эпохи и сравнения полученного \
результата с эталоном";
	j++;

	// Пустая строка
	HB(j).n = "br";	j++;

	// Подготовка таблицы для НУ
	HB(j).n = "table";
	HB(j)[0] << "class\n FlyID2";
	HB(j)[1] << "style\n text-align: left";
	HB(j)(0).n = "tr";
	HB(j)(0)(0).n = "th";
	HB(j)(0)(0).txt = "АСК-1975";
	HB(j)(0)(1).n = "th";
	HB(j)(0)(1).txt = "АСК-2000";
	HB(j)(0)(2).n = "th";
	HB(j)(0)(2).txt = "АСК-ТЭ";
	HB(j)(0)(3).n = "th";
	HB(j)(0)(3).txt = "ГСК";
	HB(j)(1).n = "tr";
	HB(j)(1)(0).n = "td";
	HB(j)(1)(1).n = "td";
	HB(j)(1)(2).n = "td";
	HB(j)(1)(3).n = "td";
	// Создаём маркер указывающий на вторую строчку этой таблицы
	HB.CreateItemsMark("NU01Tabl", ZSMarkItem(j, 1));
	j++;

	// Пустая строка, горизонтальная линия и снова пустая строка
	HB(j).n = "br";	j++;
	HB(j).n = "hr";	j++;
	HB(j).n = "br";	j++;

	// Подготовка таблицы для отклонений трансформированных НУ от эталанных
	HB(j).n = "table";

	HB(j)[0] << "class\n FlyRezult";
	HB(j)(0).n = "tr";
	HB(j)(0)(0).n = "th";
	HB(j)(0)(1).n = "th";
	HB(j)(0)(2).n = "th";
	HB(j)(0)(3).n = "th";

	HB(j)(1).n = "tr";
	HB(j)(1)(0).n = "th";
	HB(j)(1)(0).txt = "(cм)<br>(cм)<br>(cм)<br>(мм/сек)<br>(мм/сек)<br>(мм/сек)";
	HB(j)(1)(1).n = "td";
	HB(j)(1)(2).n = "td";
	HB(j)(1)(3).n = "td";

	HB(j)(2).n = "tr";
	HB(j)(2)(0).n = "th";
	HB(j)(2)(0).txt = "Отклонение координат<br>(cм)";
	HB(j)(2)(1).n = "td";
	HB(j)(2)(2).n = "td";
	HB(j)(2)(3).n = "td";

	HB(j)(3).n = "tr";
	HB(j)(3)(0).n = "th";
	HB(j)(3)(0).txt = "Отклонение скорости<br>(мм/сек)";
	HB(j)(3)(1).n = "td";
	HB(j)(3)(2).n = "td";
	HB(j)(3)(3).n = "td";

	// Создаём маркер указывающий на эту таблицу
	HB.CreateItemsMark("Rezult", ZSMarkItem(j));
	j++;
}

//-----------------------------------------------------------------------------
int TestAgeValidation()
{
	int rc = 0;
	//----------------------------------------------------------------------------
	// "Писатель" для создания HTML-документа
	ZCHtmlBuilder HB;
	// Формирование шаблона Html-документа
	BuildDocTamplate(HB);

	//----------------------------------------------------------------------------
	// Имена файлов с УОФ НУ01, соответственно в АСК 1975 года, 2000 года и 
	// текущей эпохи.
	// char NameNU1975[] = "NU01_314_Sverka_4_ASK1975.txt";
	// char NameNU2000[] = "NU01_314_Sverka_4_ASK2000.txt";
	// char NameNU0000[] = "NU01_314_Sverka_4_ASKTE.txt";
	char NameNU1975[] = "NU01_268_Sverka_4_0004.txt";
	char NameNU2000[] = "NU01_268_Sverka_4_0005.txt";
	char NameNU0000[] = "NU01_268_Sverka_4_0003.txt";

	cout<< endl << endl
		<< "  Сверка расчёта параметров прецессии и нутации"
		<< endl
		<< "  посреством трансформации НУ в различные эпохи и сравнения"
		<< endl
		<< "  полученного результата с эталоном"
		<< endl << endl;

	// НУ которые будут загружены из УОФ НУ01
	ZNU NU1, NU2, NU3;

	// Трансляция в кансоль выполняемой операции
	cout<< "  Загрузка НУ полученных из независимого источника, принимаемого"
		<< endl
		<< "  достоверным источником прецезионной баллистической информации."
		<< endl << endl;

	// Загрузка НУ из УОФ НУ01 
	// НУ в АСК 2000
	rc = NULoadPrintHtml(0, NameNU2000, NU1, &HB);
	if (rc) return rc;

	// НУ в АСК 1975
	rc = NULoadPrintHtml(1, NameNU1975, NU2, &HB);
	if (rc) return rc;

	// НУ в АСК ТЕ
	rc = NULoadPrintHtml(2, NameNU0000, NU3, &HB);
	if (rc) return rc;

	cout << endl;

	// NU1, заданные в АСК-2000 переводим в _SK_ASKTE (АСК-ТЭ)
	// и сравнимаем с NU3, заданными в АСК-ТЭ
	PrintDifNU(NU1, _SK_ASKTE,   NU3, &HB, 1);
	// NU3, заданные в АСК-ТЭ переводим в _SK_ASK1975 (АСК-1975)
	// и сравнимаем с NU2, заданными в АСК-1975
	PrintDifNU(NU3, _SK_ASK1975, NU2, &HB, 2);
	// NU1, заданные в АСК-2000 переводим в _SK_ASK1975 (АСК-1975)
	// и сравнимаем с NU2, заданными в АСК-1975
	PrintDifNU(NU1, _SK_ASK1975, NU2, &HB, 3);

	// Сброс документа Html на диск.
	mkdir(".\\_Результаты");
	HB.Flash(".\\_Результаты\\Сверка_прецессиии_и_нутации");
	system  (".\\_Результаты\\Сверка_прецессиии_и_нутации.html");

	return 0;
}

//-----------------------------------------------------------------------------
