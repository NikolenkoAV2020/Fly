//--------------------------------------------------------------------------------
// ZMForceAtmDMA2001_Gost25645000.CPP
// Вычисление плотности динамической атмосферы по 
// ГОСТ Р 25645.000-2001.
// А. Николенко 06.11.2018.
//--------------------------------------------------------------------------------
#include <stdafx.h>
#pragma   hdrstop
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#include <FlyCoreSource\\ZMForceAtmDMA2001_Gost25645000.h>
#include <FlyCoreSource\\ZMForceAtmDMA2001_Gost25645000Data.h>

//--------------------------------------------------------------------------------
//	JD         - Юлианская дата, соответствующая текущему времени, UTC
//	ISA        - Индексы солнечной активности
//	SUNg       - Координаты Солнца в гринвичской вращающейся СК, [км]
//	XYZg       - Координаты КА в гринвичской вращающейся СК, [км]
//	ro         - Искомая плотность атмосферы в кг/м3
//--------------------------------------------------------------------------------
int DMA_GOST_25645_000_2001(double JD, ISA_DMA ISA, double* SUNg, double* XYZg, double& ro)
{
	int    i, N, rc = 0 ; 
	double Re   = 6378.136 ;		// Радиус экватора км
	double alfa = 0.0033528037 ;	// величина геометрического сжатия Земли
	double ro0  = 1.58868e-8 ;		// плотность ночной атмосферы на высоте 120 км в кг/м3
	double pi   = acos(-1.0) ;
	// Расстояние Земля-Солнце
	double RS  = sqrt(SUNg[0]*SUNg[0]+SUNg[1]*SUNg[1]+SUNg[2]*SUNg[2]) ;
	// Расстояние Земля-КА
	double Rka = sqrt(XYZg[0]*XYZg[0]+XYZg[1]*XYZg[1]+XYZg[2]*XYZg[2]) ;
	// Высота КА
	double h   = Rka-Re*(1.0-alfa*XYZg[2]*XYZg[2]/Rka/Rka) ;
	// Если вычисленная высота h менее 120 км, то пространственно-временные вариации 
	// плотности не учитываются. Плотность атмосферы   рассчитывают по формуле
	// для статической стандартной атмосферы (ГОСТ 1981 года)
	if (h<=120.0) {
		if (h<0) h = 0.0 ;
		// Выбор высотного слоя
		N = SIZEOFA(LowAtmDMA2001) ;
		for (i=0; i<N; i++) { if (h<LowAtmDMA2001[i].h) break ; }
		// Начальная и конечная высоты высотного слоя
		double hn= i==0? 0 : LowAtmDMA2001[i-1].h ;
		double hk= LowAtmDMA2001[i].h ;
		// Коэффициенты апроксимации плотности атмосферы
		double a = LowAtmDMA2001[i].a ;
		double k1= LowAtmDMA2001[i].k1 ;
		double k2= LowAtmDMA2001[i].k2 ; 
		// Вычисление плотности статической атмосферы
		ro = a*exp(k1*(h-hn)+k2*(h-hn)*(h-hn)) ;
		return 0 ;
	}

	// Фиксированный уровень солнечной активности за рассматриваемый период. 
	// Допустимые значения: 75, 100, 125, 150, 175, 200, 250
	double F0   = 125 ;
	// Средне-взвешенное за 81 сутки значение индекса  F107
	double F81  = 125 ;
	// Индекс солнечной активности, равный плотности потока 
	// радиоизлучения Солнца на волне, длиной 10.7 см
	double F107 = 125 ;
	// Квазилогарифмический, планетарный среднесуточный 
	// индекс геомагнитной активности
	double Kp   = 2 ;
	// Модифицированное значение 3-х часовых индексов 
	// геомагнитной возмущенности
	double kpp  = 2 ;

	// Вычисляется значение индексов F107 и F81 для времени, 
	// отстоящего от текущего на -1.7 суток
	F107 = ISA.F107 ;
	F81  = ISA.F81 ;
	Kp   = ISA.Kp ;
	kpp  = ISA.kpp ;

	// Индекс фиксированного ИСА F0
	// Из таблицы возможных значений F выбирается значение, ближайшее к полученному
	int iF0 = 0 ;			
	N = SIZEOFA(F0fix) ;
	for (i=0; i<N-1; i++) {	if ((F81-F0fix[i])*(F81-F0fix[i+1])<=0) break ;	}
	if (i==N-1) iF0 = F81<F0fix[0] ? 0:(N-1) ;
	else iF0 = fabs(F81-F0fix[i])<fabs(F81-F0fix[i+1]) ? i:(i+1) ;
	F0 = F0fix[iF0] ;

	// Коэффициенты ДМА
	double a[7] ;					// 1-я группа коэффициентов
	double b[5] ;					// 2-я группа коэффициентов
	double c[5], n0, n[2], fi1 ;	// 3-я группа коэффициентов
	double d[4] ;					// 4-я группа коэффициентов
	double e[9], et[4] ;			// 5-я группа коэффициентов
	double k[5] ;					// 6-я группа коэффициентов
	double l[5] ;					// 7-я группа коэффициентов

	// В зависимости от F0 для каждой группы коэффициентов выбирается 
	// значение пороговой высоты hgi
	if (h<hgi[0][iF0]) {	// Расчёт с коэффициентами для НИЖНЕГО высотного слоя
		a[0] = ailow[0][iF0] ; a[1] = ailow[1][iF0] ; a[2] = ailow[2][iF0] ;
		a[3] = ailow[3][iF0] ; a[4] = ailow[4][iF0] ; a[5] = ailow[5][iF0] ;
		a[6] = ailow[6][iF0] ;
	} else {	// Расчёт с коэффициентами для ВЕРХНЕГО высотного слоя
		a[0] = aihi[0][iF0] ; a[1] = aihi[1][iF0] ;	a[2] = aihi[2][iF0] ;
		a[3] = aihi[3][iF0] ; a[4] = aihi[4][iF0] ; a[5] = aihi[5][iF0] ;
		a[6] = aihi[6][iF0] ;
	}
	if (h<hgi[1][iF0]) {	// Расчёт с коэффициентами для НИЖНЕГО высотного слоя
		b[0] = bilow[0][iF0] ; b[1] = bilow[1][iF0] ; b[2] = bilow[2][iF0] ;
		b[3] = bilow[3][iF0] ; b[4] = bilow[4][iF0] ;
	} else {	// Расчёт с коэффициентами для ВЕРХНЕГО высотного слоя
		b[0] = bihi[0][iF0] ; b[1] = bihi[1][iF0] ;	b[2] = bihi[2][iF0] ;
		b[3] = bihi[3][iF0] ; b[4] = bihi[4][iF0] ;
	}
	if (h<hgi[2][iF0]) {	// Расчёт с коэффициентами для НИЖНЕГО высотного слоя
		c[0] = cilow[0][iF0] ; c[1] = cilow[1][iF0] ; c[2] = cilow[2][iF0] ;
		c[3] = cilow[3][iF0] ; c[4] = cilow[4][iF0] ; 
		n0   = n0low[iF0] ; n[0] = nlow[0][iF0] ; n[1] = nlow[1][iF0] ;
		fi1  = fi1low[iF0] ;  
	} else {	// Расчёт с коэффициентами для ВЕРХНЕГО высотного слоя
		c[0] = cihi[0][iF0] ; c[1] = cihi[1][iF0] ; c[2] = cihi[2][iF0] ;
		c[3] = cihi[3][iF0] ; c[4] = cihi[4][iF0] ;
		n0   = n0hi[iF0] ; n[0] = nhi[0][iF0] ;	n[1] = nhi[1][iF0] ;
		fi1  = fi1hi[iF0] ;
	}
	if (h<hgi[3][iF0]) {	// Расчёт с коэффициентами для НИЖНЕГО высотного слоя
		d[0] = dilow[0][iF0] ; d[1] = dilow[1][iF0] ;
		d[2] = dilow[2][iF0] ; d[3] = dilow[3][iF0] ;
	} else {	// Расчёт с коэффициентами для ВЕРХНЕГО высотного слоя
		d[0] = dihi[0][iF0] ; d[1] = dihi[1][iF0] ;
		d[2] = dihi[2][iF0] ; d[3] = dihi[3][iF0] ;
	}
	if (h<hgi[4][iF0]) {	// Расчёт с коэффициентами для НИЖНЕГО высотного слоя
		e[0] = eilow[0][iF0] ; e[1] = eilow[1][iF0] ; e[2] = eilow[2][iF0] ;
		e[3] = eilow[3][iF0] ; e[4] = eilow[4][iF0] ; e[5] = eilow[5][iF0] ;
		e[6] = eilow[6][iF0] ; e[7] = eilow[7][iF0] ; e[8] = eilow[8][iF0] ;
		et[0] = etilow[0][iF0] ; et[1] = etilow[1][iF0] ; 
		et[2] = etilow[2][iF0] ; et[3] = etilow[3][iF0] ;
	} else {	// Расчёт с коэффициентами для ВЕРХНЕГО высотного слоя
		e[0] = eihi[0][iF0] ; e[1] = eihi[1][iF0] ;	e[2] = eihi[2][iF0] ;
		e[3] = eihi[3][iF0] ; e[4] = eihi[4][iF0] ; e[5] = eihi[5][iF0] ;
		e[6] = eihi[6][iF0] ; e[7] = eihi[7][iF0] ;	e[8] = eihi[8][iF0] ;
		et[0] = etihi[0][iF0] ;	et[1] = etihi[1][iF0] ;
		et[2] = etihi[2][iF0] ;	et[3] = etihi[3][iF0] ;
	}
	if (h<hgi[5][iF0]) {	// Расчёт с коэффициентами для НИЖНЕГО высотного слоя
		k[0] = kilow[0][iF0] ; k[1] = kilow[1][iF0] ; k[2] = kilow[2][iF0] ; 
		k[3] = kilow[3][iF0] ; k[4] = kilow[4][iF0] ;
	} else {	// Расчёт с коэффициентами для ВЕРХНЕГО высотного слоя
		k[0] = kihi[0][iF0] ; k[1] = kihi[1][iF0] ;	k[2] = kihi[2][iF0] ;
		k[3] = kihi[3][iF0] ; k[4] = kihi[4][iF0] ;
	}
	if (h<hgi[6][iF0]) {	// Расчёт с коэффициентами для НИЖНЕГО высотного слоя
		l[0] = lilow[0][iF0] ; l[1] = lilow[1][iF0] ; l[2] = lilow[2][iF0] ;
		l[3] = lilow[3][iF0] ; l[4] = lilow[4][iF0] ;
	} else {	// Расчёт с коэффициентами для ВЕРХНЕГО высотного слоя
		l[0] = lihi[0][iF0] ; l[1] = lihi[1][iF0] ; l[2] = lihi[2][iF0] ;
		l[3] = lihi[3][iF0] ; l[4] = lihi[4][iF0] ;
	}

	//----------------------------------------------------------------------------
	// Вычисления в ссответствии с моделью
	double cfi1 = cos(fi1) ;
	double sfi1 = sin(fi1) ;
	// косинус угла "фи"
	double cfi  = 1.0/Rka/RS*(
		          XYZg[0]*(SUNg[0]*cfi1-SUNg[1]*sfi1)+
		          XYZg[1]*(SUNg[1]*cfi1+SUNg[0]*sfi1)+
				  XYZg[2]*SUNg[2]) ;
	// косинус угла "фи/2"
	double cfi2 = sqrt((1.0+cfi)/2.0) ;

	// Определяется количество суток d, прошедшее от начала года
	double d1913 = JD-2419768.0 ;
	double my    = (int)((4.0*d1913-1.0)/1461.0) ;
	// Так было в методике написанной по ГОСТу 
	// double dy = d1913-(int)(1461.0*my/4.0)-1.0+0.125 ; 
	// 1) Учтём отсчёт юлианских дат от 12 часов - то есть добавим в 
	//    полученную величину 0,5 суток
	// 2) Учтём тот факт что число суток имеет смысл времени UT1
	//    то есть величину 0.125 добавлять не нужно  
	double dy    = d1913-(int)(1461.0*my/4.0)-1.0+0.5 ; 
	
	// безразмерная величина
	double Ad   = Ai[0]+(Ai[1]+(Ai[2]+(Ai[3]+(Ai[4]+
		         (Ai[5]+(Ai[6]+(Ai[7]+Ai[8]*dy)*dy)*dy)*dy)*dy)*dy)*dy)*dy ;
	// безразмерная величина
	double Ah   = k[0]+(k[1]+(k[2]+(k[3]+k[4]*h)*h)*h)*h ;
	// Синус склонения КА
	double ZRka = XYZg[2]/Rka ;
	double K5   = 1.0+Ah*pow(ZRka, 8)*(1.0+ZRka*sin(2.0*pi*(dy-355)/365.24)) ;
	double K4 ;
	if (ISA.flag3H) {
		// Если используются 3-часовые индексы
		K4 = 1.0+
			(e[0]+(e[1]+(e[2]+(e[3]+e[4]*h)*h)*h)*h)*
			(et[0]+(et[1]+(et[2]+et[3]*kpp)*kpp)*kpp) ;
		// В приведенной выше формуле значения коэффициента kpp
		// должно вычисляться с запаздыванием на 0,25 суток
	} else {
		// Если используются среднесуточные индексы
		K4 = 1.0+
			(e[0]+(e[1]+(e[2]+(e[3]+e[4]*h)*h)*h)*h)*
			(e[5]+(e[6]+(e[7]+e[8]*Kp)*Kp)*Kp) ;
		// В приведенной выше формуле значения коэффициента Kp
		// должно вычисляться с запаздыванием на 0,6 суток
	}
	// безразмерная величина
	double K3 = 1.0+(b[0]+(b[1]+(b[2]+(b[3]+b[4]*h)*h)*h)*h)* 
		       (F107-F81)/(F81+fabs(F107-F81)) ;
	// безразмерная величина
	double K2 = 1.0+(d[0]+(d[1]+(d[2]+d[3]*h)*h)*h)*Ad ; 
	// безразмерная величина
	double K1 = 1.0+(c[0]+(c[1]+(c[2]+(c[3]+c[4]*h)*h)*h)*h)* 
		       pow(cfi2, n0+n[0]*h+n[1]*h*h) ;
	// безразмерная величина
	double K0 = 1.0+(l[0]+(l[1]+(l[2]+(l[3]+l[4]*h)*h)*h)*h)* 
		       (F81-F0)/F0 ;

	// Окончательное вычисление плотности с учётом всех коэффициэнтов
	ro = ro0*exp(a[0]+(a[1]+(a[2]+(a[3]+(a[4]+(a[5]+a[6]*h)*h)*h)*h)*h)*h)*
		 K0*K1*K2*K3*K4*K5 ;
 
	return 0 ;
}

//--------------------------------------------------------------------------------
