//----------------------------------------------------------------------------
// ZFarg.cpp
// Вычисление значений фундаментальных аргументов: l,l',F,D, Omega
// А. Николенко 01.03.2019
//----------------------------------------------------------------------------
#include <stdafx.h>
#pragma   hdrstop
#include <FlyMMath.h>	// Математические функции
#include <FlyTime.h>	// Всё про время

#include <FlyCoreSource\\ModGlobal.h>
#include <FlyCoreSource\\ZSiderealTime.h>
#include <FlyCoreSource\\ZFarg.h>

//----------------------------------------------------------------------------
// Planetary longitudes IERS Conventions (2003)
// 
// t - время TT в столетиях от J2000.0
// u - результат-вектор из 9-ти аргументов планет в радианах
void ZArgPlanet(double t, double *u, TIMESCALE Scale)
{
	// Преобразование времени в масштаб юлианских столетий от астрономической
	// эпохи J2000
	t = Astro2000Time(t, Scale, nullptr) ;

	u[0] = 4.402608842 + 2608.7903141574*t;		//Mercury
	u[1] = 3.176146697 + 1021.3285546211*t;		//Venus
	u[2] = 1.753470314 + 628.3075849991*t;		//Earth
	u[3] = 6.203480913 + 334.0612426700*t;		//Mars				
	u[4] = 0.599546497 + 52.9690962641*t;		//Jupiter
	u[5] = 0.874016757 + 21.3299104960*t;		//Saturn
	u[6] = 5.481293872 + 7.4781598567*t;		//Uranus
	// IERS Conventions 2000 for Neptune
	// u[7] = 5.311886287 + 3.8133035638*t;		//Neptune 
	// Neptune longitude (MHB2000). 
	u[7] = 5.321159000 + 3.8127774000*t;		//Neptune 
	u[8] =(0.024381750 + 0.00000538691*t)*t;	//pa precession rate

	// Преобразование к интервалу от 0 до 2*pi
	for (int i=0; i<9; i++) {  
		u[i] = fmod(u[i],k_dwapi) ;
		u[i] = u[i]<0 ? u[i]+k_dwapi : u[i] ;
	}
}

//----------------------------------------------------------------------------
// Расчёт дополнительных аргументов параметров нутации
// Время t в юлианских столетиях
void ZFArgAdv(double t, double *u, char FlagCalc)
{
	if(FlagCalc==1) { 
		// расчёт GMST+PI
		u[5] = ZAverageSiderealTime(t*36525-del_TDT/k_cbc)*k_dwapi+k_pi ;
		u[5] = fmod(u[5],k_dwapi); // убираю целые циклы
	}
	if(FlagCalc==2) {
		// расчёт планетных членов
		ZArgPlanet(t, u+5) ; 
	}
}

//----------------------------------------------------------------------------
// Вычисление фундаментальных аргументов в соответствии 
// с соглашением 1980 года
//		u		 - результат-вектор из 5-ти аргументов l,l',F,D,Omega в рад.
//		FlagCalc - флаг расчёта 
//				   0 - 5 параметров(по умолчанию),
//				   1 - 5 + GMST+PI, 
//				   2 - 5 + Planet
//		Scale	 - масштаб 
void ZFArgIAU1980(double t, double *u, char FlagCalc, TIMESCALE Scale)
{
	double ta ; 
	t = Astro2000Time(t, Scale, &ta) ;

	const static double a[5][4] = {
	// RD_50_25645
	//   t3      t2			t			 своб член полинома 
	{  0.064,  31.310,	17179159227.633,  485866.733 },   // Средняя аномалия Луны
	{ -0.012,  -0.577,	  129596581.224, 1287099.804 },   // Средняя аномалия Солнца
	{  0.011, -13.257,	 1739527263.137,  335778.877 },   // L-Omega
	{  0.019,  -6.891,	 1602961601.328, 1072261.307 },   // Средняя элонгация (разность средних долгот) Луны и Солнца
	{  0.008,	7.455,	   -6962890.539,  450160.280 } } ;// Средняя долгота восходящего узла орбиты Луны на эклиптике                              };

	// Расчёт основных фундаментальных аргументов
	for(int i=0 ; i<5 ; i++) {
		double x = a[i][0] ;
		for(int j=1 ; j<4 ; j++) x = x*t+a[i][j] ;
		// 1296000 Угловых секунд в 360 градусах
		// Удаляем целое число оборотов
		// y/1296000 - это значение параметра в оборотах - целая и дробная часть
		u[i] = x - floor(x/1296000.)*1296000. ;
		// Перевод из угловых секунд в радианы
		u[i]*= k_pi/180.0/3600.0 ;
	}

	// Расчёт дополнительных аргументов
	ZFArgAdv(t, u, FlagCalc) ;
	return ;
}

//----------------------------------------------------------------------------
// Вычисление фундаментальных аргументов в соответствии 
// с IERS Convention 2003 года
// Вычисление фундаментальных аргументов в соответствии с 
//		u		 - результат-вектор из 5-ти аргументов l,l',F,D,Omega в рад.
//		FlagCalc - флаг расчёта 
//				   0 - 5 параметров(по умолчанию),
//				   1 - 5 + GMST+PI, 
//				   2 - 5 + Planet
//		Scale	 - масштаб 
void ZFArgIAU2000(double t, double *u, char FlagCalc, TIMESCALE Scale)
{
	t = Astro2000Time(t, Scale, nullptr) ;

	const static double a[5][5] = {
	// Convention_2003
	//t4         t3         t2       t                 своб член полинома 
	// Mean anomaly of the Moon. 
	{-24.470e-5, 5.1635e-2, 31.8792, 1717915923.2178,  485868.249036},   
	//-0.00001149
	//-0.00011490 ???????
	// Mean anomaly of the Sun. 
	//{-11.49e-6,  -0.0136e-2,  -0.5532,  129596581.0481, 1287104.793048},   
	{-11.49e-6,   0.0136e-2,  -0.5532,  129596581.0481, 1287104.793048},   
	// Mean argument of the latitude of the Moon. L-Omega
	{  0.417e-5, -0.1037e-2, -12.7512, 1739527262.8478,  335779.526232},    
	// Mean elongation of the Moon from the Sun. 
	// Средняя элонгация (разность средних долгот) Луны и Солнца
	{ -3.169e-5,  0.6593e-2,  -6.3706, 1602961601.2090, 1072260.703692},    
	// Mean longitude of the ascending node of the Moon. 
	// Средняя долгота восходящего узла орбиты Луны на эклиптике
	{ -5.939e-5,  0.7702e-2,   7.4722,   -6962890.5431,  450160.398036}} ; 

	// Расчёт основных фундаментальных аргументов
	for( int i=0; i<5; i++) {
		double y = 0 ;
		for(int j=0; j<5; j++) y = y*t+a[i][j] ;
		// 1296000 Угловых секунд в 360 градусах
		// y/1296000 - это значение параметра в оборотах - целая и дробная часть
		u[i] = y - floor(y/1296000.)*1296000. ;
		// Перевод из угловых секунд в радианы
		u[i]*= k_pi/180.0/3600.0 ;
	}
	// Расчёт дополнительных аргументов
	ZFArgAdv(t, u, FlagCalc) ;
}

//----------------------------------------------------------------------------
// Вычисление фундаментальных аргументов по заданной модели
//
void ZFArg(double t, double *u, char FlagCalc, 
		   TIMESCALE Scale, MODEL_FARG ModFarg)
{
	switch(ModFarg){
		case FARG1980:
			ZFArgIAU1980(t, u, FlagCalc, Scale) ;
			break ;
		case FARG2000:
			ZFArgIAU2000(t, u, FlagCalc, Scale) ;
			break ;
		default: assert(0) ;
	}
}

//----------------------------------------------------------------------------