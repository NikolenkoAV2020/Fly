//------------------------------------------------------------------------------
// MSimplex.cpp
// А. Николенко 03.08.2018
//------------------------------------------------------------------------------
#include <stdafx.h>
#pragma hdrstop
//------------------------------------------------------------------------------
#include <FlyMMathSource\\MMath.h>
//------------------------------------------------------------------------------
// Решение задачи линейного программирования Симплекс методом
//   nV    - число переменных
//   nG    - число ограничений (<числа переменных)
//   K     - вектор коэфициентов линейной формы
//   A     - матрица ограничений
//   B     - вектор правых частей ораничений
//   TypeA - типы ограничений ( 0 - "=", 1 - ">=", 2 - "<=" )
//   Результаты
//   X     - значения переменных доставляющие максимум функционалу
//   F     - значение функционала
// Возвращаемое значение
//   0  - решение успешно завершено
//   1  - арифметическая ошибка
//  -1  - система ограничений не совмесчтна
//  -2  - число переменных равно числу ограничений равенства
//  -3  - число переменных меньше числа ограничений равенства
//  -4  - ошибка выделения памяти
//  -5  - ошибка формирования начального базиса
//------------------------------------------------------------------------------
int SolutionSimplex( int nV, int nG, double* pK, double* pA, double* pB, int* TypeA, double* pX, double* pF )
{
    int     rc =  0, i, j, l, k, iin, iout ;
    int     n = nG ;
    int     m = nV ;
    int     cnt = 0 ;
    int*    I ;
    double  F = 0 ;
    double* X = 0 ;
    double* K = 0 ;
    double* B = 0 ;
    double**A = 0 ;
    double  maxK, D, minD ;
    //--------------------------------------------------------------------------
    // Подсчёт числа фиктивных переменных
    for ( i = 0 ; i < nG ; i++ ) if ( TypeA[ i ] ) m++ ;
    // Выделение памяти
    A = new double*[ nG ] ; if ( !A ) { rc =-4 ; goto end ; }
    memset( A, 0, nG * sizeof( double* ) ) ;
    K = new double[ m ] ; if ( !K ) { rc =-4 ; goto end ; }
    memcpy( K, pK, nV * sizeof( double ) ) ;
    if ( m > nV ) memset( &K[ nV ], 0, ( m - nV ) * sizeof( double ) ) ;
    B = new double[ nG ] ; if ( !B ) { rc =-4 ; goto end ; }
    memcpy( B, pB, nG * sizeof( double ) ) ;
    X = new double[ m ] ; if ( !X ) { rc =-4 ; goto end ; }
    memset( X, 0, m * sizeof( double ) ) ;
    I = new int[ m ] ; if ( !I ) { rc =-4 ; goto end ; }
    memset( I, 0, m * sizeof( int ) ) ;
    //--------------------------------------------------------------------------
    // Формирование матрицы ограничений (все ограничения к равенству или <= )
    k = 0 ;
    for ( i = 0 ; i < nG ; i++ ) {
      A[ i ] = new double[ m ] ; if ( !A[ i ] ) { rc =-4 ; goto end ; }
      memcpy( A[ i ], &pA[ i * nV ], nV * sizeof( double ) ) ;
      memset(&A[ i ][ nV ], 0, ( m - nV ) * sizeof( double ) ) ;
      if ( TypeA[ i ] ) {
        // "<= или >="
        A[ i ][ nV + k ] = 1.0 ; k++ ;
        if ( TypeA[ i ] == 1 ) {
          // ">="
          A[ i ][ nV + k - 1 ] =-1.0 ;
          B[ i ] =-B[ i ] ;
          for ( j = 0 ; j < nV ; i++ ) A[ i ][ j ] =-A[ i ][ j ] ; 
    } } } 
    //--------------------------------------------------------------------------
    // Проверка исходных жанных
    if ( m == nG ) { rc =-2 ; goto end ; }
    if ( m <= nG ) { rc =-3 ; goto end ; }
    //--------------------------------------------------------------------------
    // Формирование начального базиса
    // Дополнение неравенств до равенств
    k = 0 ;
    for ( i = 0 ; i < nG ; i++ ) {
      if ( TypeA[ i ] ) {
        I[ i ] = nV + k + 1 ;
        X[ I[ i ] - 1 ] = B[ i ] ;
        k++ ;
    } }
    // Выбор оставшихся базисных переменных
    // Все ограничения имеют теперь тип равенства
    if ( k != nG ) {
      for ( i = 0 ; i < nG ; i++ ) {
        if ( !TypeA[ i ] ) {
          D = 0 ;
          iin =-1 ;
          // Поиск максималльного коэффициента
          for ( j = 0 ; j < nV ; j++ ) {
            if ( fabs( D ) < fabs( A[ i ][ j ] ) ) { D = A[ i ][ j ] ; iin = j ; }
          }
          if ( D == 0 || iin ==-1 ) { rc =-5 ; goto end ; }
          // Переобразование текущей строки
          D = A[ i ][ iin ] ;
          B[ i ] /= D ;
          for( j = 0 ; j < nV ; j++ ) A[ i ][ j ] /= D ;
          A[ i ][ iin ] = 1.0 ;
          // Переобразование остальных строк
          for( l = 0 ; l < n ; l++ ) {
            D =-A[ l ][ iin ] ;
            if ( l == i ) continue ;
            if ( fabs( D ) < 1e-13 ) continue ;
            B[ l ]+= B[ i ] * D ;
            for( j = 0 ; j < nV ; j++ ) {
              A[ l ][ j ]+= A[ i ][ j ] * D ;
          } }
          // Сохраняем номер выбранной базисной переменной
          I[ i ] = iin + 1 ;
          k++ ;
    } } }
    // Проверка корректности формирования начального базиса
    if ( k != nG ) { rc =-5 ; goto end ; }
    // Формирование начальных значений базисных переменных
    for ( i = 0 ; i < nG ; i++ ) X[ I[ i ] - 1 ] = B[ i ] ; 
    //--------------------------------------------------------------------------
    // Отображение
    //ShowRez( TKZ.nV,TKZ.nG, m, A, K, B, TKZ.TypeA, X, F ) ;
    //--------------------------------------------------------------------------
    // Перебор опорных решений
    cnt = 0 ;
    while( 1 ) {
      // Проверка условия завершения процесса
      for( i = 0 ; i < nV ; i++ ) if ( K[ i ] > 0 && X[ i ] == 0 ) break ;
      if ( i >= nV )  break ;
      //------------------------------------------------------------------------
      // Определение переменной для включения в базис
      maxK = 0 ;
      for( i = 0 ; i < m ; i++ ) {
        if ( K[ i ] > maxK && X[ i ] == 0 ) {
          maxK = K[ i ] ;
          iin = i ; // номер включаемой переменной
      } }
      if ( maxK <= 0 ) break ;
      // Определение переменной для исключения из базиса
      iout =-1 ;
      for( i = 0 ; i < nG ; i++ ) {
        if ( A[ i ][ iin ] <= 0 ) continue ;
        D = B[ i ] / A[ i ][ iin ] ;
        if ( iout < 0 || minD > D ) { minD = D ; iout = i ; }
      }
      if ( iout == -1 ) { rc = 1 ; goto end ; }
      k = iout ;      // Номер основной строки
      iout = I[ k ] - 1 ; // Номер исключаемой переменной
      //------------------------------------------------------------------------
      // Изменение базиса
      X[ iin ] = minD ;
      X[ iout] = 0 ;
      I[ k ] = iin + 1 ;
      //------------------------------------------------------------------------
      // Преобразование симплексной таблицы
      //
      // Переобразование основной строки
      D = A[ k ][ iin ] ;
      B[ k ] /= D ;
      for( i = 0 ; i < m ; i++ ) A[ k ][ i ] /= D ; 
      // Преобразования остальных ограничений
      for( j = 0 ; j < n ; j++ ) {
        D =-A[ j ][ iin ] ;
        if ( j == k ) continue ;
        B[ j ]+= B[ k ] * D ;
        for( i = 0 ; i < m ; i++ ) A[ j ][ i ]+= A[ k ][ i ] * D ; 
      } 
      // Преобразование функционала
      D =-K[ iin ] ;
      for( i = 0 ; i < m ; i++ ) K[ i ]+= A[ k ][ i ] * D ; 
      // Новое значение базисного вектора
      memset( X, 0, m * sizeof( double ) ) ;
      for( i = 0 ; i < nG ; i++ ) {
        X[ I[ i ] - 1 ] = B[ i ] ;
      }
      // Расчёт значения функционала
      F = 0 ;
      for( i = 0 ; i < nV ; i++ ) F += pK[ i ]*X[ i ] ;
      //------------------------------------------------------------------------
      // Отображение
      //ShowRez( TKZ.nV,TKZ.nG, m, A, K, B, TKZ.TypeA, X, F ) ;
      //------------------------------------------------------------------------
      // Переход к очередному шагу симплекс метода
      cnt++ ;
    }
    // Результаты решения
    if ( pF ) memcpy( pX, X, nV * sizeof( double ) ) ;
    if ( pF ) *pF = F ;
    // Завершение работы программы
end : ;
    //--------------------------------------------------------------------------
    // Освобождение временных ресурсов
    for ( i = 0 ; i < nG ; i++ ) { if ( A[ i ] ) delete[] A[ i ] ; A[ i ] = 0 ; }
    if ( A ) delete[] A ; A = 0 ;
    if ( I ) delete[] I ; I = 0 ;
    if ( X ) delete[] X ; X = 0 ;
    if ( K ) delete[] K ; K = 0 ;
    if ( B ) delete[] B ; B = 0 ;
    return rc ;
}
//---------------------------------------------------------------------------

