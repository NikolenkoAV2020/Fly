//---------------------------------------------------------------------------
// TheTimes.cpp
// А. Николенко 12.08.2018
// 
// Всё о времени.
//	- Представление времени в различных эпохах и масштабах
//	- Пересчёт времени между различными его представлениями
//	- Хранение времени с удержанием максимального колличества значащих цыфр
//---------------------------------------------------------------------------
#include "stdafx.h"

//---------------------------------------------------------------------------
// Компоненты Fly
#include <FlySofa.h>	// Функции фундаментальной астрономии

//---------------------------------------------------------------------------
#include <FlyTimeSource\\TheTimes.h>

#define SOFATIMES 

TheUT1UTC UT1UTC ;

//---------------------------------------------------------------------------
// Скачки атомного времени для согласования с UTC1
// в указанные даты имеет место быть доп. секунда 23.59.60
// после которой следует 00.00.01 секунда следующей даты 
//(вместо 00.00.01 после 23.59.59) 
TheLeapSecond TheTimes::IAT_LEAP[Count_UTC_IAT_LEAP+1] = {
    //MJD      Date          UTC-IAT (s)
	41317.0,    1,  1, 1972, -10,
    41499.0,    1,  7, 1972, -11,
    41683.0,    1,  1, 1973, -12,
    42048.0,    1,  1, 1974, -13,
    42413.0,    1,  1, 1975, -14,
	// Начало эпохи 1975 года 
    42778.0,    1,  1, 1976, -15,
    43144.0,    1,  1, 1977, -16,
    43509.0,    1,  1, 1978, -17,
    43874.0,    1,  1, 1979, -18,
    44239.0,    1,  1, 1980, -19,
    44786.0,    1,  7, 1981, -20,
    45151.0,    1,  7, 1982, -21,
    45516.0,    1,  7, 1983, -22,
    46247.0,    1,  7, 1985, -23,
    47161.0,    1,  1, 1988, -24,
    47892.0,    1,  1, 1990, -25,
    48257.0,    1,  1, 1991, -26,
    48804.0,    1,  7, 1992, -27,
    49169.0,    1,  7, 1993, -28,
    49534.0,    1,  7, 1994, -29,
    50083.0,    1,  1, 1996, -30,
    50630.0,    1,  7, 1997, -31,
    51179.0,    1,  1, 1999, -32,
	// Начало эпохи 2000 года 
    53736.0,    1,  1, 2006, -33,
    54832.0,    1,  1, 2009, -34,
    56109.0,    1,  7, 2012, -35,
    57204.0,    1,  7, 2015, -36,
    57754.0,    1,  1, 2017, -37,
	9999999.0,  1,  1, 9999, -37 } ;

//---------------------------------------------------------------------------
TheTimes::TheTimes() : TheJD()
{
	iat	  = 0 ;
	UTC	  = 0 ;
	UT1	  = 0 ;
	TT	  = 0 ;
	TDB	  = 0 ;
	AT	  = 0 ;
	MST   = 0 ;
	TST   = 0 ;	
	S     = 0 ;

	DMB.Clear() ;
	CoordSec = 0 ;

	if (!UT1UTC.IsLoad()) UT1UTC.Load() ;
}

//---------------------------------------------------------------------------
TheTimes::TheTimes(const TheTimes& T) : TheJD((TheJD)T)
{
	memcpy(this, &T, sizeof(T)) ;
}

//---------------------------------------------------------------------------
TheTimes::~TheTimes()
{

}

//---------------------------------------------------------------------------
TheTimes& TheTimes::operator = (TheDblTime t){ fromIAT(t) ; return *this ; }
TheTimes& TheTimes::operator = (TheTimes& T) { fromIAT(T.iat) ; return *this ; }

//---------------------------------------------------------------------------
TheTimes& TheTimes::operator+= (TheDblTime dt) { fromIAT(iat+dt) ; return *this ; }
TheTimes& TheTimes::operator-= (TheDblTime dt) { fromIAT(iat-dt) ; return *this ; }

//---------------------------------------------------------------------------
TheTimes operator + (TheTimes& T, TheDblTime dt) { TheTimes A(T) ; A+= dt ; return A ; }
TheTimes operator + (TheDblTime dt, TheTimes& T) { TheTimes A(T) ; A+= dt ; return A ; }
TheTimes operator - (TheTimes& T, TheDblTime dt) { TheTimes A(T) ; A-= dt ; return A ; }
TheTimes operator - (TheDblTime dt, TheTimes& T) { TheTimes A(T) ; A-= dt ; return A ; }

//---------------------------------------------------------------------------
TheDblTime operator - (TheTimes& T1, TheTimes& T2) 
{ 
	TheDblTime R(T1.iat) ; R-= T2.iat ; return R ; 
}

//---------------------------------------------------------------------------
double TheTimes::IAT() { return (iat.LikeDouble()) ; }

//---------------------------------------------------------------------------
// Вычисление по таблице разницы целого числа секунд между 
// Всемирным координированным временем и атомным временем  UTC-IAT
double TheTimes::FindLeapCoordSec(TheDblTime iat, bool fromJ2000)  
{
	// Примерное (с точностью до скачка значения MJD)
	// к атомному времени от J2000 прибавим юлианскую дату этой эпохи
	double mjd = iat.LikeDouble()+TheT_MJD2000 ;
	// Определение запаздывания UTC относительно IAT
	int i ;
	for (i=0 ; i<Count_UTC_IAT_LEAP ; i++) { if (mjd < IAT_LEAP[i].MJD) break ; }
	double Sec = i?IAT_LEAP[i-1].sec:0 ;
	// Учёт скачка в MJD
	mjd = iat.LikeDouble()+Sec/86400.0+TheT_MJD2000 ;
	// Точное определение запаздывания UTC относительно IAT
	for (i=0 ; i<Count_UTC_IAT_LEAP ; i++) { if (mjd < IAT_LEAP[i].MJD) break ; }
	Sec = i?IAT_LEAP[i-1].sec:0 ;
	// Если нужен скачёк только от эпохи J2000
	if (fromJ2000) {
		Sec-= TheT_LEAP_UTC_1975to2000 ;
	}
	return Sec ;
}

//---------------------------------------------------------------------------
// Итак чтоб избежать путаницы изложем все известные соотношения между масштабами времени 
//
// 1) UT1 - всемирное время, как фаза поворота Земли.
//  Не является равномерным, зависит от вращения Земли 
//
// 2) UTC - всемирное координированное время, отличается от UT1 на величину не 
//  более 0.9 сек. От атомного времени отличается на целое число секунд координации
//
// 3) iat - Атомное время - время равномерно текущее, единица измерения 1-а 
//  секунда СИ. За момент начала отсчёта атомного времени можно взять любой 
//  момент времени. Главноя суть этого времени, его равномерность, от этого не изменится.  
//  Основное предназначение данного времени - служить аргументов системы диффен-
//  ренциальных уравнений движения - тем самым аргументом по которому идет 
//  интегрирование параметров движения. Так в ранних версиях СМПО в/ч25840 и в/ч73790  
//  за момент начала отсчёта атомного времние был принят момент так называемой эпохи
//  B1975 - 01.01.1975 0h. В последних модификациях СМПО отсчёт времени ведётся от 
//  момента 01.01.2000 0h. 
//  Здесь и далее будем полагать точно так же и будем обозначать данное время "iat". 
//  iat = 0 соответствует времени UTC = 0h, iat = 1.5 соответствует времени 
//  UTC = 12h + 1JD (плюс 1 юлианский день) 
//  отсчитанному от иодифицированной юлианской даты 51544.0 (01.01.2000 0h), то есть 
//			iat = UTC+(NMJD-51544.0) 
//			NMJD- номер модифицированного юлианского дня        
//			UTC - всемирное координированное время, отличающееся от атомного на
//			      целое число секунд координации.
//  для согласования iat и UTC используются значение секунды координации. Данное
//  значение изменяется периодически введением дополнительной секунды. Для времени  
//  отсчитываемого от эпохи 2000 года такие секуды вводились:
//			MJD      Date      UTC-IAT(s) дополнительная секунда координации
//			53736.0, 1.1.2006, -1,        31.12.2005 23h59m60s
//			54832.0, 1.1.2009, -2,        31.12.2008 23h59m60s
//			56109.0, 1.7.2012, -3,        30.06.2012 23h59m60s
//			57204.0, 1.7.2015, -4,        30.06.2015 23h59m60s 
//			57754.0, 1.1.2017, -5,        31.12.2016 23h59m60s
//  Значение секунды координации позволяет преобразовать значение iat в связанную
//  пару значений  UTC+MJD, а из последних получить календарную дату и гражданское 
//  время на гринвиче (то есть UT-всемирное время), прибавив к последнему 3 часа,
//  получаем дату и время ДМВ.
//
// 4) iat75 Аналогичная ситуация имеет место быть с атомным временем отсчитанным 
//  от эпохи B1975 - время iat75. Только в этом случае таблица секунд 
//  координации будет иметь вид:
//			MJD      Date      UTC-IAT(s) дополнительная секунда координации
//			41317.0, 1.1.1972, -10,		  31.12.1971 23h59m60s
//			41499.0, 1.7.1972, -11,       30.06.1972 23h59m60s
//			41683.0, 1.1.1973, -12,       31.12.1972 23h59m60s 
//			42048.0, 1.1.1974, -13,       31.12.1973 23h59m60s 
//			42413.0, 1.1.1975, -14,       31.12.1974 23h59m60s 
//			Начало эпохи 1975 года 
//			42778.0, 1.1.1976, -15,       31.12.1975 23h59m60s 
//			43144.0, 1.1.1977, -16,       31.12.1976 23h59m60s 
//			43509.0, 1.1.1978, -17,       31.12.1977 23h59m60s 
//			......................
//			51179.0, 1.1.1999, -32,       31.12.1998 23h59m60s 
//			Начало эпохи 2000 года 
//			53736.0, 1.1.2006, -33,		  31.12.2005 23h59m60s
//			54832.0, 1.1.2009, -34,		  31.12.2008 23h59m60s
//			56109.0, 1.7.2012, -35,		  30.06.2012 23h59m60s
//			57204.0, 1.7.2015, -36,		  30.06.2015 23h59m60s
//			57754.0, 1.1.2017, -37,		  31.12.2016 23h59m60s
//
//			DUTC = UTC-IAT
//			iat75 = UTC-DUTC
//  То есть по состоянию на 2018 года 
//          iat75 = UTC+37(сек)
//
// 5) TT - Земное время - также как и атомное время равномерно текущее.  
//  TT опережает атомное время на постоянную величину 
//			32.184 секунды.
//  Отличие TT от всемирного времени с учётом секунд координации можно
//  определить из таблицы
//			MJD      Date      TT-UTC(s) 
//			48257.0, 1.1.1991, 58.184,
//			48804.0, 1.7.1992, 59.184,
//			49169.0, 1.7.1993, 60.184,
//			49534.0, 1.7.1994, 61.184,
//			50083.0, 1.1.1996, 62.184,
//			50630.0, 1.7.1997, 63.184,
//			51179.0, 1.1.1999, 64.184,
//			Начало эпохи 2000 года 
//			53736.0, 1.1.2006, 65.184,
//			54832.0, 1.1.2009, 66.184,
//			56109.0, 1.7.2012, 67.184,
//			57204.0, 1.7.2015, 68.184,
//			57754.0, 1.1.2017, 69.184,
//	Таким образом получается что 
//			TT = UTC + dT, 
//	например в 2000 году
//			TT = UTC + 65.184.
//  
// 6) TDB - Барицентрическое динамическое время.
//  В пределах солнечной системы пользуются равномерной шкалой
//  барицентрического динамического времени TDB. В этой шкале вычисляютися
//  положения Луны, Солнца, планет, параметры прецессии и нутации.
//  TDB вычисляется следующим образом:
//			d = (TT-51544.5)/36525  - это интервал времени в юлианских 
//  столетиях от эпохи J2000 (по смыслу это время `AT), TT соответственно 
//  выражено тоже в модифицированных юлианских днях.
//          Средняя аномалия Солнца
//			Версия MAC 1991 год
//			g = (pi/180.0)*(357.528+35999.0501*d)           
//			Версия MAC 2000 год
//			g = (pi/180.0)*(357.5291092+35999.0502909*d-0.0001536*d*d+d*d*d/24490000.0)
//			Версия ....
//			g = (pi/180.0)*(358.476+35999.0498*d)           
//			g = (pi/180.0)*(357.52772+35999.050340*d-0.0001603*d*d-d*d*d/300000.0)
//			Собственно само барицентрическое время
//			TDB = TT(сcc) + 0.001658*sin(g+0.0167*sin(g)) / 86400
//			можно упростить и тогда получится
//			TDB = TT(сек) + 0.001658(сек)*sin(g)+0,0000138443(сек)*sin(2g)
//  Таким образом TDB отличается от Земного времени TT на периодическую
//  величину с амплитудой не более 0.0017 секунды!!!!!! Поэтому для многих 
//	расчётов можно полагать:
//			TDB = TT
//	
// 7) AT - время для рассчёта астрономических данных - равномерное время,
//  прошедшее от эпохи J2000, выраженное в юлианских столетиях 
//			AC = (t-51544.5) / 36525.0 
//  Если имеется атомное время iat, то
//			AC = iat / 36525.0 
//
//---------------------------------------------------------------------------
void TheTimes::fromIAT(TheDblTime& t) 
{
#ifdef SOFATIMES 
	//-----------------------------------------------------------------------
	// Атомное время
	iat = t ; 
	//-----------------------------------------------------------------------
	// Время UTC атомному уже с учётом секунд координации
	int rc ; 
	rc = iauTaiutc(iat.days, iat.sec/86400.0, &UTC.days, &UTC.sec) ;
	UTC.sec*= 86400.0 ;
	//-----------------------------------------------------------------------
	// Время UT1 полагаем равным UTC
	double DUT1 ;	// UT1 - UTC
	UT1UTC.Amendment(UTC, DUT1) ;
	UT1 = UTC+DUT1/1e3/86400.0 ;
	//-----------------------------------------------------------------------
	// Дикретное московское время
	BuildDMB() ;
	// барицентрическое, земное динамическое, астрономическое
	BuildTDBTTAT() ;
	// Значение секунд координации
	BuildLeapSec() ;
#else
	// Атомное время от эпохи 2000
	iat = t ; 

	//-----------------------------------------------------------------------
	// Атомное время от эпохи J1975	
	iat75 = t ;
	iat75+= DblTime_J2000toJ1975 ;

	//-----------------------------------------------------------------------
	// Значение секунд координации
	CoordSec = FindLeapCoordSec(iat, false) ;
	double LS00 = CoordSec-TheT_LEAP_UTC_1975to2000 ; 

	//-----------------------------------------------------------------------
	// время UTC. Необходимо учесть секунды координации введённые с момента
	// 01.01.2000 0h
	UTC = iat+LS00/k_cbc ;

	//-----------------------------------------------------------------------
	// Время UT1 полагаем равным UTC
	UT1 = UTC ;

	BuildTDBTTAT() ;
	BuildDMB() ;
#endif
}

//---------------------------------------------------------------------------
void TheTimes::fromUTC(TheDblTime& utc) 
{
#ifdef SOFATIMES
	int rc ; 
	// UTC
	UTC = utc ;
	// UT1
	double DUT1 ;	// UT1-UTC
	UT1UTC.Amendment(UTC, DUT1) ;
	UT1 = UTC+DUT1/1e3/86400.0 ;
	// Атомное время
	rc = iauUtctai(UTC.days, UTC.sec/86400.0, &iat.days, &iat.sec) ;
	iat.sec*= 86400.0 ;
	//-----------------------------------------------------------------------
	// Дикретное московское время
	BuildDMB() ;
	// барицентрическое, земное динамическое, астрономическое
	BuildTDBTTAT() ;
	// Значение секунд координации
	BuildLeapSec() ;
#else 
	// Значение секунд координации
	CoordSec = FindLeapCoordSec(utc, false) ;
	double LS00 = CoordSec-TheT_LEAP_UTC_1975to2000 ; 

	//-----------------------------------------------------------------------
	// Время IAT. Необходимо учесть секунды координации введённые с момента
	// 01.01.2000 0h	
	iat = utc-LS00/k_cbc ;
	// Атомное время от 01.01.1975 0h (по UT)
	iat75 = iat ;
	iat75+= DblTime_J2000toJ1975 ;

	//-----------------------------------------------------------------------
	// Время UT1 полагаем равным UTC
	UTC = utc ;
	UT1 = UTC ;

	//-----------------------------------------------------------------------
	// Дикретное московское время
	BuildDMB() ;
	// барицентрическое, земное динамическое, астрономическое
	BuildTDBTTAT() ;
#endif
}

//---------------------------------------------------------------------------
void TheTimes::fromUTC(DATETIMEUTC& dtutc) 
{
#ifdef SOFATIMES
	int rc = 0 ;
	//-----------------------------------------------------------------------
	// Время UTC 
	// SOFA CALL
	rc = iauDtf2d("UTC", dtutc.G, dtutc.M, dtutc.D, dtutc.h, dtutc.m, dtutc.s+dtutc.d, &UTC.days, &UTC.sec) ;
	UTC.sec*= 86400.0 ;
	//-----------------------------------------------------------------------
	// Время UT1 
	double DUT1 ;	// UT1 - UTC
	UT1UTC.Amendment(UTC, DUT1) ;
	UT1 = UTC+DUT1/1e3/86400.0 ;
	//-----------------------------------------------------------------------
	// Атомное время
	// SOFA CALL
	rc = iauUtctai(UTC.days, UTC.sec/86400.0, &iat.days, &iat.sec) ;
	iat.sec*= 86400.0 ;
	//-----------------------------------------------------------------------
	// Дикретное московское время
	BuildDMB() ;
	// барицентрическое, земное динамическое, астрономическое
	BuildTDBTTAT() ;
	// Значение секунд координации
	BuildLeapSec() ;
#else
	// вычисление UTC как времени двойной точности
	TheDblTime mjd, mjd0 ;
	double     H = dtutc.h+dtutc.m/60.0+(dtutc.s+dtutc.d)/3600.0 ;
	DMYHtoMJD(dtutc.D, dtutc.M, dtutc.G, &H, &mjd) ;
	Time.h = dtutc.h ; Time.m = dtutc.m ;
	Time.s = dtutc.s ; Time.d = dtutc.d ;
	mjd0= mjd ;
	mjd-= TheT_MJD2000 ;
	mjd+= 0.5 ;
	UTC = mjd ;

	//-----------------------------------------------------------------------
	// Время UT1 полагаем равным UTC
	UT1 = UTC ;

	//-----------------------------------------------------------------------
	// Вычисление ДМВ
	TheJD TJ ;
	// учёт зональной поправки - ДМВ на 3 часа идёт вперёд всемирного времени
	mjd0+= 0.125 ;
	TJ.MJDtoDMYH(mjd0) ;
	// Копирование даты
	DMB << TJ.Date ;
	// Копирование времени
	DMB << TJ.Time ;

	//TheDblTime utc ; utc << dtutc ;
	// Значение секунд координации
	CoordSec = FindLeapCoordSec(UTC, false) ;
	double LS00 = CoordSec-TheT_LEAP_UTC_1975to2000 ; 

	//-----------------------------------------------------------------------
	// Время IAT. Необходимо учесть секунды координации введённые с момента
	// 01.01.2000 0h	
	iat = UTC-LS00/k_cbc ;
	// Атомное время от 01.01.1975 0h (по UT)
	iat75 = iat ;
	iat75+= DblTime_J2000toJ1975 ;

	BuildTDBTTAT() ;
#endif
}

//---------------------------------------------------------------------------
void TheTimes::fromDMB(DATETIMEDMB& dmv) 
{
#ifdef SOFATIMES
	//-----------------------------------------------------------------------
	// Время UTC 
	// SOFA CALL
	int rc ;
	rc = iauDtf2d("UTC", dmv.G, dmv.M, dmv.D, dmv.h, dmv.m, dmv.s+dmv.d, &UTC.days, &UTC.sec) ;
	UTC.sec*= 86400.0 ;
	UTC-= 0.125 ;
	//-----------------------------------------------------------------------
	// Дата и Время UTC календарные 
	UTC >> DTUTC ;
	// Модифицированная юлианская дата на гринвиче
	MJD = UTC ;
	MJD-= TheT_MJD_ORIGIN ;
	//Доля суток в часах на гринвиче
	JDH = MJD.sec/3600.0 ;
	//-----------------------------------------------------------------------
	// Время UT1 полагаем равным UTC
	double DUT1 ;	// UT1 - UTC
	UT1UTC.Amendment(UTC, DUT1) ;
	UT1 = UTC+DUT1/1e3/86400.0 ;
	//-----------------------------------------------------------------------
	// Атомное время
	// SOFA CALL
	rc = iauUtctai(UTC.days, UTC.sec/86400.0, &iat.days, &iat.sec) ;
	iat.sec*= 86400.0 ;
	// барицентрическое, земное динамическое, астрономическое
	BuildTDBTTAT() ;
	// Значение секунд координации
	BuildLeapSec() ;
#else 
	int rc = 0 ;
	// Время ДМВ
	DMB = dmv ;
	double H = dmv.h+dmv.m/60.0+(dmv.s+dmv.d)/3600.0 ;

	// Модифицырованная юлианская дата
	TheJD TJ ; TJ.DMYHtoMJD(dmv.D, dmv.M, dmv.G, &H) ;
	// Время UTC
	UTC = TJ.MJD-TheT_MJD2000 ;
	UTC+= 0.5 ;
	// Вычитаем 3 часа для пребразования ДМВ к UTC
	UTC-= 0.125 ;
	UT1 = UTC ;

	// Вычисление UTC как календарной даты и времени, 
	// а также времени в часах на Гринвиче.
	TheDblTime mjd(TheT_MJD2000) ; 
	mjd+= UTC ;
	mjd-= 0.5 ;
	MJDtoDMYH(mjd) ;

	// Секунды координации
	CoordSec = FindLeapCoordSec(UTC, false) ;
	double LS00 = CoordSec-TheT_LEAP_UTC_1975to2000 ; 

	//-----------------------------------------------------------------------
	// Время IAT. Необходимо учесть секунды координации введённые с момента
	// 01.01.2000 0h	
	iat = UTC-LS00/k_cbc ;
	// Атомное время от 01.01.1975 0h (по UT)
	iat75 = iat ;
	iat75+= DblTime_J2000toJ1975 ;

	BuildTDBTTAT() ;
#endif
}

//---------------------------------------------------------------------------
// Значение секунд координации
void TheTimes::BuildLeapSec() 
{
#ifdef SOFATIMES
	double fd = DTUTC.h/24.0+DTUTC.m/1440.0+(DTUTC.s+DTUTC.d)/86400.0 ;
	// SOFA CALL
	iauDat(DTUTC.G, DTUTC.M, DTUTC.D, fd, &CoordSec) ; 
	CoordSec =-CoordSec ;
	double LS00 = CoordSec-TheT_LEAP_UTC_1975to2000 ; 
#else 
	CoordSec = FindLeapCoordSec(UTC, false) ;
	double LS00 = CoordSec-TheT_LEAP_UTC_1975to2000 ; 
#endif 
}

//---------------------------------------------------------------------------
void TheTimes::BuildDMB() 
{
#ifdef SOFATIMES
	// Дикретное московское время
	UTC >> DMB ;
	// Дата и время на гринвиче
	UTC >> DTUTC ;
	// Модифицированная юлианская дата на гринвиче
	MJD = UTC ;
	MJD-= TheT_MJD_ORIGIN ;
	//Доля суток в часах на гринвиче
	JDH = MJD.sec/3600.0 ;
#else
	//-----------------------------------------------------------------------
	// Формирование модифицированной юлианской даты
	//double mjd = TheT_MJD2000+UTC.LikeDouble()-0.5 ;
	TheDblTime mjd(TheT_MJD2000) ; 
	mjd+= UTC ;
	mjd-= 0.5 ;
	// Вычисление UTC как календарной даты и времени, 
	// а также времени в часах на Гринвиче.
	MJDtoDMYH(mjd) ;

	//-----------------------------------------------------------------------
	// Вычисление ДМВ
	TheJD TJ ;
	// учёт зональной поправки - ДМВ на 3 часа идёт вперёд всемирного времени
	mjd+= 0.125 ;
	TJ.MJDtoDMYH(mjd) ;
	// Копирование даты
	DMB << TJ.Date ;
	// Копирование времени
	DMB << TJ.Time ;
#endif
}

//---------------------------------------------------------------------------
void TheTimes::BuildTDBTTAT() 
{
#ifdef SOFATIMES
	//-----------------------------------------------------------------------
	// Земное динамическое время
	// SOFA CALL
	int rc ;
	rc = iauTaitt(iat.days, iat.sec/86400.0, &TT.days, &TT.sec) ;
	TT.sec*= 86400.0 ;
	//-----------------------------------------------------------------------
	// "Астрономическое" время
	AT = (TT.days-TheT_JD2000+TT.sec/86400.0)/36525.0 ;
	//-----------------------------------------------------------------------
	// Время динамическое барицентрическое
	// Средняя аномалия Солнца - версия MAC 2000 год
	double AT2 = AT*AT ;
	double g = (DPI/180.0)*(357.5291092+35999.0502909*AT-0.0001536*AT2+AT2*AT/24490000.0) ;
	// Собственно само динамическое барицентрическое время
	TDB = TT ;
	TDB+= 0.001658*sin(g+0.0167*sin(g))/86400.0 ;
#else
	//-----------------------------------------------------------------------
	// Время для рассчёта астроданных
	// Вычесть 0.5 необходимо для учёта того факта что iat отсчистывается от
	// 01.01.2000 0h, а для расчёта астроданных необходимо время отсчитанное от
	// 01.01.2000 12h - то есть от начала эпохи J2000 
	AT = (iat-0.5).LikeDouble() / 36525.0 ;

	//-----------------------------------------------------------------------
	// Земное динамическое время от эпохи 2000
	TT  = (iat75+(TheT_TTMIAT-CoordSec)/k_cbc).LikeDouble() ;

	//-----------------------------------------------------------------------
	// Время динамическое барицентрическое
	// Средняя аномалия Солнца
	// Версия MAC 2000 год
	double AT2 = AT*AT ;
	double g = (k_pi/180.0)*(357.5291092+35999.0502909*AT-0.0001536*AT2+AT2*AT/24490000.0) ;
	// Собственно само динамическое барицентрическое время
	TDB = TT+0.001658*sin(g+0.0167*sin(g))/86400.0 ;
#endif 
}

//---------------------------------------------------------------------------