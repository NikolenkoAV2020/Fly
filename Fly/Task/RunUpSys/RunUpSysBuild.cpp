//-------------------------------------------------------------------------------
// RunUpSysBuild.cpp : 
// А. Николенко 11.12.2018
//-------------------------------------------------------------------------------
#include "stdafx.h"

//---------------------------------------------------------------------------
// Компоненты Fly
#include <FlyCore.h>		// Собственоно сама модель движения
#include <FlyMMath.h>		// Математические функции

//---------------------------------------------------------------------------
#include "RunUpSysBuild.h"		

//-------------------------------------------------------------------------------
// Формирование совокупности НУ для 8-и КА системы "Разбег" (Run Up)
// в двух плоскостях, по 4 КА в каждой плоскости. 
int RunUpSysBuild_4_4(ZNU* NU, ZLSF& LSF, int CountKA) 
{
	cout << "\n Build IS...\n";
	//--------------------------------------------------------------------------	
	// Выбор параметров орбиты - ССО
	// Параметры проектируемой орбиты
	double Havr, Tz, iz, az, pz, ez, e1z, e2z ;
	int    rc ;
	// Заданное значение средней высоты
	Havr = 270 ;
	// Проектирование орбиты по среденей высоте
	rc = MBuildSSOMIV_hs(Havr, Tz, iz, pz, e1z, e2z, nullptr) ; RRC ;
	// Вычисление эксцентриситета и большой полуоси орбиты
	ez = sqrt(e1z*e1z+e2z*e2z) ;
	az = pz/(1-ez*ez) ;

	//-------------------------------------------------------------------------
	// Формирование набора из 8 НУ разнесённых в плоскости на 45 градусов
	ZNU NUK ;
	for (int j=0 ; j<CountKA ; j++) { 
		// "Ключи" НУ
		NU[j].Key.ka = j+1 ; NU[j].Key.nom = 15 ; NU[j].Key.mod = 0 ;
		NU[j].Key.type = 8 ; NU[j].Key.bc = 1 ;
		NU[j].numlsf = 1 ;
		// Дата и время всех НУ одинаковые - все НУ заданы на один момент времени
		DATE dt = DATE(1, 4, 2018);
		TIME tm = TIME(9, 0, 0, 0) ;
		// Пересч1т из ДМВ в атомное время
		TA_DMB(1, &dt, &tm, &NU[j].t) ;
		// Все НУ задаём для 100-го витка 
		NU[j].vit  = 100 ;
		// Система координат - оскулирующие элементы относительно 
		// текущего истинного экватора
		NU[j].sk   = _SK_OSKTE ;
		// Заполняем структуру НУ полученными параметрами движения для ССО
		NU[j].X[0] = TO_DTKM(az) ;
		NU[j].X[1] = ez ;
		NU[j].X[2] = TO_RAD(iz) ;
		// Две плоскости 339.555 и 39.551 град абсолютной долготы
		if ((j/2)*2==j)
			// Для нечётных КА с номерами 1,3... (N КА =j+1) абсолютная
			// долгота узла равна 339.555 град 
			NU[j].X[3] = TO_RAD(339.555) ;
		else 
			// Для чётных КА с номерами 2,4... (N КА =j+1) абсолютная
			// долгота узла равна 39.551 град 
			NU[j].X[3] = TO_RAD(39.551) ;
		NU[j].X[4] = TO_RAD(0) ;
		// КА в каждой плоскости разнесены на 90 град. 
		// и сфазированы на 45 град. относительно КА в соседней плоскости
		NU[j].X[5] = TO_RAD(1e-15+45.0*((double)(j))) ;
		NU[j].Sb = 0.0005 ;
		NU[j].Kp = 0 ;
		NU[j].M0 = 900 ;
		NU[j].MF = 50 ;

		// Уточняем параметры НУ с целью дибиться для всех НУ
		// одинаковых параметров (большая полуось, эксцентриситет и перигей) 
		// при "сносе" на начало витка, а также заданного значения средне-
		// -интегральной высоты (270 км)
		cout << "\n    IS-%d....." << j + 1;
		rc = RunUpSysEstimateNU(LSF, NU[j], NUK, 0, e1z, e2z, 0, Havr) ; RRC ;
		printf("Ok") ;
		NU[j] = NUK ;
	}
	printf("\n\n") ;
	return 0 ;
}

//-------------------------------------------------------------------------------
