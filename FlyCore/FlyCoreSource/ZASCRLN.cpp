//---------------------------------------------------------------------------
// ZASCRLN.cpp
// А. Николенко 03.08.2018
//---------------------------------------------------------------------------
#include <stdafx.h>
#pragma   hdrstop
//---------------------------------------------------------------------------
#include <FlyMMath.h>	// Математические функции
#include <FlyTime.h>	// Всё про время

#include <FlyCoreSource\\ModType.h>
#include <FlyCoreSource\\ModGlobal.h>

//---------------------------------------------------------
//	M_ABSRLN.C
//	ФУНКЦИЯ РАСЧЕТА МАТРИЦЫ ПЕРЕВОДА КООРДИНАТ
//      ИЗ ПОДВИЖНОЙ ОРБИТАЛЬНОЙ В ИНЕРЦИАЛЬНУЮ
//      И ОБРАТНО
//	Автор	: Пасынков В.В.
//---------------------------------------------------------
/*
	Подпрограмма matr_ASK_RLN

	Назначение
	   Подпрограмма вычисляет подматрицы перевода координат
	   и скоростей из подвижной (неинерциальной) или неподвижной
           (инерциальной) орбитальной  СК (ПОСК) в инерциальную:
	      АСК-ТЭ, ГЗСК, АГЭСК-J1975, АГЭСК-J2000 и т.д.
	   Ось R(X) - направлена от центра притягивающего тела к
		   центру ПОСК.
	   Ось N(Z) - по нормали к плоскости орбиты (вектру С).
	   Ось L(Y) - дополняет систему до правой.

	Обращение к подпрограмме
	   matr_ASK_RLN(napr,pr_iner,q,s);

	Входные параметры:
     napr  - направление перевода
             0 - АСК --> ОСК
             1 - ОСК --> АСК
     pr_iner - признак инерциальности ОСК
               0 - подвижная (неинерциальная),
               1 - неподвижная (инерциальная);
     q(6)   -вектор НУ в инерциальной СК (например, АГЭСК)
	     (центр ПОСК)  X,Y,Z,,Vx,Vy,Vz в произвольной
	     размерности (например, ДТКМ и ДТКМ/ССС)

	Выходные параметры:
     s(36)   - вектор, элементы которого составляют элементы матрицы
	       перевода координат и скоростей
	Результаты расчетов в размерности исходного вектора НУ.
*/

void  matr_ASK_RLN(short napr,short pr_iner,double *q,double *s)
{
//Расчет матрицы ИСК <- ПОрбСК по вектору ИСК
double x,y,z,r,cx,cy,cz,c,lx,ly,lz,l,r2,r3;
double m[9],mm[9];
short  k1,k2,ll,i,j;
//    if ( m== nullptr)	return;
    //инициализация
    for(i=0;i<9;i++)	m[i]=0.0;
    m[0]=m[4]=m[8]=1.0;

    x=q[0];      y=q[1];      z=q[2];
    r2=x*x+y*y+z*z;
    if(r2<1e-20)
       return ;
    r=sqrt(r2);      r3=r2*r;
/*-------- напр. косин.  ОСИ R */
    m[0]=x/r;      m[3]=y/r;      m[6]=z/r;
    cx=y*q[5]-z*q[4] ;      cy=z*q[3]-x*q[5];      cz=x*q[4]-y*q[3];
    c=sqrt(cx*cx+cy*cy+cz*cz);
    if(c<1e-20)
       return ;
/*--------- напр. косин. ОСИ N  */
    m[2]=cx/c;      m[5]=cy/c;      m[8]=cz/c;
    lx=z*cy-y*cz;      ly=x*cz-z*cx;      lz=y*cx-x*cy;
    l=sqrt(lx*lx+ly*ly+lz*lz);
    if(l<1e-20)
      return ;
/*--------- напр. косин. ОСИ L  */
    m[1]=lx/l;      m[4]=ly/l;      m[7]=lz/l;

    if( mm !=nullptr)    {
	mm[0]=lx/r3;                mm[1]=(-m[4]*cz+m[7]*cy)/r2; mm[2]=0.0;
	mm[4]=(m[1]*cz-m[7]*cx)/r2; mm[3]=ly/r3;                 mm[5]=0.0;
	mm[6]=lz/r3;                mm[7]=(-m[1]*cy+m[4]*cx)/r2; mm[8]=0.0;
	}

/*------- фиксирование неподвижности -------------------*/
    if(pr_iner==1) memset(mm,0,9*sizeof(double));

/*--------------- формирование из подматриц перевода -----------------*/
/*        координат и скоростей матрицы перевода координат            */
    if(napr==1)  /* из ОСК в АГЭСК*/
      for(k1=ll=i=0,k2=18;i<3;i++, k1+=6, k2+=6)
        {
        for(j=0;j<3;j++,ll++)
          {
          s[k1+j]=m[ll];		s[k1+3+j]=0.0;
          s[k2+j]=mm[ll];     s[k2+3+j]=m[ll];
          }
        }
    if(napr==0) /* из АГЭСК в ОСК*/
      {
        for(k1=ll=i=0,k2=18;i<3;i++,k1+=6,k2+=6)
          {
          for(ll=i,j=0;j<3;j++,ll+=3)
	    {
	    s[k1+j]=m[ll];   s[k1+3+j]=0.0;
	    s[k2+j]=mm[ll];   s[k2+3+j]=m[ll];
	    }
          }
      }
return;
}


//---------------------------------------------------------------------------
//	ФУНКЦИЯ РАСЧЕТА МАТРИЦЫ ПЕРЕВОДА КООРДИНАТ
//  ИЗ ПОДВИЖНОЙ ОРБИТАЛЬНОЙ В ИНЕРЦИАЛЬНУЮ И ОБРАТНО
//---------------------------------------------------------------------------
//	ZCalcM_ASCtoRLN
//	Назначение
//	   Подпрограмма вычисляет подматрицы перевода координат
//	   и скоростей из подвижной (неинерциальной) или неподвижной
//     (инерциальной) орбитальной  СК в инерциальную: АСК-ТЭ, ГЗСК, АГЭСК-J1975, АГЭСК-J2000 и т.д.
//	   Ось R(X) - направлена от центра притягивающего тела к центру ОСК.
//	   Ось N(Z) - по нормали к плоскости орбиты (вектру С).
//	   Ось L(Y) - дополняет систему до правой.

///	Вызов функции:
//	   ZCalcM_ASCtoRLN(Direct, isInerc, q, s) ;
//	Входные параметры:
//     Direct  - направление перевода
//			 0 - АСК --> ОСК
//			 1 - ОСК --> АСК
//     isInerc - признак инерциальности ОСК
//			 0 - подвижная (неинерциальная),
//			 1 - неподвижная (инерциальная);
//     RV(6)   - вектор НУ в инерциальной СК (например, АГЭСК),
//	   (центр ОСК) в (X,Y,Z), q(6) задан в произвольной размерности (например, ДТКМ и ДТКМ/ССС)
//	Выходные параметры:
//     M(36)   - вектор, элементы которого составляют элементы матрицы перевода координат и скоростей
//	Результаты расчетов в размерности исходного вектора НУ.
//---------------------------------------------------------------------------
void  ZCalcM_ASCtoRLN(double *RV, double *MRV, double* MR, double* MV, int Direct, bool isInerc)
{
	//Расчет матрицы ИСК <- ПОрбСК по вектору ИСК
	double m[9], x, y, z, r, cx, cy, cz, c, lx, ly, lz, l ;
	int    i ;

    //инициализация
    for (i=0 ; i<9 ; i++) m[i]=0.0 ;
    m[0]=m[4]=m[8]=1.0;

	// радиус-вектор
    x = RV[0] ; 
	y = RV[1] ; 
	z = RV[2] ;
    r = x*x+y*y+z*z ; if (r<1e-20) return ;
    r = sqrt(r) ;      
	// напр. косин.  ОСИ R 
	if (Direct) {
		m[0] = x/r ; m[3] = y/r ; m[6] = z/r ;
	} else {
		m[0] = x/r ; m[1] = y/r ; m[2] = z/r ;
	}

	// вектор кинетического момента
    cx = y*RV[5]-z*RV[4] ;      
	cy = z*RV[3]-x*RV[5] ;      
	cz = x*RV[4]-y*RV[3] ;
    c  = sqrt(cx*cx+cy*cy+cz*cz) ; if(c<1e-20) return ;
	// напр. косин. ОСИ N  
	if (Direct) {
		m[2] = cx/c ; m[5] = cy/c ; m[8] = cz/c ;
	} else {
		m[6] = cx/c ; m[7] = cy/c ; m[8] = cz/c ;
	}

	// вектор направленный по трансверсали
    lx = z*cy-y*cz ;      
	ly = x*cz-z*cx ;      
	lz = y*cx-x*cy ;
    l  = sqrt(lx*lx+ly*ly+lz*lz) ; if(l<1e-20) return ;
	// напр. косин. ОСИ L  
	if (Direct) {
		m[1] = lx/l ; m[4] = ly/l ;	m[7] = lz/l ;
	} else {
		m[3] = lx/l ; m[4] = ly/l ;	m[5] = lz/l ;
	}

	if (MR) memcpy(MR, m, sizeof(m)) ;

    if (isInerc==1) {
		// фиксирование неподвижности
		if (MV) memcpy(MV, m, sizeof(m)) ;
	} else {
		if (MV) memcpy(MV, m, sizeof(m)) ;
	}

	if (MRV) {
		memset(MRV, 0, 36*sizeof(double)) ;
		for (i=0; i<3; i++) {
			MRV[i] = m[i] ;
			MRV[6+i] = m[3+i] ;
			MRV[12+i] = m[6+i] ;
			MRV[21+i] = m[i] ;
			MRV[27+i] = m[3+i] ;
			MRV[33+i] = m[6+i] ;
	}	}
	return ;
}

//---------------------------------------------------------------------------
void  ZASCtoRLN(double *RV, double *ASC, double *RLN, bool andV, bool isInerc)
{
	double M[36] ;
	double MR[9] ;
	ZCalcM_ASCtoRLN(RV, M, MR, nullptr, 0, isInerc) ;
	if (andV) MMatrVactor(M, ASC, RLN, 6, 6) ;
	else      MMatrVactor(MR,ASC, RLN, 3, 3) ;
}

//---------------------------------------------------------------------------
void  ZRLNtoASC(double *RV, double *RLN, double *ASC, bool andV, bool isInerc)
{
	double M[36] ;
	double MR[9] ;
	ZCalcM_ASCtoRLN(RV, M, MR, nullptr, 1, isInerc) ;
	if (andV) MMatrVactor(M, RLN, ASC, 6, 6) ;
	else      MMatrVactor(MR,RLN, ASC, 3, 3) ;
}

//---------------------------------------------------------------------------

