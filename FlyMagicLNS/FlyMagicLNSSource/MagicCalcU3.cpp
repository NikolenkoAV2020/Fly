//-----------------------------------------------------------------------------
// MagicCalcU3.cpp: 
// А. Николенко 12.10.2018
//
// Реализация методик аналитического или численно-аналитического расчёта
// параметров управления движением центра масс КА для вариантов семейста 30+,
// (то есть 30, 31,..) в рамках методики узловых точек. 
// Автор всех методик старый волшебник. 
// !!!! Номера вариантов могут не совпадать с общепринятыми !!!!
//-----------------------------------------------------------------------------
#include <stdafx.h>

//-----------------------------------------------------------------------------
#include <FlyMMath.h>		// Математические функции
#include <FlyMagicLNS.h>	//

//-----------------------------------------------------------------------------
extern double k_epsdrs ;		// 10 метров
extern double k_stepu ;			// [град] шаг перебора аргумента широты
extern int    pru ;				// признак учёта времени работы КДУ
extern int    kp ;				// признак корректируемого параметра
extern double dtQ1, dtQ2 ;		// для вектора промаха
extern double PV1[3], PV2[3] ;	// для изменений а, е, w от V1, V2

int MagicBuildORB(ZSMagicLnsSolution* MS, ZCLnsNpmClaim& PT, bool reBuild);

//-----------------------------------------------------------------------------
// Расчёт управлений по вариантам 3-импульсных коррекций
//-----------------------------------------------------------------------------
// Расчёт управлений по варианту "30" ("L, a, e, w для любой орбиты")
int MagicCalcU30(
	ZSMagicLnsSolution* MS,	// Описание решаемой задачи
	ZSLoopFact    &P1,		// Пар-ы движения на витке первого импульса
	ZSLoopFact    &PZ,		// Пар-ы движения на заданном витке
	ZCLnsNpmClaim &PT,		// Требуемые параметры движения
	ZSFlightRule  &U)		// Искомое управление
{
    PT.VarPar = SPO_VARIDPAR_a ;
    return(MagicCalcU31(MS, P1, PZ, PT, U));
}

//-----------------------------------------------------------------------------
// Расчёт управлений по варианту "31"("L, T, h, Bh для эл." 
// или "L, T, e, w для ОМИВ или ДУ")
int MagicCalcU31BydL(
	ZSMagicLnsSolution* MS,	// Описание решаемой задачи
	ZSLoopFact    &P1,		// Пар-ы движения на витке первого импульса
	ZSLoopFact    &PZ,		// Пар-ы движения на заданном витке
	ZCLnsNpmClaim &PT,		// Требуемые параметры движения
	double		  dL,		// Невязка по долготе
	ZSFlightRule  &U)		// Искомое управление
{
    ZSLnsNpmFault  P ;
    int    i, j, k, rc = 0 ;
    double rs ;
    double dLp, dW, b[3] ;
    double dV1[6], dV2[6], dV3[6], dVs, mindVs ;
    double u[3][6] ;

	// По умолчанию основной параметр, определяющий орбиту, 
	// по которому проектируем орбиту - приод
	if (PT.VarPar == SPO_NOTBUILD) PT.VarPar = SPO_VARIDPAR_T;

    // Проверка корректности заданного параметра
	if (PT.VarPar != SPO_VARIDPAR_H && PT.VarPar != SPO_VARIDPAR_dL &&
		PT.VarPar != SPO_VARIDPAR_T && PT.VarPar != SPO_VARIDPAR_a) return -1;

    // Проектирование орбиты по заданному парамкетру
	//rc = MknBuildSpo( PT, SP ) ; RRC ;
	rc = MagicBuildORB(MS, PT, (PT.VarOrb == SPO_ORB_OMIV ||
		 PT.VarOrb == SPO_ORB_DU) ? false : true); if (rc) return -1;

    // Для ОМИВ и ДУ запоминаем  геометрию требуемой орбиты
	//if (( PT.VarOrb == SPO_ORB_OMIV || PT.VarOrb == SPO_ORB_DU)&& GlobCount==1)
    //   {PT.T = SP.T ;PT.e = SP.e ; PT.w = SP.w ; PT.e1 = SP.e1; PT.e2 = SP.e2; }
    // Для ОМИВ и ДУО возвращаем  геометрию  орбиты
	//if (  GlobCount >=2 &&(PT.VarOrb==SPO_ORB_OMIV || PT.VarOrb==SPO_ORB_DU ))
    // {  SP.e1 = PT.e1 ; SP.e2 = PT.e2  ; SP.e = PT.e; SP.w= PT.w;}

    // Вычисление радиусов в узловых точках требуемой орбиты и промаха
    //rc = MagicCalcMishit(SP.i, SP.p, SP.e1, SP.e2, P1,PZ, PT.Ro, P) ; RRC ;
    rc = MagicCalcMishit(PT.i, PT.p, PT.e1, PT.e2, P1, PZ, PT.Ro, P) ; 
	if (rc) return -1;

    // Невязка по средниму радиусу
	rs = (PT.Ro[2] + PZ.Ro[2]) / 2.0;

    // Производная долготы восходящего узла по времени [гдад/сек]
	dW =-360.0 / pow(rs, 2)*k_eps / k_mu_kms*Cos(P1.i) / P1.T;
    // Вращение Земли [гдад/сек]
	double k_omega_gs = GradA(k_omega) / 86400.0;
    // Приведённая невязка долготы [км/сек]
	dLp = dL*k_mu_kms / rs / rs / (k_omega_gs - dW);

	//-------------------------------------------------------------------------
	// Расчёт управлений по 6 вариантам и выбор лучшего
	//-------------------------------------------------------------------------

	// 6 вариантов аргументов широты приложения импульса
	if (P.dRs<0) P.u0 = ValiA(P.u0 + 180.0, 1);
	double u01 = P.u0;
	double u02 = ValiA(P.u0 + 180.0, 1);
    u[0][0] = u01 ; u[1][0] = u01 ; u[2][0] = u02 ;
    u[0][1] = u01 ; u[1][1] = u02 ; u[2][1] = u01 ;
    u[0][2] = u01 ; u[1][2] = u02 ; u[2][2] = u02 ;
    u[0][3] = u02 ; u[1][3] = u02 ; u[2][3] = u01 ;
    u[0][4] = u02 ; u[1][4] = u01 ; u[2][4] = u02 ;
    u[0][5] = u02 ; u[1][5] = u01 ; u[2][5] = u01 ;

	//-------------------------------------------------------------------------
	// Среди ниже перечисленных 6-и решений могут быть решения посторонние
	// по смыслу. Такие решения когда знак и первого и второго импульсов
	// по своему смыслу противоположен знаку требуемого дрейфа.
	// 
	// Так если невязка dL < 0, то это значит что ожидается дрейф долготы ВУ
	// орбиты (или фазы КА для 241 или 311... варианта) в сторону увеличения
	// долготы L (или фазы - аргумента широты КА). В таком случае хотя бы 
	// один из первых двух импульсов должен быть отрицательным. То есть решение
	// с двумя первыми положительными импульсами будет посторонним.
	// 
	// По аналогии если невязка dL > 0, то хотя бы один из первых двух 
	// импульсов должен быть положительным, а решение содержащее первые два 
	// отрицательные импульса постороннее по смыслу
	//
	// Если рассуждать точнее, то можно прийти к следующему критерию.
	// Если сумма попарных произведений импульсов скорости на соответствующие
	// угловые дальности импульса до момента контроля угловой величины 
	// (долготы или фазы) имеет знак противоположенный dL, то решение 
	// является посторонним. 
	//
	// В приведённом ниже переборе посторонние по смыслу решения игнорируются
	//-------------------------------------------------------------------------
	k =-1;
	mindVs = 999e+99;
	for (i = 0; i < 6; i++) {
		double fi[3];
		for (j = 0; j < 3; j++) {
			// Угловые дальности от импульсов до заданного витка
			fi[j] = 2.* k_pi * (PZ.Vit - U.vit[j]) - RadA(u[j][i]);
			// Проверка контроля на правом конце траектории фазы а не долготы
			if (MS->MZ.Contu()) {
				// Если контролируется фаза то в угловую дальность нужно
				// добавить заданный аргумент широты (фазу)
				fi[j] += RadA(MS->MZ.PARu());
			}
			// Производные ...
			b[j] = (3. * fi[j] + fi[j] * k_eps / k_mu_kms * 4. / rs / rs *
				   (2. - 1.5 * pow(Sin(PZ.i), 2)) - 4. * Sin(u[j][i]));
		}
		// Расчёт импульсов характеристической скорости в зависимости 
		// от схемы перелёта. 
		switch (i) {
		case 0:
		case 3:
			dV1[i] = ((8. * dLp - P.l * (b[1] - b[2]) * P.dR0 -
				     2. * P.l * (b[1] + b[2]) * P.dRs)) / 8. / (b[0] - b[1]);
			dV2[i] = ((-8. * dLp + P.l * (b[0] - b[2]) * P.dR0 +
				     2. * P.l * (b[0] + b[2]) * P.dRs)) / 8. / (b[0] - b[1]);
			dV3[i] = P.l / 4. * (P.dRs - .5 * P.dR0);
			break;
		case 1:
		case 4:
			dV1[i] = ((8. * dLp + P.l * (b[1] - b[2]) * P.dR0 -
				     2. * P.l * (b[1] + b[2]) * P.dRs)) / 8. / (b[0] - b[2]);
			dV2[i] = P.l / 4. * (P.dRs - .5 * P.dR0);
			dV3[i] = ((-8. * dLp + P.l * (b[0] - b[1]) * P.dR0 +
				     2. * P.l * (b[0] + b[1]) * P.dRs)) / 8. / (b[0] - b[2]);
			break;
		case 2:
		case 5:
			dV1[i] = P.l / 4.0 * (P.dRs - 0.5 * P.dR0);
			dV2[i] = ((8. * dLp - P.l * (b[0] - b[2]) * P.dR0 -
				     2. * P.l * (b[0] + b[2]) * P.dRs)) / 8. / (b[1] - b[2]);
			dV3[i] = ((8. * dLp + P.l  * (b[0] - b[1]) * P.dR0 +
				     2. * P.l * (b[0] + b[1]) * P.dRs)) / 8. / (b[1] - b[2]);
			break;
		}
		if (i == 2) P.dR0 = -P.dR0;

		// Суммарных расход характеристической скорости
		dVs = fabs(dV1[i]) + fabs(dV2[i]) + fabs(dV3[i]);

		// Оценка смещения долготы засчёт реализации импульсов
		double ShiftL = 0;
		for (j = 0; j < 3; j++){
			// колличество витков от момента приложения импульса
			// до правого конца траектории перелёта.
			double dN = MS->MZ.VIT() - MS->MZ.VITIMP(j);
			// Учёт контроля агрумента широты вместо долготы
			if (MS->MZ.Contu()) dN += MS->MZ.PARu() / 360.0;
			// Структура для расчётных производных
			ZSLnsNpmDiffDV D;
			// Вычисление производных от элементов движения КА по
			// величине трансверсального импульса
			MagicCalcDifDV(P1.a, P1.e, P1.i, P1.w, P.u0, 0, dN, D);
			// Суммирования расчётного смещения "долготы" на правом
			// конце траектории.
			ShiftL += D.dL*(j ? (j == 2 ? dV3[i] : dV2[i]) : dV1[i]);
		}
		// Расчёт относительной погрешности по долготе домноженной на
		// характеристическую скорость (импульс остаточной коррекции)
		// fabs(fabs(ShiftL / dL)-1.0) - это сколько в процентах мы
		// "не долетели" или "перелетели" по долготе (ну или по аргументу
		// широты КА если маневрирование осуществляется по соответствующему 
		// варианту).
		double sigm;
		sigm = fabs(fabs(ShiftL / dL)-1.0)*dVs;
		// sigm - остаточный импульс в метрах в секунду.

		// Если ожидаемое смещение долготы dL не соответствует 
		// расчётному ShiftL, то такое решение (схема) является посторонним
		// по смыслу решением задачи. В таком случае схема в выборе наилучшей
		// не участвует.
		// Для правильного решения должео выполняться: ShiftL = dL (примерно).
		// 
		// Для определения постороннего решения то есть примерного выполнения
		// равенства ShiftL = dL удобно воспользоваться понятием остаточного 
		// импульса. Если такой остаточный импульс (в настоящем коде он 
		// представлен переменной sigm) достаточно велик, то  это означает, 
		// что ShiftL = dL выполняется совсем не точно!
		// Самый простой путь в такой ситуации - выбор оптимальной схемы по 
		// минимуму характеристической скорости с учётом остаточного импульса.
		// То есть минимизируем сумму характеристической скорости и
		// остаточного импульса (dVs + sigm)!!!!
		//
		// В оригинальном изложении алгоритма Старым волшебником для выбора 
		// схемы минимизировалась именно характеристическая скорость dVs.  
		// В некоторых случаях это приводило к АВОСТу, хотя и достаточно 
		// редких на практике.

		// Выбор варианта с минимальными затратами характеристической скорости
		if (k < 0 || mindVs > dVs + sigm) {
			// Минимальные затраты на манёвр
			mindVs = dVs + sigm;
			// k - индекс наилучшего варианта
			k = i; 
	}	}
	P.dR0 =-P.dR0 ;

    // План коррекции (один из 6-и вариантов рассмотренных выше) 
	// фиксируем на первой итерации
	if (MS->GlobCount == 1) U.plane = k + 1;
	if (MS->GlobCount >  1) k = U.plane - 1;

	// Искомое управление
    U.n = 3;
    U.u0[0] = u[0][k]; U.u0[1] = u[1][k]; U.u0[2] = u[2][k];
    U.uw[0] = 0;       U.uw[1] = 0;       U.uw[2] = 0;
    U.dV[0] = dV1[k];  U.dV[1] = dV2[k];  U.dV[2] = dV3[k];

	return rc ;
}

//-----------------------------------------------------------------------------
// Расчёт управлений по варианту "31"("L, T, h, Bh для эл." 
// или "L, T, e, w для ОМИВ или ДУ")
int MagicCalcU31(
	ZSMagicLnsSolution* MS,	// Описание решаемой задачи
	ZSLoopFact    &P1,		// Пар-ы движения на витке первого импульса
	ZSLoopFact    &PZ,		// Пар-ы движения на заданном витке
	ZCLnsNpmClaim &PT,		// Требуемые параметры движения
	ZSFlightRule  &U)		// Искомое управление
{
	// Невязка по долготе
	double dL = ValiDA(PZ.L - PT.L, 1);
	return(MagicCalcU31BydL(MS, P1, PZ, PT, dL, U));
}

//-----------------------------------------------------------------------------
// Расчёт управлений по варианту "31" для Кондор(L, T, e, w )
int MknMBCalcKondorU31(
	ZSMagicLnsSolution* MS,	// Описание решаемой задачи
	ZSLoopFact    &P1,		// Пар-ы движения на витке первого импульса
	ZSLoopFact    &PZ,		// Пар-ы движения на заданном витке
	ZCLnsNpmClaim &PT,		// Требуемые параметры движения
	ZSLnsNpmFault &P,		//
	ZSFlightRule  &U)		// Искомое управление
{

	// Промах по долготе
	double dL = ValiDA(PZ.L - PT.L, 1);

	int    i, j, k, rc=0;
	double rs;
	double a, dLp, dW, b[3];
	double dV1[6], dV2[6], dV3[6], dVs, mindVs;
	double u[3][6];

	// Большaя полуось в нормальном поле выраженная через период
	rc = MATC20(PT.i, PT.e1, PT.e2, PT.T, a);
	// Промах в узловых точках
	rc = MagicCalcMishit(PT.i, a*(1 - PT.e*PT.e), PT.e1, PT.e2, 
						 P1, PZ, PT.Ro, P); if (rc) return rc;

    // Средний радиус
	rs = (PT.Ro[2] + PZ.Ro[2]) / 2.;

    // Производная долготы восходящего узла по времени
	dW =-360.0 / pow(rs, 2) * k_eps / k_mu_kms * Cos(P1.i) / P1.T;

    // Приведённая невязка долготы
	dLp = RadA(dL) * k_mu_kms / rs / rs / (RadA(k_omega) - RadA(dW));

	//-------------------------------------------------------------------------
    // Расчёт управлений по 6 вариантам и выбор лучшего
	//-------------------------------------------------------------------------

	// 6 вариантов аргументов широты приложения импульса
	if (P.dRs<0) P.u0 = ValiA(P.u0 + 180.0, 1);
	double u01 = P.u0;
	double u02 = ValiA(P.u0 + 180.0, 1);
	u[0][0] = u01; u[1][0] = u01; u[2][0] = u02;
	u[0][1] = u01; u[1][1] = u02; u[2][1] = u01;
	u[0][2] = u01; u[1][2] = u02; u[2][2] = u02;
	u[0][3] = u02; u[1][3] = u02; u[2][3] = u01;
	u[0][4] = u02; u[1][4] = u01; u[2][4] = u02;
	u[0][5] = u02; u[1][5] = u01; u[2][5] = u01;

	// Вычисление импульсов скорости по каждому из 6 вариантов
	// с выбором наилучшего
    k = 0 ;
	for (i = 0; i < 6; i++) {
		for (j = 0; j < 3; j++) {
			// Угловые дальности от импульсов до заданного витка
			double fi = 2.* k_pi * (PZ.Vit - U.vit[j]) - RadA(u[j][i]);
			// Производные ...
			b[j] = (3. * fi + fi * k_eps / k_mu_kms * 4. / rs / rs *
				   (2. - 1.5 * pow(Sin(PZ.i), 2)) - 4. * Sin(u[j][i]));
		}
		if (i == 0 || i == 3) {
			dV1[i] = ((8. * dLp - P.l * (b[1] - b[2]) * P.dR0 -
				     2. * P.l * (b[1] + b[2]) * P.dRs)) / 8. / (b[0] - b[1]);
			dV2[i] = ((-8. * dLp + P.l * (b[0] - b[2]) * P.dR0 +
				     2. * P.l * (b[0] + b[2]) * P.dRs)) / 8. / (b[0] - b[1]);
			dV3[i] = P.l / 4. * (P.dRs - .5 * P.dR0);
		}
		if (i == 1 || i == 4) {
			dV1[i] = ((8. * dLp + P.l * (b[1] - b[2]) * P.dR0 -
				     2. * P.l * (b[1] + b[2]) * P.dRs)) / 8. / (b[0] - b[2]);
			dV2[i] = P.l / 4. * (P.dRs - .5 * P.dR0);
			dV3[i] = ((-8. * dLp + P.l * (b[0] - b[1]) * P.dR0 +
				     2. * P.l * (b[0] + b[1]) * P.dRs)) / 8. / (b[0] - b[2]);
		}
		if (i == 2 || i == 5) {
			dV1[i] = P.l / 4.0 * (P.dRs - 0.5 * P.dR0);
			dV2[i] = ((8. * dLp - P.l * (b[0] - b[2]) * P.dR0 -
				     2. * P.l * (b[0] + b[2]) * P.dRs)) / 8. / (b[1] - b[2]);
			dV3[i] = ((8. * dLp + P.l  * (b[0] - b[1]) * P.dR0 +
				     2. * P.l * (b[0] + b[1]) * P.dRs)) / 8. / (b[1] - b[2]);
		}
		if (i == 2) P.dR0 = -P.dR0;

		// Суммарных расход характеристической скорости
		dVs = fabs(dV1[i]) + fabs(dV2[i]) + fabs(dV3[i]);

		if (!i) mindVs = dVs;
		else {
			// k - индекс наилучшего варианта
			if (mindVs > dVs) { mindVs = dVs; k = i; }
		}
    }
	P.dR0 = -P.dR0;

    // Искомое управление
	if (MS->GlobCount == 1) U.plane = k + 1;
	if (MS->GlobCount  > 1) k = U.plane - 1;

    U.n = 3 ;
	U.u0[0] = u[0][k];	U.u0[1] = u[1][k];	U.u0[2] = u[2][k];
	U.uw[0] = 0;		U.uw[1] = 0;		U.uw[2] = 0;
	U.dV[0] = dV1[k];	U.dV[1] = dV2[k];	U.dV[2] = dV3[k];

    return rc ;
}

//-----------------------------------------------------------------------------
// Расчёт управлений по варианту "311"("u, T, h, Bh для эл." 
// или "u, T, e, w для ОМИВ или ДУ")
int MagicCalcU311(
	ZSMagicLnsSolution* MS,	// Описание решаемой задачи
	ZSLoopFact    &P1,		// Пар-ы движения на витке первого импульса
	ZSLoopFact    &PZ,		// Пар-ы движения на заданном витке
	ZCLnsNpmClaim &PT,		// Требуемые параметры движения
	ZSFlightRule  &U)		// Искомое управление
{
	int    rc;
	double dLdu = 0;
	double up = MS->MZ.PARu();

	// По умолчанию основной параметр, определяющий орбиту, 
	// по которому проектируем орбиту - приод
	if (PT.VarPar == SPO_NOTBUILD) PT.VarPar = SPO_VARIDPAR_T;

	// Проверка корректности заданного параметра
	if (PT.VarPar != SPO_VARIDPAR_H && PT.VarPar != SPO_VARIDPAR_dL &&
		PT.VarPar != SPO_VARIDPAR_T && PT.VarPar != SPO_VARIDPAR_a) return-1;

	// Проектирование орбиты по заданному парамкетру
	rc = MagicBuildORB(MS, PT, (PT.VarOrb == SPO_ORB_OMIV || PT.VarOrb == 
					   SPO_ORB_DU) ? false : true); if (rc) return rc;

	// Вычисление радиусов в узловых точках требуемой орбиты и промаха
	ZSLnsNpmFault  P;
	rc = MagicCalcMishit(PT.i, PT.p, PT.e1, PT.e2, P1, PZ, PT.Ro, P); 
	if (rc) return-1;

	// Оценка производной dLdu долготы по смещению вдоль орбиты 
	// (по аргументу широты)
	ZSLnsNpmDiffDV D;
	for (int i = 0; i < 3; i++){
		MagicCalcDifDV(P1.a, P1.e, P1.i, P1.w, P.u0, up, 
					   MS->MZ.VIT() - MS->MZ.VITIMP(i), D);
		dLdu+= D.dLdu;
	}
	dLdu/= 3.0;

	// Невязка по аргументу широты
	// Именно этой невязкой 311 вариант отличается от 310-го (31) варианта.
	// В 310 варианте на парвом конце траектории контролируется не аргумент
	// широты в заданный момент времени, а долгота на начало заданного витка.
	double dL = ValiDA(PZ.up - PT.u, 1);
	// Преобразование невязки аргумента широты в соответстующую невязку по 
	// долготе восходящего узла... В результате чего расчёт параметров 
	// программы управления становится анологичным расчёту по 310 варианту
	dL *= dLdu;

	// Решение 31-го варианта по долготе 
	return(MagicCalcU31BydL(MS, P1, PZ, PT, dL, U));
}

//-----------------------------------------------------------------------------
// Расчёт управлений по варианту "32" (L,Hср,e,w для ОМИВ ДУ или ЭО)
int MagicCalcU32(
	ZSMagicLnsSolution* MS,	// Описание решаемой задачи
	ZSLoopFact    &P1,		// Пар-ы движения на витке первого импульса
	ZSLoopFact    &PZ,		// Пар-ы движения на заданном витке
	ZCLnsNpmClaim &PT,		// Требуемые параметры движения
	ZSFlightRule  &U)		// Искомое управление
{
      PT.VarPar = SPO_VARIDPAR_H ;
      PT.VarH   = SPO_VARH_MID ;
      return(  MagicCalcU31(MS, P1, PZ, PT, U ) ) ;
}

//-----------------------------------------------------------------------------
// Расчёт управлений по варианту "33" (L,dL,e,w для ОМИВ ДУ или ЭО")
int MagicCalcU33(
	ZSMagicLnsSolution* MS,	// Описание решаемой задачи
	ZSLoopFact    &P1,		// Пар-ы движения на витке первого импульса
	ZSLoopFact    &PZ,		// Пар-ы движения на заданном витке
	ZCLnsNpmClaim &PT,		// Требуемые параметры движения
	ZSFlightRule  &U)		// Искомое управление
{
    PT.VarPar = SPO_VARIDPAR_dL ;
    return( MagicCalcU31(MS, P1, PZ, PT, U ) ) ;
}

//-----------------------------------------------------------------------------
