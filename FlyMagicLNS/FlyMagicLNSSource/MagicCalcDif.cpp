//------------------------------------------------------------------------------
// MagicCalcDif.cpp: 
// А. Николенко 23.08.2018
//-------------------------------------------------------------------------------
#include <stdafx.h>

//---------------------------------------------------------------------------
// Компоненты Fly
#include <FlyMMath.h>		// Математические функции
#include <FlyCore.h>		// Математические функции
#include <FlyMagicLNS.h>	//

//------------------------------------------------------------------------------
// Функция расчёта производных трансверсального импульса
int MagicCalcDifDV(	// Оскулирующие элементы на витке приложения импульса: 
	double	a,		// - большая полуось, км;
	double	e,		// - эксцентриситет;
	double	i,		// - наклонение, град;
	double	w,		// - аргумент широты перигея, град.
	double	u,		// Аргумент широты приложения импульса.
	double	up,		// Заданный аргумент широты.
	double	dN,		// Интервал витков от витка импульса до заданного витка.
	ZSLnsNpmDiffDV& D)	// Производные элементов движения по трансверсальному имп.
{
    int rc = 0 ;
	double ci = Cos(i),
		   si = Sin(i),
		   su = Sin(u),
		   cu = Cos(u),
		   cw = Cos(w),
		   sw = Sin(w),
		   ct = Cos(u - w),
		   st = Sin(u - w),
		   p  = a*(1.0 - e*e),
		   p2 = p*p,
		   e1 = e*cw,
		   e2 = e*sw,
		   k = si*si,
		   k1 = sqrt(p / k_mu_kms),
		   k2 = 1.0 + e*ct,
		   // Угловая дальность в радианах
		   fi = 2.0*k_pi*dN - RadA(u),
		   // Оскулирующий период
		   T = 2.0*k_pi*a*sqrt(a / k_mu_kms),
		   // Прецессия плоскости в град/сек
		   dW = -360.0 / T / p / p*k_eps / k_mu_kms*ci;

	// Вычисление производных..
	// Для большой полуоси, эксцентриситета и его компонент 
    D.da = k1*2.0*p/pow((1.0-e*e), 2)*k2 ;		// [км/км/сек]
    D.de = k1*(e*ct*ct+2.0*ct+e)/k2 ;			// [1/км/сек]
    D.de1= k1*(cu+(e1+cu)/k2) ;					// [1/км/сек]
    D.de2= k1*(su+(e2+su)/k2) ;					// [1/км/сек]

	// Для аргумента широты перигея [град/км/сек]
    D.dw = GradA((e1*D.de2-e2*D.de1)/e/e) ;

	// Для драконического периода [сек/км/сек]
    D.dT = 2.0*k_pi/k_mu_kms*(3.0*p*p*k2+k_eps/k_mu_kms/k2*(3.0-2.5*k-(1.0-5.0*k)*(1.0+k2)*cu));

	// Производная для изменения аргуиента широты в точке с u=

	// Для долготы восходящего узла на заданном витке в [град/км/сек]
    // с учётом "парадокса спутника"
	double k_omega_gs = GradA(k_omega)/86400.0 ;
    D.dL =-(k_omega_gs-dW)*a*a/k_mu_kms*((3.0*fi-4.0*sin(fi))+fi/a/a*k_eps/k_mu_kms*k1*(3.0-2.5 *k-e1*(1.0-5.0*k)));
	D.dL =-D.dT*fi/2.0/k_pi*(k_omega_gs-dW) ;
    // без учёта "парадокса спутника"
	D.dLsimpl =-fi/2.0/k_pi*(D.dT*k_omega_gs-8.*360.0/p/p*k_eps/k_mu_kms*ci*sqrt(a/k_mu_kms)/k2);

	// Для аргумента широты на заданный момент времени на заданном витке [град/км/сек]
	D.du = -D.dT*sqrt(k_mu_kms / p / p2)*(180.0*dN + (up - u) / 2.0) / k_pi;

	if (fabs(D.du) < 1e-12) D.dLdu = 999e+99*Sign1(D.du*D.dL);
	else D.dLdu = D.dL / D.du;

	// Для радиуса перигея и апогея
    D.dhp= k1*p/pow(1.0+e, 2)*(2.0*(1.0-ct)+e*st)/k2 ;
    D.dha= k1*p/pow(1.0-e, 2)*(2.0*(1.0+ct)+e*st*st)/k2 ;
	return rc ;
}

//------------------------------------------------------------------------------