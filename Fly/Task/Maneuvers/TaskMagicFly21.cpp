//-------------------------------------------------------------------------------
// TaskMagicFly21.cpp : 
// А. Николенко 24.08.2018
//
// 21-й вариант LNS-маневра
// T,h,Bh или T,e,w для ОМИВ, ДУ, ЭО
//-------------------------------------------------------------------------------
#include "stdafx.h"

//---------------------------------------------------------------------------
// Компоненты Fly
#include <FlyMMath.h>		// Математические функции
#include <FlyMagicLNS.h>	// Метод узловых точек

//---------------------------------------------------------------------------
#include <FlyMagicLNSSource/MagicSolution.h>

int TaskMagicFlyBegin(ZSMagicLnsSolution* MS, int task, ZMSC& KA,
	ZNU& NU, ZLSF& LSF, bool ResetNU, ZCPrintManager* PrintMng,
	FILE** pfp);

//-------------------------------------------------------------------------------
int TaskMagicFly21(int TypeOrb)
{
	// идентификатор задачи (иными словами номер варианта маневрирования)
	int indexTask = 21;
	int rc = 0 ;

	//---------------------------------------------------------------------------
	// Создаём "Модель решения"
	// По сути своей модель решения это контейнер, который содержит: 
	//		- характеристики двигутельной установки, 
	//		- массив параметров задачи (опции),
	//		- задание на решение задачи (массив информации, обычно задаваемый 
	//		  оператором в интерактивном режиме).
	// ... Таким образом эту самую модель перед решением нужно создать.
	//---------------------------------------------------------------------------
	ZSMagicLnsSolution* MS = CreateMagicLnsSolution(); if (!MS) return 1;

	//---------------------------------------------------------------------------
	// TypeOrb - Тип требуемой орбиты
	//		SPO_ORB_EL	- геометрия требуемой орбиты задаётся как e, w.
	//		SPO_ORB_HBH	- геометрия требуемой орбиты задаётся как Hmin, Bhmin.
	//		SPO_ORB_OMIV- параметры требуемой орбиты обеспечивают минимальное.
	//					  изменение высоты на витке (e, w выбираются исходя из 
	//					  условия ОМИВ).
	//		SPO_ORB_DU	- параметры требуемой орбиты обеспечивают динамическую
	//					  устойчивость (e, w выбираются исходя из условия ДУ).
	//---------------------------------------------------------------------------
	MS->MZ.ORB() = TypeOrb ;	

	//--------------------------------------------------------------------------
	// Инициализация НУ, ЛШС и модели движения, настройка документирования
	//--------------------------------------------------------------------------
	ZNU   NU;			// НУ движения КА.
	ZLSF  LSF;			// Логическая шкала сил в которой выполняется решение. 
	ZMSC  KA;			// Модель движения (или просто КА)
	FILE* fp = nullptr;	// Файл для документирования результатов решения
	// Диспетчер документирования
	// Несмотря на то что диспетчер документирования ZCPrintManager был разработан
	// для документирования результатов прогноза, он находит своё применение и
	// в прикладных задачах, в части касающейся создания документа, вывода 
	// заголовка документа, документирования НУ и ЛШС, документирования 
	// информации о времени расчёта и его длителоьности, форматированного 
	// документирования данных в заданный контекст (просто говоря в звдвнный 
	// файл). 
	// В итоге диспетчер документирования нам нужен!
	ZCPrintManager PrintMng;

	// Инициализация основных данных необходимых для решения тестовых задач
	// расчёта параметров орбитального маневрирования - задание на расчёт
	// "фиксированная" часть. 
	// Данный метод общий для
	// всех тестовых процедур именованных как TaskMagicFly__.
	// В "Prodaction" необходимость в данном методе отпадает. Вся его 
	// функциональная нагрузка ложится на GUI 
	// и/или на средства автоматизации АПК.
	rc = TaskMagicFlyBegin(MS, indexTask, KA, NU, LSF, true, &PrintMng, &fp); 
	if (rc) goto end;

	//--------------------------------------------------------------------------
	// Формирование задания на расёт, "опреративная" часть (формируется в 
	// интерактивном режиме с использованием GUI)
	MS->MZ.VITIMP(0) = 2;		// Виток первого импульса
	MS->MZ.VITIMP(1) = 4;		// Виток второго импульса
	MS->MZ.VIT()     = 5;		// Заданный виток на котором контролируются 
								// краевые условия
	// Требуемые параметры орбиты
	MS->MZ.PARL() = 131.2;		// Долгота ВУ
	MS->MZ.PART() = 5503.0;		// Драконический период
	MS->MZ.PARh() = 210.0;		// Минимальная высота
	MS->MZ.PARBh()= 10;			// Широта минимальной высоты
	MS->MZ.PARBv()= 1;			// Восходящая ветвь
	MS->MZ.PARe() = 0.0002;		//	
	MS->MZ.PARw() = 90.0;		//	

	// Взводим флаг уточнения формы орбиты для того чтобы
	// На итерациях изменять прицельные значения минимальной высоты и её широты
	MS->MP.isEstimateOrb = true;

	//--------------------------------------------------------------------------
	// Решение задачи расчёта параметров коррекции по заданию MZ 
	{
	ZSLoopFact  P1;	// Параметры движения на виток первого имп 
	ZSLoopFact  P2;	// Параметры движения на виток второго имп 
	ZSLoopFact  PN;	// Начальные параметры движения на заданный виток
	ZSLoopFact  PR;	// Расчётные конечные параметры движения на заданный виток 
	ZSFlightRule U;	// Прогрмамма управления

	// Процедура итерационного решения формализованной задачи расчёта методом
	// узловых точек. Данная процедура является единой для всех тестовых задач
	// именованных как TaskMagicFly__. 
	rc = MagicSolution(MS, &PrintMng, fp, LSF, KA, NU, nullptr, 
					   &P1, &P2, &PN, &PR, &U);
	// Закрытие документа с результатами решения
	PrintMng.ClosePrint(&fp);
	}
end:;
	//---------------------------------------------------------------------------
	// В завершении удаляем созданную ранее "Модель решения"
	FreeMagicLnsSolution(MS);
	return rc ;
}

//-------------------------------------------------------------------------------