//-----------------------------------------------------------------------------
// SamplAverageMotion.cpp
// А. Николенко 14.06.2019
//
// Прогноз движения КА по виткам с расчётом осреднённой высоты для каждого витка
// Демонстрация механизма "вертикального" расширения модели движения КА
//-----------------------------------------------------------------------------
#include "stdafx.h"

//-----------------------------------------------------------------------------
// Компоненты Fly
#include <FlyCore.h>		// Собственоно сама модель движения
#include <FlyMMath.h>		// Математические функции
#include <FlyCoreLink.h>	// Подключение всех библиотек

int TaskTurnsPredictionHAvr();

void main()
{
	// Вывод кирилицы в консольном приложении 
	//setlocale(LC_CTYPE, "rus");
	SetConsoleCP(1251);
	SetConsoleOutputCP(1251);

	// Инициализация ядра Fly, фактически настройка путей к необходимым 
	// информационным ресурсам, инициализация глобальных переменных,
	// в последствии возможно инициализация соединения с БД...
	int rc = FlyGlobalInit(); if (rc) return;

	// Пример прогнозирования движения КА с осреднением параметров движения
	// и с вертикальным расширением модели движения КА.
	TaskTurnsPredictionHAvr();
}

//---------------------------------------------------------------------------
// Уточнение НУ с целью формирования онрбиты заданной 
// средне-интегральной высоты 
// Процедура корректировки НУ NU0 с целью получения из них в поле сил LSF
// НУ орбиты с заданной геометрией (e1z, e2z, az (или havrz)) в точке 
// с аргументом широты uz.
// Если заданно значение havrz, средняя интегральная на витке высота орбиты
// будет равна havrz.
// Результат - начальные условия NUK.
//---------------------------------------------------------------------------
int RunUpSysEstimateNU(
	ZLSF& LSF,		   // Поле сил
	ZNU&  NU0,		   // Исходные НУ
	ZNU&  NUK,		   // Полученные НУ (результат)
	double uz,		   // Аргумент широты на который задаётся геометрия орбиты
	double e1z,		   // Геометрия орбиты
	double e2z,
	double az,		   // Большая полуось (имеет смысл если не задано havrz)
	double havrz = 0); // Требуемая средняя высота орбиты

//-------------------------------------------------------------------------------
// Прогноз движения КА по виткам с расчётом осреднённой высоты для каждого витка
// Демонстрация механизма "вертикального" расширения модели движения КА
//		Основные демонстрируемые методы и классы: 
//		ZNU    NU			- Начальные условия - структура
//		ZSC_SI SI			- Элементы движения КА - структура
//		ZMSC   KA			- Модель движения, можно полагать её по сути своей 
//							  равной Космическому аппарату (КА) - класс
//		KA.Init(...)		- Инициализация модели движения - метод 
//		KA.GoToVit(...)		- Моделирование движения КА до начала заданного 
//							  витка - метод
//		KA.GoAlongVit(...)	- Прогноз вдоль витка с расчётом интегральных 
//							- параметров витка - метод
//		ZCPrintManager PrintMng - Диспетчер документирования - класс
//-------------------------------------------------------------------------------

// Наследуем МД для перегрузки метода расчёта внешних дифференциальных уравнений
ZMSC_EXV_BEG(ZModExternHAvr)
	// Реализация правых частей внешних дифференциальных уравнений
	// Вычисление координат в ГСК
	double GSK[6];
	int rc = ZASC1975toGSC(t, Xmain, GSK, 0);	RRC;
	// Вычисление высоты, широты и долготы
	double HBL[3];
	ZGRtoHBL(GSK, HBL, 0, 0);
	// Формирование правой части дополнительного уравнения движения 
	// Просто интегрируем высоту на ОЗЭ заданную в км.
	Yexe[0] = 1e4*HBL[0];
	// В процедуре создающей объект модели движения перед её инициализацией
	// определяеся что внешнее уравнение будет одно! 
	// "KA.SetExternalEquationsCount(1) ;"
	// Именно поэтому длинна вектора правых частей дополнительных уравнений
	// Yexe равна единице... Yexe[0] = ... 
	// 
ZMSC_END

//-------------------------------------------------------------------------------
int TaskTurnsPredictionHAvr()
{
	cout << "\n   Prediction by turns whith hight averaging...\n";

	int  rc = 0;
	long Vit;
	long Vitn = 100;	// Виток начала моделирование
	long Vitk = 212;	// Виток завершения моделирования

	cout << "   Fron turn " << Vitn << "  to " << Vitk << "\n";

	PZCPrintManager PrintMng;	// Диспетчер документирования
	PZMSC		    KA;			// Модель движения КА
	ZNU             NU;			// Начальные условия движения

	//---------------------------------------------------------------------------
	// Логическая шкала сил
	ZLSF LSF; memset(&LSF, 0, sizeof(LSF));
	LSF.num   = 1;			// Условный номер
	LSF.vgpz  = GPZ90;		// Грав поле Земли ПЗ-90 (!!!! не 90.11 !!!!)
	LSF.ngpz  = 16;			// Колличество секториальных 
	LSF.mgpz  = 16;			// и зональных гармоник
	LSF.vatm  = ATMSMA81;	// Статическая модель атмосферы ГОСТ 1981 года
	LSF.vsvd  = 0;			// Вариант модели светового давления
	LSF.varsp = 0;			//
	LSF.vTide = TIDENULL;	// Вариант учёта влияния океанических приливов
	LSF.isDU  = 0;			// Возможен ли учёт работы двигательной установки
	LSF.isSun = 1;			// Учёт гравитационного возмущения Солнца
	LSF.isMoon= 1;			// Учёт гравитационного возмущения Луны

	//---------------------------------------------------------------------------
	// Формирование НУ

	// Ключи НУ
	NU.Key.ka = 1; NU.Key.nom = 15; NU.Key.mod = 0;
	NU.Key.type = 8; NU.Key.bc = 1;

	// Условный номер логической шкалы сил
	NU.numlsf = 1;
	// Время НУ в ССС (NU.t)
	DATE dt = DATE(18, 7, 2018); 	// Календарная дата
	TIME tm = TIME(9, 30, 0, 0);	// Структурированное время
	TA_DMB(1, &dt, &tm, &NU.t);		// Преобразование структурированной даты 
	// и времени в ССС (скаляр)
	// Виток
	NU.vit = 99;

	// Система координат - оскулирующие элементы, заданный относительно
	// экватора эпохи 1975 года
	NU.sk = _SK_OSK1975;
	NU.X[0] = TO_DTKM(6650.0);
	NU.X[1] = 0.0001;
	NU.X[2] = TO_RAD(97.0);
	NU.X[3] = TO_RAD(120.0);
	NU.X[4] = TO_RAD(45.0);
	NU.X[5] = TO_RAD(15);
	NU.Sb = 0.001;
	NU.Kp = 0;
	NU.M0 = 900;
	NU.MF = 50;

	//---------------------------------------------------------------------------
	// Выбор параметров прогнозируемой орбиты - солнечно синхронная орбита
	{
		// Параметры проектируемой орбиты
		double T, i, a, p, e, e1, e2;
		// Расчёт по средней высоте
		double Hs = 270;
		// Вычисление параметров солнечно синхронной орбиты минимального изменения
		// высоты с заданной средней высотой Hs.
		rc = MBuildSSOMIV_hs(Hs, T, i, p, e1, e2, nullptr); 
		if (rc) return rc;

		// Модификация НУ - заполняем структуру НУ полученными 
		// параметрами движения для ССО
		e = sqrt(e1*e1 + e2*e2);
		a = p / (1 - e*e);
		NU.sk = _SK_OSKTE;
		NU.X[0] = TO_DTKM(a);
		NU.X[1] = e;
		NU.X[2] = TO_RAD(i);
		NU.X[3] = TO_RAD(120.0);
		NU.X[4] = TO_RAD(0);
		NU.X[5] = TO_RAD(1e-15);

		// Уточнение параметров НУ
		ZNU NUK;
		rc = RunUpSysEstimateNU(LSF, NU, NUK, 0, e1, e2, 0, Hs); 
		if (rc) return rc;
		NU = NUK;
	}

	//---------------------------------------------------------------------------
	// Определение колличества внешних уравнений (вертикальное расширение модели)
	KA->SetExternalEquationsCount(1);
	// Инициализация модели движения для расчёта от заданных НУ (NU)
	// в заданном поле сил (LSF)
	rc = KA->Init(NU, &LSF); 
	if (rc) return rc;

	//---------------------------------------------------------------------------
	// Определение состава элементов движения подлежащих документированию

	// Плоское документирование, то есть по строкам
	PrintMng->MPK.AflatOn();
	// Документирование параметров движения по виткам
	PrintMng->MPK.FromVitOn();
	// Собственно состав параметров
	PrintMng->MPK << MODPRDATE;		// Дата структурированная
	PrintMng->MPK << MODPRTIME;		// Время структурированное
	PrintMng->MPK << MODPR_VIT;			// Виток
	PrintMng->MPK << MODPR_MSSV;		// Местное среднее солнечное время
	PrintMng->MPK << MODPR_L;			// Долгота гринвическая
	PrintMng->MPK << MODPR_Aosk;		// Большая полуось
	PrintMng->MPK << MODPR_eosk;		// Эксцентриситет
	PrintMng->MPK << MODPR_V_Hsr;		// Средняя на витке высота
	PrintMng->MPK << MODPR_V_Hmaxt;		// Время достижения макс. высоты на витке
	PrintMng->MPK << MODPR_V_HmaxU;		// аргумент широты макс. высоты
	PrintMng->MPK << MODPR_V_Hmax;		// сама максимальная высота
	PrintMng->MPK << MODPR_V_Hmint;		// Аналогично для минимальной высоты: 
	PrintMng->MPK << MODPR_V_HminU;		// время, аргумент широты, сама высота
	PrintMng->MPK << MODPR_V_Hmin;		//
	PrintMng->MPK << MODPR_V_Rmaxt;		// Аналогично для максимального на витке 
	PrintMng->MPK << MODPR_V_RmaxU;		// радиуса.
	PrintMng->MPK << MODPR_V_Rmax;		//
	PrintMng->MPK << MODPR_V_Rmint;		// Аналогично для минимального на витке 
	PrintMng->MPK << MODPR_V_RminU;		// радиуса
	PrintMng->MPK << MODPR_V_Rmin;		//

	// Создание текстового документа
	PrintMng->PrePrint(&KA, "Прогноз", "_TaskTurnsPredictionHAvr");
	PrintMng->PrintHeaderDoc("Прогноз движения КА");
	PrintMng->PrintText("Прогноз движения КА по виткам с расчётом осреднённой \
высоты для каждого витка. НУ уточняются по заданным начальным условиям с целью \
формирования заданной средней высоты орбиты.");

	// Документирование НУ и ЛШС
	PrintMng->PrintNU (NU, nullptr, 3);
	PrintMng->PrintLSF(LSF, 1);

	// Структура для получения элементов движения КА
	ZSC_SI SI;
	// Прогнозирование состояния КА на виток начала моделирования
	cout << "\r       turn  " << Vitn << "...    ";
	rc = KA->GoToVit(Vitn, &SI); 
	if (rc) return rc;
	Vit = Vitn;

	while (1) {
		// Подключение заданных ранее внешних уравнений 
		// Начальные условия для внешнего уравнения в данном случае 
		// будут полагаться нулевыми.
		KA->ExternalEquationsOn();
		// Моделирование движения КА вдоль витка Vit с расчётом всех элементов
		// движения КА, в том числе и интегральных характеристик витка.
		cout << "\r       turn  " << Vit << "...    ";
		rc = KA->GoAlongVit(Vit, _SK_ASKTE); if (rc) break;
		// Вычисление высоты осреднённой на витке вдоль которого только что
		// моделировалось движение.
		// Текущее значение внешней переменной, которая интегрировалась внедрённым
		// в модель движения внешним уравнением.
		double HAvr;
		KA->ExternalEquationsOff(&HAvr);
		// Полученное значение делится на драконический период выраженный в средних
		// солнечных сутках.
		HAvr /= (KA->FV.Td / k_cbc);
		// Таким образом и получается средне-интегральное на витке значение высоты
		// полёта КА
		KA->FV.HAvr = HAvr;
		// Документирование текущих элементов движения КА.
		PrintMng->PrintMSC(&KA);
		// Перенход к следующему витку
		Vit++;
		// Проверка условия завершения моделирования
		if (Vit>Vitk) break;
	}
	cout << "\n";

	// Завершение документирования.
	PrintMng->PostPrint();
	PrintMng->ClosePrint();

	// Просмотр результатов средствами операционной системы
	PrintMng->ShowTextFile();
	PrintMng->ShowHtmlFile();

	return rc;
}

//-------------------------------------------------------------------------------


