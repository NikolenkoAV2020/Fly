//-------------------------------------------------------------------------------
// TaskFlightTrack.cpp
// Пример программы расчёта трассы полёта КА
//
// А. Николенко 03.08.2018
//-------------------------------------------------------------------------------
#include "stdafx.h"

//---------------------------------------------------------------------------
// Компоненты Fly
#include <FlyCore.h>		// Собственоно сама модель движения

//---------------------------------------------------------------------------
// Параметры документирования
//   Размерность угловых величин 
//		0 - градусы
//		1 - радианы
//		2 - градусы, минуты, секунды
static const int vardimBLF = 0;
//   Размерность углов Солнца
//		0 - градусы
//		1 - радианы
//		2 - градусы, минуты, секунды
static const int vardimUMS = 2;
static bool      FirstPrint = true;

//-------------------------------------------------------------------------------
// Документирование результатов рассчёа трассы
void FlightTrackPrint(ZSC_SI* SI, FILE* fp);

//-------------------------------------------------------------------------------
// Трасса полёта
int TaskFlightTrack()
{
	cout << "\n   Calculation flight path...\n";

	ZCPrintManager PrintMng;		// Диспетчер документирования 
	ZNU    NU;					// Начальные условия
	ZLSF   LSF;					// Логическая шкала сил
	ZMSC   KA;					// Модель движения (КА)

	double h = 3.0/24.0/60.0;	// Шаг расчёта трассы в ССС (часть от 86400 сек)
	double t, t0, tk, X[ 6 ] ;
	long   Vit ;

	int    rc = 0;

	// Время завершения моделирования полёта КА
	tk << DATETIMEDMB(21, 06, 2018, 7, 44, 33, 0.371) ;

	// Формирование структуры НУ 
	// В production данная структура должна загружаться из внешнего источника
	// данных, например из БД, или из файла УОФ01, или формироваться 
	// посредством GUI 

	// Ключи НУ
	NU.Key.ka = 314 ; NU.Key.nom = 15 ; NU.Key.mod = 0 ;
	NU.Key.type = 8 ; NU.Key.bc = 1 ;
	// Номер ЛШС
	NU.numlsf = 1 ;
	// Дата и время НУ свёрнутые в скаляр
	NU.t << DATETIMEDMB(20, 06, 2018, 7, 44, 33, 0.371) ;
	// Виток НУ
	NU.vit  = 2113 ;
	// Система координат в которой заданы НУ (Гринвич)
	NU.sk   = _SK_GSK ;
	// Координаты и скорости представленные во внутренней размерности модели
	// ДТКМы и ДТКМ за ССС - именно в такой размерности они интегрируются 
	// в интеграторе.
	//		-1184.4708982 это X в км
	//      в ДТКМ данная координата будет иметь значение -0.11844708982
	NU.X[0] = TO_DTKM(-1184.4708982) ;
	NU.X[1] = TO_DTKM(6787.8144262) ;
	NU.X[2] = TO_DTKM(0) ;
	//		1.4684391398 это Vx в км/сек
	//		В ДТКМ за ССС будет иметь значение 0.00014684391398 * 86400
	NU.X[3] = TO_DTKMSSS(1.4684391398) ;
	NU.X[4] = TO_DTKMSSS(0.24668951606) ;
	NU.X[5] = TO_DTKMSSS(7.5434684871) ;
	// Баллистический коэффициент
	NU.Sb   = 0.0014421888 ;
	// Коэффициент светового давления
	NU.Kp   = 0 ;
	// Масса КА сухая (без топлива)
	NU.M0   = 900 ;
	// Актуальный запас топлива на борту
	NU.MF   = 50 ;

	// Инициализация модели движения
	rc = KA.Init(NU); if (rc) return rc;

	// Так можно получить НУ которыми была проинициализированна 
	// модель движения
	KA.GetNU( NU ) ; t0 = NU.t ;
	// Так можно получить текущий вектор кинематических параметров,
	// виток и время
	rc = KA.GetVector(X, &Vit, &t); if (rc) return rc;

	// Настройка документирования
	FILE* fp = NULL;
	FirstPrint = true;
	// Создание файла документа
	PrintMng.PrePrint(&KA, "Прогноз", "_TaskFlightTrack", &fp) ;
	// Заголовок создаваемого документа
	PrintMng.PrintHeaderDoc("\n   Трасса полёта КА\n\n\0", fp) ;

	// Документирование НУ
	PrintMng.PrintNU(NU, NULL, 3, fp) ;
	// Так можно получить логическую шкалу сил при которая использовалась
	// при инициализации модели движения
	KA.GetLSF(LSF) ;
	// Документирование логической шкалы сил
	PrintMng.PrintLSF(LSF, 1, fp) ;

	// ZSC_SI SI - структура для хранения и доступа 
	// элементам движения КА 
	ZSC_SI SI ; memcpy(&SI, &KA.FSC, sizeof(SI)) ;
	// Документирование текущих (начальных )элементов движения КА. 
	// Детали документирования определены в локальной функции FlightTrackPrint.
	FlightTrackPrint(&SI, fp) ; 

	// Цыкл моделирования движения с получением элементов движения КА с заданным
	// шагом h. Важно h НЕ равен шагу интегрирования задачи Коши!
	while(1) {
		// Текущее время
		t = KA.GetTime() ;
		// Условие завершения моделирования
		if (t+h/2.0>tk) break ;
		// Подшагивание на указанный шаг - точнее говоря прогноз движения КА от
		// текущего момента времени до момента отстоящего о текущего на h.
		// h задан в средних солнечных сутках, то есть как часть от 86400 секунд.
		// Функция подшагивания возвращает элементы движения КА на момент t+h
		// в виде структуры SI. 
		rc = KA.GoDTime(h, &SI) ; if (rc) break ;
		// Документирование текущих элементов движения КА. 
		// Детали документирования определены в локальной функции FlightTrackPrint.
		FlightTrackPrint(&SI, fp) ; 
	}
	// Завершение документирования - сброс буфера и закрытие файла документа.
	PrintMng.PostPrint(&fp) ;
	PrintMng.ClosePrint(&fp);
	cout << "\n\n";

	return rc ;
}

//-------------------------------------------------------------------------------
// Документирование результатов рассчёа трассы
//-------------------------------------------------------------------------------
static CFormatString FDataTime;
static CFormatString FArcBL;
static CFormatString FTdr;
static CFormatString FUMS;

//-------------------------------------------------------------------------------
void FlightTrackPrint(ZSC_SI* SI, FILE* fp)
{
	if (FirstPrint) {
		// Выполняется только в случае первого вызова
		FirstPrint = false;

		// Определение характеристик форматов вывода данных: 
		// FDataTime, FArcBL, FUMS.

		FDataTime.FormatedDateTime(0);
		FDataTime.SetFixedLastField(true);
		FDataTime.SetDec(4);

		switch (vardimBLF) {
		case 0: FArcBL.FormatedGrad(0); FArcBL.SetDec(8); break;
		case 1: FArcBL.FormatedRad(0); FArcBL.SetDec(9); break;
		case 2: FArcBL.FormatedGMS(0); FArcBL.SetDec(4); break;
		}
		FArcBL.SetFixedLastField(true);
		FArcBL.SetFixedFirstField(false);
		FArcBL.SetFormatIO(EDF_GRAD);
		FArcBL.SetSign(true);

		switch (vardimUMS) {
		case 0: FUMS.FormatedGrad(0); FUMS.SetDec(8); break;
		case 1: FUMS.FormatedRad(0); FUMS.SetDec(9); break;
		case 2: FUMS.FormatedGMS(0); FUMS.SetDec(4); break;
		}
		FUMS.SetFixedLastField(true);
		FUMS.SetFixedFirstField(false);
		FUMS.SetFormatIO(EDF_RAD);
		FUMS.SetSign(true);

		// Заголовок таблицы
		fprintf(fp, "____________________________________________________________________________________________\n");
		fprintf(fp, "  Дата       Время         Долгота,        Широта,          Высота,        Уг. места Солнца,\n");
		fprintf(fp, "                           град            град             км             град\n");
		fprintf(fp, "____________________________________________________________________________________________\n");

		// Отображение в консоли
		printf("\n\n");
	}

	// Документирование одной строки таблицы
	FDataTime << SI->ta;
	FArcBL << SI->THBLFR[3];
	fprintf(fp, " %s %13s", FDataTime.GetText(), FArcBL.GetText());
	printf("\r %s %13s ", FDataTime.GetText(), FArcBL.GetText());	// Отображение в консоли
	FArcBL << SI->THBLFR[2];
	fprintf(fp, " %14s %16.6lf", FArcBL.GetText(), SI->THBLFR[1]);
	printf(" %14s %16.6lf", FArcBL.GetText(), SI->THBLFR[1]);		// Отображение в консоли
	FUMS << SI->SA[0];
	fprintf(fp, "%18s\n", FUMS.GetText());
}

//-------------------------------------------------------------------------------
