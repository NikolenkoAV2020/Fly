//-------------------------------------------------------------------------------
// FlightCalcPrediction.cpp
// Прогноз от НУ на заданном интервале времени с расчётом интегральных 
// характеристик витка НУ
// 
// А. Николенко 14.02.2019
//-------------------------------------------------------------------------------
#include "stdafx.h"

//---------------------------------------------------------------------------
// Компоненты Fly
#include <FlyCore.h>			// Собственоно сама модель движения

//-------------------------------------------------------------------------------
// Наследуем МД для перегрузки метода расчёта внешних дифференциальных уравнений
ZMSC_EXV_BEG(ZModKHAvr)
	// Правые части внешних дифференциальных уравнений
	double GSK[6] ;
	int rc = ZASC1975toGSC(t, Xmain, GSK, 0) ;	RRC ;
	double HBL[3] ;
	ZGRtoHBL(GSK, HBL, 0, 0) ;
	// Интегрирование высоты полёта
	Yexe[0] = 1e4*HBL[0] ;
ZMSC_END

//-------------------------------------------------------------------------------
// Простой прогноз
//		NU	-	НУ от которых нужно прогнозировать
//		LSF	-`	Шкала сил в которой выполняется прогноз
//		dt	-	Интервал прогнозирования (7 суток например)
//		dL, dLs, Hmin, ... - Межвитковое расстояние, суточный сдвиг трасы,
//				мин. высота, ... на витке НУ
//	
int FlightCalcPrediction(ZNU& NU, ZLSF& LSF, double dt, char* FilePrintSticker, 
						 double* dL, double* dLs, double* Hmin, 
						 double* Hmax, double* Hs)
{
	printf("Motion prediction...\n") ;
	int rc = 0 ; 

	// Осуществляется расчет драконического периода   
	// путем прогнозирования движения МКА в принятой модели движения.
	// Модель движения КА
	ZMSC KA ;
	// Инициализация модели движения
	rc = KA.Init(NU, &LSF) ; RRC ;

	//---------------------------------------------------------------------------
	// Если необходим расчёт мин мах и средней высоты, 
	// то моделируем виток с учётом одного внешнего уравнения
	// для расчёта осреднённой на витке высоты (среднеинтегрального
	// значения).
	if (Hmin || Hmax || Hs || dLs || dL) {
		ZModKHAvr KA ;
		// Задаём число внешних уравнений
		KA.SetExternalEquationsCount(1) ;
		// Инициализируем модель
		rc = KA.Init(NU, &LSF) ; RRC ;
		// Включаем интегрирование внешнего уравнения,
		// при этом задаются нулевые НУ для внешних уравнений
 		KA.ExternalEquationsOn(NULL) ;
		// Моделирование траектории полёта вдоль витка NU.vit
		KA.GoAlongVit(NU.vit) ;
		// Значение проинтегрированного внешнего уравнения
		double HAvr ;
		KA.ExternalEquationsOff(&HAvr) ;
		// Делим на драконический период чтобы получить 
		// среднеинтегральное значение параметра
		HAvr/= (KA.FV.Td/k_cbc) ;
		// Заменяем значение в массиве интегральных параметров витка
		KA.FV.HAvr = HAvr ;

		// Межвитковый сдвиг в градусах
		if (dL ) *dL = KA.FV.dL ;	
		// Суточное смещение трасы в градусах
		if (dLs) *dLs= KA.FV.dLs ;	

		// Выбор из локальных минимумов глобально минимальной высоты на витке
		ZSC_VP* HM1 = HMIN_VI(KA.FV) ;
		// Выбор из локальных максимумов глобально максимальной высоты на витке
		ZSC_VP* HM2 = HMAX_VI(KA.FV) ;
		if (Hmin) *Hmin = HM1->H ; 
		if (Hmax) *Hmax = HM2->H ; 
		if (Hs  ) *Hs   = KA.FV.HAvr ; 
	}

	//---------------------------------------------------------------------------
	// Диспетчер документирования
	ZCPrintManager PrintMng ;
	// Отключить документирование прогноза по виткам
	PrintMng.MPK.FromVitOff() ;
	// Документирование результатов прогноза по строкам (горизонтально)
	PrintMng.MPK.AflatOn() ;

	//---------------------------------------------------------------------------
	FAST_SEMAPFORE_OPEN("FlightKanopusMPKBuild") ;

	//---------------------------------------------------------------------------
	// Параметризация ПОЛЬЗОВАТЕЛЬСКОГО докумеентирования результатов прогноза.
	// Указыватся: тип параметра, его точность (число знаков после запятой),
	// максимальное колличество символов для представления и название.
	// Значения документируемых параметров задаются далее при помощи
	// функции PMPK.UPP(0).value = ...
	PrintMng.MPK << ZSUserPrintParam(UPPdouble, 16, 6, "время", "часы") ;
	PrintMng.MPK.UPP(0).value = 0 ;
	// Добавление документируемых параметров движения
	PrintMng.MPK << MODPRDATETIME ;
	PrintMng.MPK << MODPR_MSSV ;
	PrintMng.MPK << MODPR_T_iTE ;
	PrintMng.MPK << MODPR_T_WTE ;
	PrintMng.MPK << MODPR_T_wTE ;
	PrintMng.MPK << MODPR_T_uTE ;
	PrintMng.MPK << MODPR_H ;
	PrintMng.MPK << MODPR_Aosk ;
	PrintMng.MPK << MODPR_eosk ;
	PrintMng.MPK << MODPR_exosk ;
	PrintMng.MPK << MODPR_eyosk ;

	//---------------------------------------------------------------------------
	FAST_SEMAPFORE_CLOSE() ;

	//---------------------------------------------------------------------------
	// Инициализация документирования
	//---------------------------------------------------------------------------
	// Добавляем стикер к имени файла документа
	PrintMng.SetPrintFileSticker(FilePrintSticker) ;
	// Создание текстового документа
	PrintMng.PrePrint(&KA, "Прогноз", "_FlightKanopus") ;
	// Заголовок документа
	PrintMng.PrintHeaderDoc("\n Прогноз параметров движения КА (FlightKanopus)\n") ;

	// Документирование НУ
	PrintMng.PrintNU(NU, NULL, 3) ;
	// Документирование логической шкалы сил
	PrintMng.PrintLSF(LSF, 1) ;

	//---------------------------------------------------------------------------
	// Собственно само прогнозирование параметров движения КА
	//---------------------------------------------------------------------------

	// Документирование параметров движения
	PrintMng.PrintMSC(&KA, NULL, NULL, NULL) ; 
	// Текущее время
	double t  = KA.GetTime() ;
	// Начальное время
	double tn = t ;
	// Конечное время время
	double tk = t+dt ;
	int   dir = tk>=t ? 1:-1 ;
	// Цыкл моделирования 
	ZSC_SI SI ;
	while(1) {
		printf("\rCompleted %.2lf%s    ", (t-tn)/dt*100.0, "%") ;
		// Проверка условия завершения численного интегрирования (прогноза)
		if (t>=tk) break ;
		// Один шаг интегратора с автоматическим выбором его величины, 
		// но не далее чем момент времени tk. То есть h <= tk-t, где
		// t есть текущее время
		rc = KA.GoStepA(&SI, dir, &tk) ; if (rc) break ;
		// Новое текущее время 
		t = SI.ta ;
		// Пользовательское докумеентирования результатов прогноза.
		// Задаётся значение дополнительного параметра,
		// декларируемого ранее при помощи вызова оператора 
		// PrintMng.MPK << ZSUserPrintParam(UPPdouble...
		PrintMng.MPK.UPP(0).value = (t-tn)*24.0;
		// Документирование полученных параметров движения
		PrintMng.PrintMSC(&KA, &SI, NULL, NULL) ;
	}
	printf("\n") ;

	//---------------------------------------------------------------------------
	// Завершение документирования
	PrintMng.PostPrint() ; 
	PrintMng.ClosePrint();

	return 0 ;
}

//-------------------------------------------------------------------------------
