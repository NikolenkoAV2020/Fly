//-------------------------------------------------------------------------------
// ZMSpaceCraftTime.cpp
// А. Николенко 03.08.2018
//-------------------------------------------------------------------------------
#pragma once
#include <stdafx.h>

//---------------------------------------------------------------------------
// Компоненты Fly
#include <FlyMMath.h>	// Математические функции

//---------------------------------------------------------------------------
#include <FlyCoreSource\\ModGlobal.h>
#include <FlyCoreSource\\ZMSpaceCraft.h>

//-------------------------------------------------------------------------------
int ZMSC::GoToTime(double tk, ZSC_SI* SI) 
{
	double t ;
	int    dir = (tk>=GetTime()?1:-1) ;
	int    rc = 0 ; 

	// Задаём направления интегрирования
	SetDirect(dir) ;
	// Инициализация диспетчера программ управления
	MPU.Init() ;

	ZSC_SI SAI ;
	while(1) {
		// Один шаг интегратора с автоматическим выбором его величины, 
		// но не далее чем момент времени tk. То есть h <= tk-t, где
		// t есть текущее время
		rc = GoStepA(&SAI, dir, &tk) ; if (rc) break ;
		// Текущее время
		t = SAI.ta ;
		if (dir*t>=dir*tk) {
			if (fabs(t-tk)*k_cbc<1e-10) {
				// Если интегрируя по шагам точно вышли на заданный момент
				FSE = FSC ;
				FSE.E.ID = ModEvent_ONTIME ;
				FSE.E.ta = t ;
				FSE.E.Value = FSE.E.Value2 = FSE.E.Value3 = FSE.E.Value4 = 0.0 ;
				FSE.E.Value5 = 0 ;
				if (SI) memcpy(SI, &FSE, sizeof(FSE)) ;  
				break ;
			}
			// Сохраняем состояние интегратора (то есть интегрируемый вектор состояния)
			FastStory() ;
			// Отшагиваем назад до требуемого значения времени
			// в пределах последнего шага
			// Формирование структуры FSI происходит внутри ф-ии GoStep
			rc = BackStep(SI, tk-t, ModEvent_ONTIME) ; if (rc) break ;
			// Восстанавливаем состояние интегратора
			FastReStory() ;
			// Таким образом состояние интегратора остаётся соответствующим последнему
			// шагу интегрирование (момент времени t), на этот момент формируется структура
			// FSC, содержащая все параметры движения на момент времени t.
			// Одновременно формируется структура
			// FSE, содержащая все параметры движения на момент tk наступления события 
			// ModEvent_ONTIME - достижения заданного момента времени (tk). 
			//
			// Попытка доступа к текущим параметрам движения приведёт к извлечению последних
			// из структуры FSE, запрос текущего времени также вернёт не значение t,
			// а вернёт значение tk!
			//
			// Попытка продолжения интегрирования СДУ приводит к реализации шага интегрирования
			// от момента времени t (не tk)! То есть от параметров движения FSC а не от FSE!
			//
			// Основная тонкость настоящей реализации модели движения состоит в корректном
			// моделировании наступления того или иного события межжду моментами времени
			// t и tk, например события - включение двигательной установки, если такое
			// событие генерируется программистом межу вызовами функций GoToTime и ей подобных
			break ;
	}	}

	// Событие "выход на заданный момент времени" 
	// одновременно является результатом прогноза, поэтому копируем FSE в FSR
	memcpy(&FSR, &FSE, sizeof(FSR)) ;

	return rc ;
}

//-------------------------------------------------------------------------------
int ZMSC::GoDTime(double dt, ZSC_SI* SI) 
{
	return (GoToTime(GetTime()+dt, SI)) ;
}

//-------------------------------------------------------------------------------
int ZMSC::GoToU(double u, ZSC_SI* SI, SK_TYPE sk)
{
	// Текущий виток в заданной СК
	long vit = GetVitok(sk) ;
	// Прогноз до заданного аргумента широты u текущего витка vit
	int rc = GoToVitU(vit, u, SI, sk);
	return rc ;
}

//-------------------------------------------------------------------------------
int ZMSC::GoToDU(double DU, ZSC_SI* SI)
{
	DU = TO_RAD(DU) ;
	int dir = DU >= 0 ? 1 :-1 ;
	DU = fabs( DU ) ;
	long   Vitn = GetVitok( ) ;
	double Un   = GetU( ) ;
	long   dVit = ( long )( DU / k_dwapi ) ;
	DU = DU-dVit*k_dwapi ;
	long   Vitk = Vitn+dVit*dir ;
	double Uk   = Un+DU*dir ;
	if (Uk>k_dwapi ) { Uk-= k_dwapi ; Vitk+= 1 ;	}
	if (Uk<0 ) { Uk+= k_dwapi ; Vitk-= 1 ; }
	return(GoToVitU(Vitk, TO_GRAD(Uk), SI));
}

//-------------------------------------------------------------------------------