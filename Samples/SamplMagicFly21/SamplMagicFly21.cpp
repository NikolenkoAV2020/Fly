//-----------------------------------------------------------------------------
// SamplMagicFly21.cpp
//
// А. Николенко 20.06.2019
//-----------------------------------------------------------------------------
#include "stdafx.h"

//-----------------------------------------------------------------------------
// Компоненты Fly
#include <FlyCore.h>
#include <FlyMMath.h>		// Математические функции
#include <FlyMagicLNS.h>	// Метод узловых точек
#include <FlyCoreLink.h>

int TestMagicFly21(int TypeOrb);

int TaskMagicFlyBegin(ZSMagicLnsSolution* MS, int task, ZMSC& KA, ZNU& NU,
	ZLSF& LSF, bool ResetNU, ZCPrintManager* PrintMng,
	FILE** pfp);

void main()
{
	// Вывод кирилицы в консольном приложении 
	//setlocale(LC_CTYPE, "rus");
	SetConsoleCP(1251);
	SetConsoleOutputCP(1251);

	// Инициализация ядра Fly, фактически настройка путей к необходимым 
	// информационным ресурсам, инициализация глобальных переменных,
	// в последствии возможно инициализация соединения с БД...
	int rc = FlyGlobalInit(); if (rc) return;

	//
	int TypeOrb = SPO_ORB_HBH;
	TestMagicFly21(TypeOrb);
}

//-----------------------------------------------------------------------------
int TestMagicFly21(int TypeOrb)
{
	// идентификатор задачи (иными словами номер варианта маневрирования)
	int indexTask = 21;
	int rc = 0;

	//---------------------------------------------------------------------------
	// Создаём "Модель решения"
	// По сути своей модель решения это контейнер, который содержит: 
	//		- характеристики двигутельной установки, 
	//		- массив параметров задачи (опции),
	//		- задание на решение задачи (массив информации, обычно задаваемый 
	//		  оператором в интерактивном режиме).
	// ... Таким образом эту самую модель перед решением нужно создать.
	//---------------------------------------------------------------------------
	ZSMagicLnsSolution* MS = CreateMagicLnsSolution(); if (!MS) return 1;

	//---------------------------------------------------------------------------
	// TypeOrb - Тип требуемой орбиты
	//		SPO_ORB_EL	- геометрия требуемой орбиты задаётся как e, w.
	//		SPO_ORB_HBH	- геометрия требуемой орбиты задаётся как Hmin, Bhmin.
	//		SPO_ORB_OMIV- параметры требуемой орбиты обеспечивают минимальное.
	//					  изменение высоты на витке (e, w выбираются исходя из 
	//					  условия ОМИВ).
	//		SPO_ORB_DU	- параметры требуемой орбиты обеспечивают динамическую
	//					  устойчивость (e, w выбираются исходя из условия ДУ).
	//---------------------------------------------------------------------------
	MS->MZ.ORB() = TypeOrb;

	//--------------------------------------------------------------------------
	// Инициализация НУ, ЛШС и модели движения, настройка документирования
	//--------------------------------------------------------------------------
	ZNU   NU;			// НУ движения КА.
	ZLSF  LSF;			// Логическая шкала сил в которой выполняется решение. 
	ZMSC  KA;			// Модель движения (или просто КА)
	FILE* fp = nullptr;	// Файл для документирования результатов решения
	// Диспетчер документирования
	// Несмотря на то что диспетчер документирования ZCPrintManager был разработан
	// для документирования результатов прогноза, он находит своё применение и
	// в прикладных задачах, в части касающейся создания документа, вывода 
	// заголовка документа, документирования НУ и ЛШС, документирования 
	// информации о времени расчёта и его длителоьности, форматированного 
	// документирования данных в заданный контекст (просто говоря в звдвнный 
	// файл). 
	// В итоге диспетчер документирования нам нужен!
	ZCPrintManager PrintMng;

	// Инициализация основных данных необходимых для решения тестовых задач
	// расчёта параметров орбитального маневрирования - задание на расчёт
	// "фиксированная" часть. 
	// Данный метод общий для
	// всех тестовых процедур именованных как TaskMagicFly__.
	// В "Prodaction" необходимость в данном методе отпадает. Вся его 
	// функциональная нагрузка ложится на GUI 
	// и/или на средства автоматизации АПК.
	rc = TaskMagicFlyBegin(MS, indexTask, KA, NU, LSF, true, &PrintMng, &fp);
	if (rc) goto end;

	//--------------------------------------------------------------------------
	// Формирование задания на расёт, "опреративная" часть (формируется в 
	// интерактивном режиме с использованием GUI)
	MS->MZ.VITIMP(0) = 2;		// Виток первого импульса
	MS->MZ.VITIMP(1) = 4;		// Виток второго импульса
	MS->MZ.VIT() = 5;		// Заданный виток на котором контролируются 
	// краевые условия
	// Требуемые параметры орбиты
	MS->MZ.PARL() = 131.2;		// Долгота ВУ
	MS->MZ.PART() = 5503.0;		// Драконический период
	MS->MZ.PARh() = 210.0;		// Минимальная высота
	MS->MZ.PARBh() = 10;			// Широта минимальной высоты
	MS->MZ.PARBv() = 1;			// Восходящая ветвь
	MS->MZ.PARe() = 0.0002;		//	
	MS->MZ.PARw() = 90.0;		//	

	// Взводим флаг уточнения формы орбиты для того чтобы
	// На итерациях изменять прицельные значения минимальной высоты и её широты
	MS->MP.isEstimateOrb = true;

	//--------------------------------------------------------------------------
	// Решение задачи расчёта параметров коррекции по заданию MZ 
	{
		ZSLoopFact  P1;	// Параметры движения на виток первого имп 
		ZSLoopFact  P2;	// Параметры движения на виток второго имп 
		ZSLoopFact  PN;	// Начальные параметры движения на заданный виток
		ZSLoopFact  PR;	// Расчётные конечные параметры движения на заданный виток 
		ZSFlightRule U;	// Прогрмамма управления

		// Процедура итерационного решения формализованной задачи расчёта методом
		// узловых точек. Данная процедура является единой для всех тестовых задач
		// именованных как TaskMagicFly__. 
		rc = MagicSolution(MS, &PrintMng, fp, LSF, KA, NU, nullptr,
			&P1, &P2, &PN, &PR, &U);
		// Закрытие документа с результатами решения
		PrintMng.ClosePrint(&fp);
	}
end:;
	//---------------------------------------------------------------------------
	// В завершении удаляем созданную ранее "Модель решения"
	FreeMagicLnsSolution(MS);

	return 0;
}

//-----------------------------------------------------------------------------