//---------------------------------------------------------------------------
// ZSun.cpp
// А. Николенко 03.08.2018
//---------------------------------------------------------------------------
#include <stdafx.h>
#pragma   hdrstop
#include <FlyMMath.h>
#include <FlyTime.h>

#include <FlyCoreSource\\ModType.h>
#include <FlyCoreSource\\ModGlobal.h>
#include <FlyCoreSource\\ModAstro.h>
#include <FlyCoreSource\\ZPR.h>
#include <FlyCoreSource\\ZNUT.h>
#include <FlyCoreSource\\ZAvrE0.h>
#include <FlyCoreSource\\ZSun.h>
#include <FlyCoreSource\\ZCalc.h>

static double		inquiry_eps_t = 1e-3/k_cbc ;		// 1-а тысячная доля секундв	
static ZSUN_POINT	last_inquiry_SunPoint = {			// Последний массив расчетной информации по Солнцу
					-999999.0, -999999.0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, {0, 0, 0}, {0, 0, 0}} ;
//----------------------------------------------------------------------------
// Расчет положения Солнца 
// с точностью не хуже 2 угловых секунд
// Результат в виде прямоугольных координат в АСК J2000 
// flag:
//	0 - ta задано в ссс от J2000 (0h 01.01.2000)
//	1 - ta задано в ссс от J1975 (0h 01.01.1975)
//	2 - ta задано в юлианских столетиях от J2000 (12h 01.01.2000)
//----------------------------------------------------------------------------
int ZSunJ2000(double ta, double *Sun, TIMESCALE Scale, bool notStory)
{
	ZSUN_POINT SP ;
	int rc = ZSun(ta, SP, Scale, notStory) ; RRC ;
	memcpy(Sun, SP.X2000, 3*sizeof(double)) ;   
	return 0 ; 
}

//----------------------------------------------------------------------------
int ZSun(double ta, ZSUN_POINT& SP, TIMESCALE Scale, bool notStory)
{
	double t = Astro2000Time(ta, Scale, &ta) ;

	// Проверка необходимости расчета 
	if (fabs(last_inquiry_SunPoint.ta-ta)<=inquiry_eps_t) {
		// Если при предыдущем вызове данной функции атрибуты Солнца уже были 
		// расчитаны на момент времени достаточно близкий к t, то повторный расчет не выполняется
		// а просто копируется расчитанный ранее массив информации
		// Структутра last_inquiry_SunPoint запоминается после каждого нового расчёта
		memcpy(&SP, &last_inquiry_SunPoint, sizeof(ZSUN_POINT));
		return 0 ;
	}

#ifdef Z_CALCSUN_SIMPLE
	// Упрощенныё расчёт
	// Отклонения от АЕ в земном экваторе
	//		- по прямому восхожденю	15-20 угловых секунд 
	//		- по склоненю			10 угловых секунд 
	//
	SP.E0 = ZAverageE0(t, TIMEJ2000JC) / M_SEKRAD;				// В радианах
	SP.E0g= SP.E0*M_GRARAD ;	
	// В градусах

	ZSunSimple(t, TIMEJ2000JC, SP.XTES, 0) ;	
	SP.R   = SP.XTES[2] ;			// в дткм
	SP.alf = SP.XTES[0] ;			// В радианах
	SP.dlt = SP.XTES[1] ;
	SP.alfg = SP.alf*M_GRARAD;		// В градусах
	SP.dltg = SP.dlt*M_GRARAD;

	SP.XTES[0] = SP.R*cos(SP.dlt)*cos(SP.alf) ; 
	SP.XTES[1] = SP.R*cos(SP.dlt)*sin(SP.alf) ; 
	SP.XTES[2] = SP.R*sin(SP.dlt) ;

	//double dg = floor(SP.dltg);
	//double dm = floor((SP.dltg-dg)*60.0);
	//double ds = ((SP.dltg-dg)*60.0-dm)*60.0 ;
	//double ah = floor(24.0*SP.alfg/360.0) ;
	//double am = floor((24.0*SP.alfg/360.0-ah)*60.0) ;
	//double as = ((24.0*SP.alfg/360.0-ah)*60.0-am)*60.0 ;

	// Матрица поворота вокруг оси X на угол E0
	double MX[9] = {
		1.0,	 0.0,			0.0,
		0.0,	 cos(SP.E0),	sin(SP.E0),
		0.0,	-sin(SP.E0),	cos(SP.E0)} ;

	// Пересчет координат SP.XTES в геоцентрическую эклиптическую АСК - координаты Xe
	double Xe[3] ; 
	umpr(MX, SP.XTES, Xe);
	// Эклиптические долгота и широта
	SP.Ls = Atan2(Xe[1], Xe[0], 0) ;	// В радианах 
	SP.Bs = Asin(Xe[2]/SP.R, 0) ; 
	SP.Lsg = SP.Ls*M_GRARAD;			// В градусах
	SP.Bsg = SP.Bs*M_GRARAD;

#else
	// Более точный расчёт
	// Отклонения от АЕ в земном экваторе
	//		- по прямому восхожденю	2 угловые секунды 
	//		- по склоненю			9 угловых секунд 
	int i ;
	//------------------------------------------------------------------------
	// u2 . средняя аномалия Венеры, 
	// u3 . средняя аномалия Земли, 
	// u4 . средняя аномалия Марса, 
	// u5 . средняя аномалия Юпитера, 
	// u6 . средняя аномалия Сатурна, 
	// и числовые значения аргументов теории движения Луны D, l, F.
	//------------------------------------------------------------------------
	// Значения средних аномалий планет u2, u3, u4, u5, u6 
	// и средних аргументов модели движения Луны D, l, F всё в радианах
	double u[8] ;
	static double K[8][2] = { 
		{0.87167007, 1021.32292307},
		{6.23999846, 628.30194562},
		{0.34133404, 334.05561755}, 
		{0.34667475, 52.96346464},
		{5.53957033, 21.32432794},
		{5.19870752, 7771.37722506},
		{2.35556617, 8328.69136358},
		{1.62797331, 8433.46599185} } ;
	for(i=0; i<8; i++) u[i] = K[i][0] + K[i][1]*t ;
	double u2=u[0], u3=u[1], u4=u[2], u5=u[3], u6=u[4] ;
	double D=u[5], l=u[6], F=u[7] ;	

	//------------------------------------------------------------------------	
	// Возмущение в эклиптической долготе Ls. Единица измерения - угловые секунды.
	double dLs ;
	// Кеплеровские члены и возмущения от Венеры в долготе
	dLs =-0.22*cos(u3)+6892.76*sin(u3)
		 +(-0.06*cos(u3)-17.35*sin(u3))*t
		 +(-0.01*cos(u3)-0.05*sin(u3))*t*t
		 +71.98*sin(2*u3)
		 -0.36*sin(2*u3)*t
		 +1.04*sin(3*u3)
		 +0.03*cos(-u2)-0.07*sin(-u2) ;
	
	double Av[16][2] = {
		{ 2.35,-4.23},
		{-0.10, 0.06},
		{-0.06,-0.03},
		{-4.70, 2.90},
		{ 1.80,-1.74},
		{-0.67, 0.03},
		{ 0.03,-0.03},
		{ 1.51,-0.40},
		{-0.19,-0.09},
		{ 0.76,-0.68},
		{-0.14,-0.04},
		{-0.05,-0.07},
		{ 0.15,-0.04},
		{-0.03,-0.03},
		{ 0,   -0.04},
		{-0.12,-0.03} } ;
	double kv[16][4] = {
		{1,-1, 1,-1},
		{1,-2, 1,-2},
		{2,-1, 2,-1},
		{2,-2, 2,-2},
		{3,-2, 3,-2},
		{3,-3, 3,-3},
		{4,-2, 4,-2},
		{4,-3, 4,-3},
		{4,-4, 4,-4},
		{5,-3, 5,-3},
		{5,-4, 5,-4},
		{5,-5, 5,-5},
		{6,-4, 6,-4},
		{6,-5, 6,-5},
		{6,-6, 6,-6},
		{7,-5, 7,-5} } ;
	for(i=0; i<16; i++) dLs+= (Av[i][0]*cos(kv[i][0]*u3+kv[i][1]*u2)+Av[i][1]*sin(kv[i][2]*u3+kv[i][3]*u2)) ;

	// Возмущения в долготе, обусловленные действием Марса.
	double Am[12][2] = {
		{-0.22, 0.17},
		{-1.66, 0.62},
		{ 1.96, 0.57},
		{ 0.40, 0.15},
		{ 0.53, 0.26},
		{ 0.05, 0.12},
		{-0.04,-0.20},
		{ 0,   -0.03},
		{ 0.05,-0.07},
		{-0.10, 0.11},
		{-0.05, 0},
		{ 0.05, 0.01} } ;
	double km[12][4] = {
		{ 1,-1, 1,-1},
		{ 1,-2, 1,-2},
		{ 2,-2, 2,-2},
		{ 2,-3, 2,-3},
		{ 2,-4, 2,-4},
		{ 3,-3, 3,-3},
		{ 3,-5, 3,-5},
		{ 4,-4, 4,-4},
		{ 4,-5, 4,-5},
		{ 4,-6, 4,-6},
		{ 5,-7, 5,-7},
		{ 5,-8, 5,-8} } ;
	for(i=0; i<12; i++) dLs+= (Am[i][0]*cos(km[i][0]*u3+km[i][1]*u4)+Am[i][1]*sin(km[i][2]*u3+km[i][3]*u4)) ;

	//Возмущения в долготе, обусловленные действием Юпитера
	double Au[12][2] = {	
		{ 0.01, 0.07},
		{-0.31, 2.58},
		{-7.21,-0.06},
		{-0.54,-1.52},
		{-0.03,-0.21},
		{-0.16, 0.05},
		{ 0.14,-2.73},
		{ 0.07,-0.55},
		{ 0.02,-0.08},
		{ 0.01,-0.07},
		{-0.16,-0.03},
		{-0.04,-0.01}} ;
	double ku[12][4] = {
		{-1,-1,-1,-1},
		{ 0,-1, 0,-1},
		{ 1,-1, 1,-1},
		{ 1,-2, 1,-2},
		{ 1,-3, 1,-3},
		{ 2,-1, 2,-1},
		{ 2,-2, 2,-2},
		{ 2,-3, 2,-3},
		{ 2,-4, 2,-4},
		{ 3,-2, 3,-2},
		{ 3,-3, 3,-3},
		{ 3,-4, 3,-4}} ;
	for(i=0; i<12; i++) dLs+= (Au[i][0]*cos(ku[i][0]*u3+ku[i][1]*u5)+Au[i][1]*sin(ku[i][2]*u3+ku[i][3]*u5)) ;

	//Возмущения в долготе, обусловленные действием Сатурна
	double As[4][2] = {	
		{ 0.0,  0.32},
		{-0.08,-0.41},
		{ 0.04, 0.10},
		{ 0.04, 0.10}} ;
	double ks[4][4] = {
		{ 0,-1, 0,-1},
		{ 1,-1, 1,-1},
		{ 1,-2, 1,-2},
		{ 2,-2, 2,-2}} ;
	for(i=0; i<4; i++) dLs+= (As[i][0]*cos(ks[i][0]*u3+ks[i][1]*u6)+As[i][1]*sin(ks[i][2]*u3+ks[i][3]*u6)) ;

	//------------------------------------------------------------------------
	// Возмущения в широте, обусловленные действием Венеры, Марса, Юпитера и Сатурна.
	double dBs = 0 ;

	double Bv[13][2] = {	
		{ 0.02,-0.02},
		{ 0.02, 0.0},
		{ 0.01,-0.09},
		{ 0.01,-0.01},
		{ 0.04,-0.06},
		{ 0.01, 0.0},
		{ 0.01,-0.01},
		{ 0.18,-0.10},
		{ 0.01, 0.0},
		{-0.03, 0.0},
		{ 0.01, 0.0},
		{-0.01, 0.0},
		{-0.02,-0.01}} ;
	double kbv[13][4] = {
		{ 0,-1, 0,-1},
		{ 1,-2, 1,-2},
		{ 2,-1, 2,-1},
		{ 2,-2, 2,-2},
		{ 3,-2, 3,-2},
		{ 3,-3, 3,-3},
		{ 4,-2, 4,-2},
		{ 4,-3, 4,-3},
		{ 5,-3, 5,-3},
		{ 5,-4, 5,-4},
		{ 6,-4, 6,-4},
		{ 6,-5, 6,-5},		
		{ 7,-5, 7,-5}} ;
	for(i=0; i<13; i++) dBs+= (Bv[i][0]*cos(kbv[i][0]*u3+kbv[i][1]*u2)+Bv[i][1]*sin(kbv[i][2]*u3+kbv[i][3]*u2)) ;

	dBs+= (0.01*sin(2.0*u3-2.0*u4) + 0.01*cos(3.0*u3-4.0*u4)) ;

	double Bu[7][2] = {	
		{ 0.0, -0.02},
		{ 0.02, 0.0},
		{ 0.0, -0.02},
		{ 0.01,-0.17},
		{ 0.0, -0.02},
		{ 0.01, 0.0},
		{ 0.01, 0.0}} ;
	double kbu[7][4] = {
		{-1,-1,-1,-1},
		{ 0,-1, 0,-1},
		{ 1,-1, 1,-1},
		{ 1,-2, 1,-2},
		{ 1,-3, 1,-3},
		{ 2,-1, 2,-1},
		{ 2,-3, 2,-3}} ;
	for(i=0; i<7; i++) dBs+= (Bu[i][0]*cos(kbu[i][0]*u3+kbu[i][1]*u5)+Bu[i][1]*sin(kbu[i][2]*u3+kbu[i][3]*u5)) ;

	dBs+= (-0.01*sin(u3-u6)) ;

	//------------------------------------------------------------------------
	// Возмущения в расстоянии, обусловленные действием Венеры, результат в км
	double dRs =-16707.37*cos(u3)-0.54*sin(u3)+(42.04*cos(u3)-0.15*sin(u3))*t+(0.13*cos(u3)-0.02*sin(u3))*t*t-
				139.57*cos(2.0*u3)+0.70*cos(2.0*u3)*t-1.75*cos(3.0*u3) ;
	double Rv[17][2] = {	
		{-0.16,-0.07},
		{-4.75,-2.64},
		{ 0.12, 0.20},
		{ 0.20,-0.01},
		{ 8.28, 13.42},
		{-1.44,-1.57},
		{ 0.11, 2.43},
		{ 0.10, 0.09},
		{-0.88,-3.36},
		{-0.38, 0.77},
		{ 0.30, 0.37},
		{-0.11, 0.43},
		{-0.31, 0.21},
		{-0.06,-0.21},
		{-0.09, 0.09},
		{-0.18, 0.02},
		{-0.08, 0.31}} ;
	double krv[17][4] = {
		{ 0,-1, 0,-1},
		{ 1,-1, 1,-1},
		{ 1,-2, 1,-2},
		{ 2,-1, 2,-1},
		{ 2,-2, 2,-2},
		{ 3,-2, 3,-2},
		{ 3,-3, 3,-3},
		{ 4,-2, 4,-2},
		{ 4,-3, 4,-3},
		{ 4,-4, 4,-4},
		{ 5,-3, 5,-3},
		{ 5,-4, 5,-4},
		{ 5,-5, 5,-5},
		{ 6,-4, 6,-4},
		{ 6,-5, 6,-5},
		{ 6,-6, 6,-6},
		{ 7,-5, 7,-5}} ;
	for(i=0; i<17; i++) dRs+= (Rv[i][0]*cos(krv[i][0]*u3+krv[i][1]*u2)+Rv[i][1]*sin(krv[i][2]*u3+krv[i][3]*u2)) ;

	// Возмущения в расстоянии, обусловленные действием Марса. 
	double Rm[13][2] = {	
		{-0.21,-0.27}, 
		{ 0.16, 0.28}, 
		{-1.32, 4.55}, 
		{-0.17, 0.46}, 
		{ 0.09,-0.22}, 
		{-0.35, 0.15}, 
		{ 1.06,-0.29}, 
		{ 0.20,-0.04}, 
		{ 0.10, 0.04}, 
		{ 0.20, 0.14}, 
		{-0.23,-0.22}, 
		{ 0.01,-0.14}, 
		{-0.02, 0.10}} ;
	double krm[13][4] = {
		{ 1,-1, 1,-1},
		{ 1,-2, 1,-2},
		{ 2,-2, 2,-2},
		{ 2,-3, 2,-3},
		{ 2,-4, 2,-4},
		{ 3,-3, 3,-3},
		{ 3,-4, 3,-4},
		{ 3,-5, 3,-5},
		{ 4,-4, 4,-4},
		{ 4,-5, 4,-5},
		{ 4,-6, 4,-6},
		{ 5,-7, 5,-7},
		{ 5,-8, 5,-8}} ;
	for(i=0; i<13; i++) dRs+= (Rm[i][0]*cos(krm[i][0]*u3+krm[i][1]*u4)+Rm[i][1]*sin(krm[i][2]*u3+krm[i][3]*u4)) ;

	// Возмущения в расстоянии, обусловленные действием Юпитера
	double Ru[12][2] = {	
		{ 0.18,-0.02}, 
		{ 0.52, 0.34}, 
		{ 0.13,-16.27}, 
		{ 3.09,-1.12}, 
		{ 0.38,-0.06},
		{-0.18,-0.31}, 
		{ 9.23, 0.48}, 
		{ 1.83, 0.25}, 
		{ 0.25, 0.06}, 
		{ 0.16, 0.04}, 
		{ 0.08,-0.64}, 
		{ 0.03,-0.17}} ;
	double kru[12][4] = {
		{-1,-1,-1,-1},
		{ 0,-1, 0,-1},
		{ 1,-1, 1,-1},
		{ 1,-2, 1,-2},
		{ 1,-3, 1,-3},
		{ 2,-1, 2,-1},
		{ 2,-2, 2,-2},
		{ 2,-3, 2,-3},
		{ 2,-4, 2,-4},
		{ 3,-2, 3,-2},
		{ 3,-3, 3,-3},
		{ 3,-4, 3,-4}} ;
	for(i=0; i<12; i++) dRs+= (Ru[i][0]*cos(kru[i][0]*u3+kru[i][1]*u5)+Ru[i][1]*sin(kru[i][2]*u3+kru[i][3]*u5)) ;
 
	// Возмущения в расстоянии, обусловленные действием Сатурна
	dRs+= 0.01*cos(-u6)+0.97*cos(u3-u6)-0.18*sin(u3-u6)-
		  0.23*cos(u3-2.0*u6)+ 0.10*sin(u3-2.0*u6)-
		  0.35*cos(2.0*u3-2.0*u6)+0.13*sin(2.0*u3-2.0*u6) ;

	// Числовое значение угла наклона мгновенной эклиптики к среднему подвижному экватору  
	SP.E0 = ZAverageE0(t, 2)/k_sekrad ;						// В радианах
	SP.E0g= SP.E0*k_grarad ;								// В градусах 
	// Расчет прямоугольных координат в Эклиптике
	double AU = 149597870.691 ;								// в км
	SP.R  = 1e-4*AU*(1.0001398-0.0000007*t+1e-6*dRs) ;		// в дткм
	SP.Ls = 4.93823996+u3+((6191.2+1.1*t)*t+dLs)/k_sekrad ;	// В радианах 
	SP.Bs = dBs/k_sekrad ; 
	SP.Lsg= SP.Ls*k_grarad ;								// В градусах
	SP.Bsg= SP.Bs*k_grarad ;

	// Прямоугольные координаты в эклиптике
	double Xe[3] ;
	Xe[0] = SP.R*cos(SP.Bs)*cos(SP.Ls) ;	// Результат в дткм 
	Xe[1] = SP.R*cos(SP.Bs)*sin(SP.Ls) ;	// 
	Xe[2] = SP.R*sin(SP.Bs) ;				//
	
	// Матрица поворота вокруг оси X на угол -E0
	double MX[9] = {
		1.0,	 0.0,	    0.0,
		0.0,	 cos(-SP.E0),  sin(-SP.E0),
		0.0,	-sin(-SP.E0),  cos(-SP.E0)} ;

	// Пересчет координат Xe в геоцентрическую экваториальную для текущего экватьра - координаты SP.XTE
	umpr(MX, Xe, SP.XTES);
	// Прямое восхождение и склонение для текущегго экватора
	// Для сверки с ежегодником
	SP.alf = Atan2(SP.XTES[1], SP.XTES[0], 0) ;		// В радианах
	SP.dlt = Asin (SP.XTES[2]/SP.R, 0) ;
	SP.alfg= SP.alf*k_grarad ;						// В градусах
	SP.dltg= SP.dlt*k_grarad ;
#endif

	// Матрица прецессии
	double MP[9]; ZBuildMatrPrecessJ2000(t, MP, TIMEJ2000JC) ; 
	// Пересчет координат SP.XTES в геоцентрическую экваториальную СК эпохи 2000 года - координаты SP.X2000
	umobr(MP, SP.XTES, SP.X2000);

	SP.ta = ta ;
	SP.t0 = t ;
	if (!notStory) memcpy(&last_inquiry_SunPoint, &SP, sizeof(ZSUN_POINT)) ;
	return 0 ;
}

//----------------------------------------------------------------------------
// Возвращает f-истинную аномалию по эксцентриситету e
// и средней аномалии l . Только для почти круговых орбит.
//----------------------------------------------------------------------------
double TrueAnom_fromAvrAnom(double e, double l)
{	
	static const double kfc[9]={
		5.0/96.0,		-0.25,			2.0,
		-11.0/12.0,		1.25,			-43./64.0,	
		13.0/120,		103.0/96.0,		1097./960} ;
	double x1,y1,x2,y2,x4,y4,e2;
	double kepf=l;
	x1=e*cos(l);
	y1=e*sin(l);
	x2=x1*x1-y1*y1;
	y2=x1*y1*2;
	x4=x2*x2-y2*y2;
	y4=y2*x2*2;
	e2=e*e;
	kepf+=	((kfc[0]*e2+kfc[1])*e2+kfc[2])*y1+
			( kfc[3]*e2+kfc[4])*y2+
			( kfc[5]*e2+kfc[6])*(y2*x1+x2*y1)+
			  kfc[7]*y4+kfc[8]*(y4*x1+y1*x4);
	return kepf ;
}

//----------------------------------------------------------------------------
//	time - время 
//  flagtime:
//		0 - time задано в ссс от J2000 (0h 01.01.2000)
//		1 - time задано в ссс от J1975 (0h 01.01.1975)
//		2 - time задано в юлианских столетиях от J2000 (12h 01.01.2000)
//	xs   - массив результатов
//	prizn = 0 -альфа,дельта,радиус
//		 != 0 -X,Y,Z
//----------------------------------------------------------------------------
void ZSunSimple(double ta, TIMESCALE Scale, double *xs, short prizn)
{
	double t = Astro2000Time(ta, Scale, &ta) ;

	static const double koef[13]={
	1.0932,	129602771.363, 361679.215, 1.655, 6190.339, 370574.453,
	-0.1236e-6, -0.4204e-4, 0.016708617, -20.49, 648000.0, 1.4959787e+4,	
	1.00000101778} ;
	const double *kf;
	double arg[3],x,y;
	short i;

	kf=koef;
	for (i=0;i<3;kf+=3) arg[i++]=(kf[0]*t+kf[1])*t+kf[2];

	(*arg) = TrueAnom_fromAvrAnom(arg[2], (arg[0] - arg[1]) / M_SEKRAD);

	x=1-arg[2]*arg[2];
	y=1+arg[2]*cos(arg[0]);
	arg[1] = arg[0] + (arg[1] + kf[0] * y + kf[1]) / M_SEKRAD;
	x*=kf[2]*kf[3]/y;

	y = sr_E0_IERS(t) / M_SEKRAD;

	xs[0]=x*cos(arg[1]);
	xs[1]=(t=x*sin(arg[1]))*cos(y);
	xs[2]=t*sin(y);

	if (prizn) return ;

	t=atan2(xs[2],sqrt(xs[0]*xs[0]+xs[1]*xs[1]));
	xs[2]=x ;
	xs[0]=atan2(xs[1],xs[0]) ;
	xs[1]=t ;
}