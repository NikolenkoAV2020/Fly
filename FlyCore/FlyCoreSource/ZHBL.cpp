//---------------------------------------------------------------------------
// ZHBL.cpp
// А. Николенко 03.08.2018
//---------------------------------------------------------------------------
#include <stdafx.h>
#pragma   hdrstop
//---------------------------------------------------------------------------
#include <FlyMMath.h>	// Математические функции
#include <FlyTime.h>	// Всё про время

#include <FlyCoreSource\\ModType.h>
#include <FlyCoreSource\\ModGlobal.h>
#include <FlyCoreSource\\ZNUT.h>
#include <FlyCoreSource\\ZSK.h>
#include <FlyCoreSource\\ZHBL.h>

//---------------------------------------------------------------------------
// Преобразование гринвических координат в широту долготу и высоту
//  hbl     - высота в дткм
//          - широта и долгота в радианах
//  gk      - координаты в ГСК, дткм
//          - скорости в ГСК, дткм/ссс
//	pr		- направление преобразования
//			0 - Гринвичские координаты в HBL
//			1 - HBL в Гринвичские координаты
//	oze		- эллипсоида	
//			0 - общеземной элипсоид
//			1 - элипсоид Красовского
//			2 - заданный элипсоид с параметрами ellipse
//	ellipse	- параметры заданного эллипсоида
//	nk		- матрица направляющих косинусов
//---------------------------------------------------------------------------
void ZGRtoHBL(double* gk, double* hbl, short pr, short oze, double* nk, double* ellipse )
{
	double b=0., z, r1, c, s, h, sb, cb, sl, cl, eps=1.e-7, bp, a0, alfa0, nk3, nk4;

	switch( oze )  {
    case 0 : a0 = k_a0 ; alfa0 = k_alfa0 ; break ;
    case 1 : a0 = k_ak ; alfa0 = k_alfak ; break ;
    default: 
		if (!ellipse) assert(0) ;
		a0 = ellipse[0] ; alfa0 = ellipse[1] ;
	}

	// Гринвичские координаты  ->  HBL(геогр.) ???? наверно все же геодезические ????
	if(!pr) {
		r1 = gk[0]*gk[0]+gk[1]*gk[1] ; 
		sb = sqrt(r1) ;
		z  = gk[2] ;
		do { 
			bp = b ;
			b  = dargum(sb, z) ;
			s  = sin(b) ;
			h  =(2.0-alfa0)*alfa0*s ;
			c  = a0/sqrt(1.-h*s) ;
			z  = gk[2]+c*h ;
	    } while (fabs(b-bp) > eps) ;

		hbl[0] = sqrt(z*z+r1)-c ;
		hbl[1] = b ;
		hbl[2] = dargum(gk[0],gk[1]) ;
		if(!nk) return ;
	}

	// Расчет направляющих косинусов
	sb = sin(hbl[1]) ;
	cb = cos(hbl[1]) ;
	sl = sin(hbl[2]) ;
	cl = cos(hbl[2]) ;
	nk3 = cb*cl ;
	nk4 = cb*sl ;

	// Расчет матрицы направляющих косинусов
	if(nk) {
		nk[0] =-sb*cl;  nk[3] = nk3;   nk[6] =-sl;
		nk[1] =-sb*sl;  nk[4] = nk4;   nk[7] = cl;
		nk[2] = cb   ;  nk[5] = sb ;   nk[8] = 0.;
	}
	// HBL(геогр.) ->  Гринвичские координаты
	if (pr==1) {
		c = a0/sqrt(1.-alfa0*(2.-alfa0)*sb*sb) ;
		s = c*(1.-alfa0)*(1.-alfa0)+hbl[0] ;
		c+= hbl[0] ;
		gk[0] = c*nk3 ;
		gk[1] = c*nk4 ;
		gk[2] = s*sb ;
	}
}

//---------------------------------------------------------------------------
//    Подпрограмма формирования матрицы перехода от новых координат
//    к старым по углу поворота и оси,задаваемых вектором Омега[3].
//    Направление поворота отсчитывается  против  часовой  стрелки,
//    если смотреть с конца  вектора Омега[3]. Величина  поворота в
//    радианах равна длине вектора.Если угол поворота отсчитывается
//    по  часовой стрелке, то матрица получится  транспонированной.
//    Расположение элементов матрицы в памяти : 11,12,13,21...32,33
//    (Координаты в старой СК) = Матрица * (Координаты в повернутой СК).
//    Матрица ортонормированная.
//---------------------------------------------------------------------------
void ZPovorotOmega(double *omga,double *Mt)
{
	double u=0;
	double e[3],c,s;
	short i,j;
	for (i=3;--i>=0;u+=omga[i]*omga[i]);
	u=sqrt(u);
	for (i=3;--i>=0;)    { if(u!=0) e[i]=omga[i]/u ; else e[i]=0; }
	c=cos(u);
	Mt+=9;
	for (i=3;--i>=0;){
		s=(1-c)*e[i];
		for (j=3;--j>=0;*(--Mt)=s*e[j]);
	}
	for (i=3;--i>=0;Mt+=4) (*Mt)+=c;
	Mt-=12;
	s=sin(u);
	c=e[0]*s;
	Mt[7]+=c;
	Mt[5]-=c;
	c=e[1]*s;
	Mt[2]+=c;
	Mt[6]-=c;
	c=e[2]*s;
	Mt[3]+=c;
	Mt[1]-=c;
}

//---------------------------------------------------------------------------
//	Функция перехода из геоцент. ЭКр в ГСК и обратно
//	dr - поправки к координатам центра ЭК относительно центра ОЗЭ
//	om - разворот осей ЭК относительно ОЗЭ
//	gr - гринв. координаты
//	kras - координаты относит. цента ЭК
//---------------------------------------------------------------------------
void ZGRtoKRAS(short pr,double *gr,double *kras,double *dr,double *om)
{
	short i;
	double Mt[9],x[3];
    ZPovorotOmega(om, Mt) ;
	if ( pr )  {
		// Перевод из СК Красовского в ГСК
		Um_Mat(Mt,kras,x,3,3,1);
		// Пока m всегда равна 0 поэтому закоментировано
		// for (i=3;--i>=0;x[i]*=1+m;
		for (i=0; i<3; i++) gr[i] = x[i]+dr[i] ;
	} else {
		// Перевод из ГСК в СК Красовского
		for (i=0; i<3; i++) x[i] = gr[i]-dr[i] ;
		Um_Mat(x,Mt,kras,1,3,3);
		//Пока m всегда равна 0 поэтому закоментировано
		//for (i=3;--i>=0;kras[i]/=1+m;
	}
}

//---------------------------------------------------------------------------
// Перевод из hbl Красовского в ГСК и обратно
//		pr = 1 - hbl -> ГСК
//		pr = 0 - ГСК -> hbl
//---------------------------------------------------------------------------
void ZGSCtoHBLKR(double *gsk,double *hbl,short pr)
{
	double x[3];
	double  dwx= k_dwx ;
	double* om = &dwx ;
	double  dr[3] = {k_dx, k_dy, k_dz} ;
	if ( pr ) {
		// Переводим из hbl Красовского в ГСК
		ZGRtoHBL(x,hbl,pr,1,nullptr,nullptr);	//переход из hbl Крас. в xyz Крас.
		ZGRtoKRAS(pr,gsk,x,dr,om);		//переход из геоцентр. ЭКр. в ГСК
	} else {
		// Переводим из ГСК в hbl Красовского
		ZGRtoKRAS(pr,gsk,x,dr,om);		//переход из ГСК в геоцентр. ЭКр.
		ZGRtoHBL(x,hbl,pr,1,nullptr,nullptr);	//переход из xyz Крас. в hbl Крас.
	}
}

//---------------------------------------------------------------------------