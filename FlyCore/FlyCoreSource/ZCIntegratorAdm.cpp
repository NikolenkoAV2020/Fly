//-------------------------------------------------------------------------------
// ZCIntegrator.cpp
// А. Николенко 03.08.2018
// Реализация многошаговых методов Адамса
//-------------------------------------------------------------------------------
#include <stdafx.h>

#include <FlyMMath.h>

#include <FlyCoreSource\\ModType.h>
#include <FlyCoreSource\\ModGlobal.h>
#include <FlyCoreSource\\ZCIntegrator.h>

//-------------------------------------------------------------------------------
int ZCIntegrator::CreateAdm( ) 
{
	// Для 8 точек 7-й степени
	AdmN = 8 ;
	CalcAdamsKf( AdmN-1, Kpredict, Kcorrect ) ;
	for (int i=0 ; i<2*MAX_ADAMS_N+1; i++) GI[i] = new double[m_N] ; 
	CountGI = 0 ;
	
	AdmStepMax	= m_cs.step_max ;
	AdmStepMin	= m_cs.step_min ;	
	AdmStep		= AdmStepMin ;
	AdmEps1		= 1e-11 ;
	AdmEps2		= 1e-7 ;
	return 1 ;  
}

//-------------------------------------------------------------------------------
// Один шаг методом Адамса
void ZCIntegrator::StepAdams( double* dq )
{
	int i, j ;
	int N = NE() ;

	// Проверка необходимости разгона 
	if (CountGI<AdmN) {
		// Если разгон не закончен то делается очередной шаг методом РК 
		// шаг при этом равен разгонному шагу - он же минимальный шаг метода Адамса

		// Смещаем группы интегрирования
		if (CountGI>0) {
			for (i=2*AdmN-CountGI; i<2*AdmN ; i++) memcpy( GI[i], GI[i+1], N*sizeof(double) ) ;		
		}
		// Фиксированный шаг методом РК с расчётом правых частей СДУ
		StepRK8(nullptr, GI[2*AdmN], AdmStepMin, true) ;
		// Копируем производные
		if (dq) memcpy(dq, GI[2*AdmN], N*sizeof(double)) ;
		CountGI++ ;
		// Если разгон закончен то основной шаг метода адамса устанавливаем равным минимальному шагу,
		// то есть тому шагу с которым разгонялись
		if (CountGI>=AdmN) AdmStep = AdmStepMin ;
		return ;
	}

	// Если разгон завершен то выполняется шаг по методу Адамса -
	// - расчет по экстраполяционной формуле, потом по интерполяционной

	//------------------------------------------------
	// Предиктор
    double step = m_up*AdmStep ;
    for (j=0 ; j<N ; j++)  {
		m_x[j] = m_a[j] ;
		for(i=0 ; i<AdmN ; i++) m_x[j]+= step*Kpredict[i]*GI[AdmN+i+1][j] ;
	}
	// Смещаем группы интегрирования
	int i0=2*AdmN-CountGI ;
	for (i=i0<0?0:i0 ; i<2*AdmN ; i++) memcpy(GI[i], GI[i+1], N*sizeof(double)) ;
	// расчёт правых частей СДУ для вектора полученного по предиктору
    SphExe(m_x, GI[2*AdmN]) ;

	//------------------------------------------------
	// Корректор
    for (j=0 ; j<N ; j++) {
		// Сразу формируем новое значение вектора состояния
		for (i=0 ; i<AdmN ; i++) m_a[j]+= step*Kcorrect[i]*GI[AdmN+i+1][j] ;
	}
	// расчёт правых частей СДУ для вектора полученного по корректору
    SphExe(m_a, GI[2*AdmN]) ;

	// Очередной шаг выполнен и можно увеличить число расчитанных групп интегрирования
	if (CountGI<2*AdmN+1) CountGI++ ;

	if (dq) memcpy(dq, GI[2*AdmN], N*sizeof(double)) ;

	{
	//------------------------------------------------
	// Формируем разницу между векторами состояния полученными по предиктору и по корректору
	// для оценки возможности удвоения шага и контроля необходимости деления шага
	for (i=0 ; i<N ; i++) m_d[0][i] = m_a[i]-m_x[i] ;

	//------------------------------------------------
	// Анализ возможности деления или удвоения шага интегрирования	
	int CP = 0 ;
	for(i=0 ; i<N ; i++) {
		if ( fabs(m_d[0][i])<AdmEps1) CP++;
		if ( fabs(m_d[0][i])>AdmEps2) CP--;
	}
	if (CP==8 && CountGI==2*AdmN+1 && AdmStep<AdmStepMax/2) {
		// Обнаружена возможность увеличения шага
		CountGI = AdmN ;
		AdmStep*= 2.0 ;
		// Смещаем груммы интегрирования
		for (i=2*AdmN-2, j=2*AdmN-1 ; i>=0 ; i-=2, j--) memcpy(GI[j], GI[i], N*sizeof(double)) ;
	} 
	if (CP<0 && AdmStep>2*AdmStepMin) {
		// Обнаружена необходимость деления шага

	}
	}
}

//-------------------------------------------------------------------------------
// Вычисление интегралов входящих в коэффициенты 
// семейства методов Адамса для интегрирования СДУ
//	1
//	I( (t+k0)(t+k1)(t+k2)(t+k3)...(t+k(n-1)) )*dt - Всего под интегралом n множителей  
//	0
//		n - число произведений под интегралом		
//		k - свободные члены во множителях   
//		I - значение определенного интеграла 		
void ZCIntegrator::CalcAdamsI( int n, double* k, double& I )
{
	double* A = new double[ n+1 ] ;	memset( A, 0, (n+1)*sizeof( double ) ) ;
	// Первый множитель ( t+k0 )  
	A[0] = k[0] ;
	A[1] = 1 ; 
	// Раскрываем все скобки и получаем полином степени n с
	// т+1 коэффициентами, свободный член равен k0*k1*...*k(n-1)
	//A[i]   = A[i-1] + k[i-1]A[i] ;
	//A[i-1] = A[i-2] + k[i-1]A[i-1] ;
	//A[i-2] =          k[i-1]A[i-2] ;
	int i, j ;
	for ( i=2 ; i<=n ; i++ ) {
		for ( j=0 ; j<=i ; j++ ) A[i-j] = ( j < i ? A[i-1-j] : 0 ) + k[i-1]*A[i-j] ;
	}
	// Значение определенного интеграла
	I = 0 ; 
	for ( i=0 ; i<=n ; i++ ) I+=A[i] / (double)(i+1) ; 	
	delete[] A ; A = 0 ; 
}

//-------------------------------------------------------------------------------
// Вычисление коэффициентов, входящих в методы Адамса для интегрирования СДУ
//	N 		- порядок метода (число точек, а значит и число искомых
//			  коэффициентов и предиктора и корректора, на 1 больше)
//	Kpredict- коэффициенты предиктора
//	Kcorrect- коэффициенты корректора
void ZCIntegrator::CalcAdamsKf( int N, double* Kpredict, double* Kcorrect )
{
//	double dKoef_Predikt[8] = {
//       0.3589955357142857e+01,	// это b07
//      -0.9525206679894181e+01,
//       0.1805453869047619e+02,
//      -0.2202775297619048e+02,
//       0.1737965443121693e+02,
//      -0.8612127976190477e+01,
//       0.2445163690476190e+01,
//      -0.3042245370370371e+00};
//	double dKoef_Korrekt[8] = {
//       0.3042245370370370e+00,
//       0.1156159060846561e+01,
//      -0.1006919642857143e+01,
//       0.1017964616402117e+01,
//      -0.7320353835978837e+00,
//       0.3430803571428572e+00,
//      -0.9384093915343916e-01,
//       0.1136739417989418e-01};
//	double dKoef_Interp[56] = {
//	  0.1984126984126984e-03,  -0.4166666666666667e-02,   0.3472222222222222e-01,
//	 -0.1458333333333333e+00,   0.3222222222222222e+00,  -0.3500000000000000e+00,
//	  0.1428571428571428e+00,  -0.1388888888888889e-02,   0.3055555555555555e-01,
//	 -0.2638888888888889e+00,   0.1138888888888889e+01,  -0.2568055555555556e+01,
//	  0.2830555555555556e+01,  -0.1166666666666667e+01,   0.4166666666666667e-02,
//	 -0.9583333333333334e-01,   0.8625000000000000e+00,  -0.3854166666666667e+01,
//	  0.8933333333333334e+01,  -0.1005000000000000e+02,   0.4200000000000000e+01,
//	 -0.6944444444444444e-02,   0.1666666666666667e+00,  -0.1569444444444444e+01,
//	  0.7333333333333333e+01,  -0.1767361111111111e+02,   0.2050000000000000e+02,
//	 -0.8750000000000000e+01,   0.6944444444444444e-02,  -0.1736111111111111e+00,
//	  0.1715277777777778e+01,  -0.8465277777777779e+01,   0.2161111111111111e+02,
//	 -0.2636111111111111e+02,   0.1166666666666667e+02,  -0.4166666666666667e-02,
//	  0.1083333333333333e+00,  -0.1125000000000000e+01,   0.5916666666666667e+01,
//	 -0.1637083333333333e+02,   0.2197500000000000e+02,  -0.1050000000000000e+02,
//	  0.1388888888888889e-02,  -0.3750000000000000e-01,   0.4097222222222222e+00,
//	 -0.2312500000000000e+01,   0.7088888888888889e+01,  -0.1115000000000000e+02,
//	  0.7000000000000000e+01,  -0.1984126984126984e-03,   0.5555555555555556e-02,
//	 -0.6388888888888888e-01,   0.3888888888888889e+00,  -0.1343055555555555e+01,
//	  0.2605555555555556e+01,  -0.2592857142857143e+01 };

	int i, j, l ;
	double I, *K = new double[ N ] ;
	for( j=0 ; j<=N ; j++ ) {
		for( i=0, l=0 ; i<=N ; i++ ) { if ( i != j ) { K[l] = (double)i ; l++ ; } }
		CalcAdamsI( N, K, I ) ;
		Kpredict[N-j] = pow(-1.0, j) / FK(j) / FK(N-j) * I ; 
	}
	for( j=-1 ; j<N ; j++ ) {
		for( i=-1, l=-1 ; i<N ; i++ ) { if ( i != j ) { K[l+1] = (double)i ; l++ ; } }
		CalcAdamsI( N, K, I ) ;
		Kcorrect[N-(j+1)] = pow(-1.0, j+1) / FK(j+1) / FK(N-1-j) * I ; 
	}
	delete[] K ; K = 0 ;
}

//-------------------------------------------------------------------------------