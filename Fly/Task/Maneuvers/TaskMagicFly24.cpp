//-----------------------------------------------------------------------------
// TaskMagicFly24.cpp : 
// А. Николенко 24.08.2018
//
// 24-й вариант LNS-маневра
// L,T+h,Bh или L,T+e,w для ОМИВ, ДУ, ЭО
//-----------------------------------------------------------------------------
#include "stdafx.h"

//-----------------------------------------------------------------------------
// Компоненты Fly
#include <FlyMMath.h>		// Математические функции
#include <FlyMagicLNS.h>	// Метод узловых точек

//-----------------------------------------------------------------------------
#include <FlyMagicLNSSource/MagicSolution.h>

int TaskMagicFlyBegin(ZSMagicLnsSolution* MS, int task, ZMSC& KA,
	ZNU& NU, ZLSF& LSF, bool ResetNU, ZCPrintManager* PrintMng,
	FILE** pfp);

//-----------------------------------------------------------------------------
int TaskMagicFly24(int TypeOrb)
{
	// идентификатор задачи (иными словами номер варианта маневрирования)
	int indexTask = 24;
	// Выбирается одини из тестовых НУ и соответственно требуемые 
	// параметры орбиты. 
	int varNU = 1;
	int rc = 0;

	//-------------------------------------------------------------------------
	// Создаём "Модель решения"
	// По сути своей модель решения это контейнер, который содержит: 
	//		- характеристики двигутельной установки, 
	//		- массив параметров задачи (опции),
	//		- задание на решение задачи (массив информации, обычно задаваемый 
	//		  оператором в интерактивном режиме).
	// ... Таким образом эту самую модель перед решением нужно создать.
	//-------------------------------------------------------------------------
	ZSMagicLnsSolution* MS = CreateMagicLnsSolution(); if (!MS) return 1;

	//-------------------------------------------------------------------------
	// TypeOrb - Тип требуемой орбиты
	//		SPO_ORB_EL	- геометрия требуемой орбиты задаётся как e, w.
	//		SPO_ORB_HBH	- геометрия требуемой орбиты задаётся как Hmin, Bhmin.
	//		SPO_ORB_OMIV- параметры требуемой орбиты обеспечивают минимальное.
	//					  изменение высоты на витке (e, w выбираются исходя из 
	//					  условия ОМИВ).
	//		SPO_ORB_DU	- параметры требуемой орбиты обеспечивают динамическую
	//					  устойчивость (e, w выбираются исходя из условия ДУ).
	//-------------------------------------------------------------------------
	MS->MZ.ORB() = TypeOrb;

	//-------------------------------------------------------------------------
	// Инициализация НУ, ЛШС и модели движения, настройка документирования
	//-------------------------------------------------------------------------
	ZNU   NU;			// НУ движения КА.
	ZLSF  LSF;			// Логическая шкала сил в которой выполняется решение. 
	ZMSC  KA;			// Модель движения (или просто КА)
	FILE* fp = nullptr;	// Файл для документирования результатов решения
	// Диспетчер документирования
	// Несмотря на то что диспетчер документирования ZCPrintManager был разработан
	// для документирования результатов прогноза, он находит своё применение и
	// в прикладных задачах, в части касающейся создания документа, вывода 
	// заголовка документа, документирования НУ и ЛШС, документирования 
	// информации о времени расчёта и его длителоьности, форматированного 
	// документирования данных в заданный контекст (просто говоря в звдвнный 
	// файл). 
	// В итоге диспетчер документирования нам нужен!
	ZCPrintManager PrintMng;

	// Интегрирование вместе с уравнениями движения 
	// компонент вектора эксцентриситета
	ZCExternalEquationsDefinition EED;
	EED << EXTEQ_ID_avrT_ex;
	EED << EXTEQ_ID_avrT_ey;
	// Интегрирование высоты полёта над ОЗЭ
	EED << EXTEQ_ID_avrT_H;

	//-------------------------------------------------------------------------
	// Формирование НУ движения КА
	NU.Key.ka = 1; NU.Key.nom = 15; NU.Key.mod = 0;
	NU.Key.type = 8; NU.Key.bc = 1;
	NU.numlsf = 1;
	if (varNU == 1) {
		// НУ для сверки вариант 24 - ТЕСТ 1,
		NU.t << DATETIMEDMB(14, 12, 2015, 12, 0, 0, 0);
		NU.vit = 1;
		NU.sk = _SK_GSK;
		NU.X[0] = TO_DTKM(-6587.1866159);
		NU.X[1] = TO_DTKM(-436.2698529);
		NU.X[2] = TO_DTKM(0);
		NU.X[3] = TO_DTKMSSS(0.1687606245);
		NU.X[4] = TO_DTKMSSS(-2.5480965961);
		NU.X[5] = TO_DTKMSSS(7.1501923050);
		NU.Sb = 0.014 / 9.80665*2.0;
		NU.Kp = 0;
		NU.M0 = 5500;
		NU.MF = 500;
	} else {
		// НУ для сверки вариант 24 - ТЕСТ 2
		NU.t << DATETIMEDMB(14, 12, 2015, 12, 0, 0, 0) ;
		NU.vit  = 2 ;
		NU.sk   = _SK_GSK ;
		NU.X[0] = TO_DTKM(-6253.8800322 ) ;
		NU.X[1] = TO_DTKM( 2113.7267198 ) ;
		NU.X[2] = TO_DTKM( 0 ) ;
		NU.X[3] = TO_DTKMSSS(-0.8176778949 ) ;
		NU.X[4] = TO_DTKMSSS(-2.419300063 ) ;
		NU.X[5] = TO_DTKMSSS( 7.1503057135 ) ;
		NU.Sb   = 0.014/9.80665*2.0 ;
		NU.Kp   = 0 ;
		NU.M0   = 5500 ;
		NU.MF   = 500 ;
	}

	//-------------------------------------------------------------------------
	// Инициализация основных данных необходимых для решения тестовых задач
	// расчёта параметров орбитального маневрирования - задание на расчёт
	// "фиксированная" часть. 
	// Данный метод общий для
	// всех тестовых процедур именованных как TaskMagicFly__.
	// В "Prodaction" необходимость в данном методе отпадает. Вся его 
	// функциональная нагрузка ложится на GUI 
	// и/или на средства автоматизации АПК.
	rc = TaskMagicFlyBegin(MS, indexTask, KA, NU, LSF, false, &PrintMng, &fp); 
	if (rc) goto end;

	//-------------------------------------------------------------------------
	// Формирование задания на расёт (формируется в интерактивном режиме 
	// с использованием GUI)
	if (varNU == 1) {
		// ТЕСТ 1 (сравнение с BVN-маневром)
		MS->MZ.VITIMP(0) = 2;		// Виток первого импульса
		MS->MZ.VITIMP(1) = 4;		// Виток второго импульса
		MS->MZ.VIT()     = 5;		// Заданный виток на котором контролируются 
		// краевые условия
		MS->MZ.PARL() = 93.653;		// Долгота ВУ
		MS->MZ.PART() = 5355.66;	// Драконический период
		MS->MZ.PARh() = 226.3;	// Минимальная высота
		//MS->MZ.PARh() = 240.0;		// Минимальная высота
		MS->MZ.PARBh()= 16.5;		// Широта минимальной высоты
		MS->MZ.PARBv()= 0;			// 
		MS->MZ.PARe() = 0.000655;	//	
		MS->MZ.PARw() = 180.0;		//	
	}
	else {
		// ТЕСТ - 2 (сравнение с BVN-маневром)
		MS->MZ.VITIMP(0) = 2;		// Виток первого импульса
		MS->MZ.VITIMP(1) = 17;		// Виток второго импульса
		MS->MZ.VIT()     = 30;		// Заданный виток на котором контролируются
		// краевые условия
		MS->MZ.PARL()  = 250.74;	// Долгота ВУ
		MS->MZ.PART()  = 5331.24;	// Драконический период
		MS->MZ.PARh()  = 220.0;		// Минимальная высота
		MS->MZ.PARBh() = 6.6;		// Широта минимальной высоты
		MS->MZ.PARBv() = 1;			//
	}

	// Взводим флаг уточнения формы орбиты для того чтобы
	// На итерациях изменять прицельные значения минимальной высоты и её широты
	MS->MP.isEstimateOrb = true;

	//-------------------------------------------------------------------------
	// Решение задачи расчёта параметров коррекции по заданию MZ 
	{
		ZSLoopFact  P1;	// Параметры движения на виток первого имп 
		ZSLoopFact  P2;	// Параметры движения на виток второго имп 
		ZSLoopFact  PN;	// Начальные параметры движения на заданный виток
		ZSLoopFact  PR;	// Расчётные конечные параметры движения на заданный вит. 
		ZSFlightRule U;	// Прогрмамма управления

		// Процедура итерационного решения формализованной задачи расчёта 
		// методом узловых точек. Данная процедура является единой для всех 
		// тестовых задач именованных как TaskMagicFly__. 
		rc = MagicSolution(MS, &PrintMng, fp, LSF, KA, NU, nullptr, 
						   &P1, &P2, &PN, &PR, &U);
		// Закрытие документа с результатами решения
		PrintMng.ClosePrint(&fp);
	}
end:;
	//-------------------------------------------------------------------------
	// В завершении удаляем созданную ранее "Модель решения"
	FreeMagicLnsSolution(MS);
	return rc;
}

//-----------------------------------------------------------------------------